{
  "version": "1.0",
  "conceptualSchemaSettings": {},
  "queries": [
    {
      "name": "DataFiles_Cubes",
      "lineageTag": "caefe577-f8ee-4a89-8889-066ab433028c",
      "queryGroupId": "6b9bd30e-c3b7-4f80-bccb-4793bd9fbb08",
      "navigationStepName": "Navigation",
      "text": [
        "let",
        "   Result = ",
        "      if ConnectionConfig[ConnectionType] = \"DataFiles\" then",
        "            let",
        "                //Source = ( try Table.Buffer(Folder.Files(ConnectionConfig[DataFilesPath])) otherwise Table.FromRecords({ [Name = null, Extension = null] }) )[[Name], [Extension]],",
        "                // Avoiding a dynamic data source when updating on the Service",
        "                Source = ( try Table.Buffer(Folder.Files(#\"31 DATA FILES PATH\")) otherwise Table.FromRecords({ [Name = null, Extension = null] }) )[[Name], [Extension]],",
        "                CubeSelection1 = Table.SelectRows(Source, each FileExtentions{[Name = \"Cube\"]}[Extension] = Text.Lower([Extension])),",
        "                //no cubes in the model given",
        "                CubeSelection2 = if Table.IsEmpty(CubeSelection1) then Table.SelectRows(Source, each FileExtentions{[Name = \"Rule\"]}[Extension] = Text.From([Extension])) else CubeSelection1,",
        "                NameSelection = Table.SelectRows(CubeSelection2, each ",
        "                                                        let ",
        "                                                            Name = [Name], ",
        "                                                            NameFilter = List.MatchesAny( KeyWords[SysMetaDataRef], each not Text.StartsWith( Name, _ ))",
        "                                                        in ",
        "                                                            NameFilter",
        "                                ),",
        "                RemoveExtensionFromName = Table.ReplaceValue(  NameSelection",
        "                                                                , each [Extension]",
        "                                                                , each \"\"",
        "                                                                , Replacer.ReplaceText",
        "                                                                , {\"Name\"}  ",
        "                                                            ),                        ",
        "                RemovedExt = Table.RemoveColumns(RemoveExtensionFromName,{\"Extension\"}),",
        "                RenameColumn = Table.RenameColumns(RemovedExt,{{\"Name\", \"Cube\"}})",
        "            in",
        "                RenameColumn",
        "      else null",
        "in",
        "    Result"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Null",
      "isHidden": false
    },
    {
      "name": "DataFiles_Dimensions",
      "lineageTag": "ea764712-0866-4a33-a7f1-89b65cb627fc",
      "queryGroupId": "6b9bd30e-c3b7-4f80-bccb-4793bd9fbb08",
      "text": [
        "let",
        "    Result = ",
        "        if ConnectionConfig[ConnectionType] = \"DataFiles\" then",
        "            let",
        "                //Source = ( try Table.Buffer(Folder.Files(ConnectionConfig[DataFilesPath])) otherwise Table.FromRecords({ [Name = null, Extension = null] }) )[[Name], [Extension]],",
        "                // Avoiding a dynamic data source when updating on the Service",
        "                Source = ( try Table.Buffer(Folder.Files(#\"31 DATA FILES PATH\")) otherwise Table.FromRecords({ [Name = null, Extension = null] }) )[[Name], [Extension]],",
        "                ExtSelection = Table.SelectRows(Source, each FileExtentions{[Name = \"Dimension\"]}[Extension] = Text.Lower([Extension])),",
        "                NameSelection = Table.SelectRows(ExtSelection, each ",
        "                                                        let ",
        "                                                            Name = [Name], ",
        "                                                            NameFilter = List.MatchesAny( KeyWords[SysMetaDataRef], each not Text.StartsWith( Name, _ ))",
        "                                                        in NameFilter",
        "                                ),",
        "                RemoveExtensionFromName = Table.ReplaceValue(  NameSelection",
        "                                                                , each [Extension]",
        "                                                                , each \"\"",
        "                                                                , Replacer.ReplaceText",
        "                                                                , {\"Name\"}  ",
        "                                                            ),                        ",
        "                RemovedExt = Table.RemoveColumns(RemoveExtensionFromName,{\"Extension\"}),",
        "                RenameColumn = Table.RenameColumns(RemovedExt,{{\"Name\", \"Dimension\"}})",
        "            in",
        "                RenameColumn",
        "        else null",
        "in",
        "    Result"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "DataFiles_RulesAndProcesses",
      "lineageTag": "aa8c5d17-d5bb-436b-867d-27ef7a1f1748",
      "queryGroupId": "6b9bd30e-c3b7-4f80-bccb-4793bd9fbb08",
      "text": [
        "let",
        "   /* Result = ",
        "        if ConnectionConfig[ConnectionType] = \"DataFiles\" then",
        "            let */",
        "                //Source = ( try Table.Buffer(Folder.Files(ConnectionConfig[DataFilesPath])) otherwise Table.FromRecords({ [Content = null, Name = null, Extension = null] }) )[[Content], [Name], [Extension]],",
        "                // Avoiding a dynamic data source when updating on the Service",
        "                Source = ( try Table.Buffer(Folder.Files(#\"31 DATA FILES PATH\")) otherwise Table.FromRecords({ [Content = null, Name = null, Extension = null] }) )[[Content], [Name], [Extension]],",
        "                RemoveExtensionFromName = Table.ReplaceValue(  Source",
        "                            , each [Extension]",
        "                            , each \"\"",
        "                            , Replacer.ReplaceText",
        "                            , {\"Name\"}  ",
        "                ), ",
        "                LowCaseExtension = Table.TransformColumns(  RemoveExtensionFromName, { \"Extension\", ( val ) => Text.Lower(val) }, null, MissingField.Ignore ),   ",
        "                ",
        "                // Cubes with no rules",
        "",
        "                CubeExtensions = FileExtentions{[Name = \"Cube\"]}[Extension],",
        "                CubeSelection  = Table.SelectRows(LowCaseExtension, each [Extension] = Text.From(CubeExtensions) and [Content] <> null),",
        "                TransformCubeSelection = Table.FromRecords(",
        "                    Table.TransformRows(CubeSelection, ( rec ) as record => Record.TransformFields(rec, {{ \"Content\", each Binary.FromText(\"\") }, { \"Extension\", each Text.From(FileExtentions{[Name = \"Rule\"]}[Extension]) }}))",
        "                ),",
        "",
        "                // Rules and Processed",
        "",
        "                RuleAndProcessExtensions = { FileExtentions{[Name = \"Rule\"]}[Extension], FileExtentions{[Name = \"Process\"]}[Extension] },",
        "                RuleAndProcessSelection = Table.SelectRows(LowCaseExtension, each ",
        "                            let ",
        "                                Ext = [Extension], ",
        "                                ExtFilter = List.MatchesAny( RuleAndProcessExtensions, each _ = Text.From(Ext))",
        "                            in",
        "                                ExtFilter",
        "                ),",
        "",
        "                // Rows union",
        "                RowsUnion = Table.Combine({ TransformCubeSelection, RuleAndProcessSelection }),",
        "                NameSelection = Table.SelectRows(RowsUnion, each ",
        "                            let ",
        "                                Name = [Name], ",
        "                                NameFilter = List.MatchesAny( KeyWords[SysMetaDataRef], each not Text.StartsWith( Name, _ ))",
        "                            in",
        "                                NameFilter",
        "                ),",
        "                RowsGrouping = Table.Group(NameSelection, { \"Name\", \"Extension\" }, { \"Content\", each Binary.Combine([Content]) }, null, Comparer.OrdinalIgnoreCase),",
        "",
        "                // Other transformations",
        "                AddMetaData = Table.NestedJoin(RowsGrouping",
        "                            , \"Extension\"",
        "                            , FileExtentions",
        "                            , \"Extension\"",
        "                            , \"MetaDataTable\"",
        "                            , JoinKind.Inner ",
        "                        ),  ",
        "                ExpandMetaData = Table.ExpandTableColumn(AddMetaData, \"MetaDataTable\", {\"Name\"}, {\"MetaData\"}),                                                                                      ",
        "                TextContent = Table.AddColumn(ExpandMetaData, \"TextContent\", each Text.FromBinary([Content])),",
        "                RemovedBinaryContent = Table.RemoveColumns(TextContent,{\"Content\", \"Extension\"})",
        "",
        "in",
        "    RemovedBinaryContent",
        "       /* else null",
        "in",
        "    Result */"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "DataFiles_MessageLog",
      "lineageTag": "6b2ed82e-2631-4bef-b143-9c7dbbd85b80",
      "queryGroupId": "6b9bd30e-c3b7-4f80-bccb-4793bd9fbb08",
      "text": [
        "let",
        "    Result = ",
        "      if ConnectionConfig[ConnectionType] = \"DataFiles\" then",
        "            let",
        "                //Source = try Table.Buffer(Csv.Document(File.Content(ConnectionConfig[LogFilesPath] & \"tm1server.log\")), [Delimiter = \"#(lf)\", Columns = {\"Row\"}, Encoding = 65001, QuoteStyle = QuoteStyle.None])) otherwise Table.FromRecords({ [Row = null] }),",
        "                // Avoiding a dynamic data source when updating on the Service",
        "                Source =  try Table.Buffer(Csv.Document(File.Contents(#\"32 LOG FILES PATH\" & \"tm1server.log\"), [Delimiter = \"#(lf)\", Columns = {\"Row\"}, Encoding = 65001, QuoteStyle = QuoteStyle.None])) otherwise Table.FromRecords({ [Row = null] }),",
        "                SplitRows = Table.FromList(Source[Row], Splitter.SplitTextByDelimiter(\"   \", QuoteStyle.None), { \"ThreadID\", \"[]\", \"Level\", \"TimeStamp\", \"Logger\", \"Message\" }, null, ExtraValues.Ignore),",
        "                SelectNotNull = Table.SelectRows(SplitRows, each [TimeStamp] <> null)",
        "        in",
        "            SelectNotNull[[TimeStamp], [Level], [Message]]",
        "    else null",
        "in",
        "    Result"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "FileExtentions",
      "lineageTag": "85aef128-f876-4fb7-9874-423e73f61a72",
      "queryGroupId": "3377eb56-03e4-4ce7-968d-bb4471d7fb25",
      "text": [
        "let",
        "    Source = ",
        "        #table(",
        "                type table [Name = text, Extension = text], ",
        "                {",
        "                      {\"Cube\", \".cub\"}",
        "                    , {\"Dimension\", \".dim\"}",
        "                    , {\"Rule\", \".rux\"}",
        "                    , {\"Process\", \".pro\"}",
        "                    , {\"TransactionLog\", \".log\"}",
        "                }",
        "",
        "        )",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "KeyWords",
      "lineageTag": "c3a85601-6f73-48a0-812b-27635f0bd9b3",
      "queryGroupId": "3377eb56-03e4-4ce7-968d-bb4471d7fb25",
      "text": [
        "let",
        "    KeyWords =",
        "                [",
        "                      RuleCubeRef = {\"DB\", \"ConsolidatedMin\", \"ConsolidatedMax\", \"ConsolidatedAvg\", \"ConsolidatedCount\", \"ConsolidatedCountUnique\"}",
        "                    , RuleAttrRef = {\"AttrN\", \"AttrS\"}",
        "                    , ProcessCubeRef = {\"CellPutN\", \"CellPutS\", \"CellIncrementN\", \"CellPutProportionalSpread\"}",
        "                    , ProcessProcessRef = {\"ExecuteProcess\"}",
        "                    , FeederRef = \"FEEDERS;\"",
        "                    , SkipcheckRef = \"SKIPCHECK;\"",
        "                    , SysMetaDataRef = {\"}\"}",
        "                    , ElAttrRef = \"}ElementAttributes_\"",
        "                    , TransactionLogRef = \"tm1s\"",
        "                ]",
        "in",
        "    KeyWords"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "01 MODE",
      "lineageTag": "7842af7f-fea2-425c-abd0-a6391010802f",
      "description": "Mandatory. Select \"Service\" or \"Desktop\".\nUse \"Service\" on the Power BI Portal and \"Desktop\" in the Power BI Desktop",
      "queryGroupId": "3c598972-2685-4d67-9d26-73285509eef9",
      "text": [
        "\"Service\" meta [IsParameterQuery=true, List={\"Service\", \"Desktop\"}, DefaultValue=\"Service\", Type=\"Text\", IsParameterQueryRequired=true]"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Text",
      "isHidden": false
    },
    {
      "name": "02 CONNECTION TYPE",
      "lineageTag": "a6974d72-bf94-47c9-8622-9cd1a19e007e",
      "description": "Mandatory. Select \"REST\" or \"DataFiles\". \nThe \"DataFile\" connection does not require a running model but the functionality is limited",
      "queryGroupId": "3c598972-2685-4d67-9d26-73285509eef9",
      "text": [
        "\"REST\" meta [IsParameterQuery=true, List={\"REST\", \"DataFiles\"}, DefaultValue=\"REST\", Type=\"Text\", IsParameterQueryRequired=true]"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Text",
      "isHidden": false
    },
    {
      "name": "03 CONFIG PATH",
      "lineageTag": "b31f1bf7-0a42-44a0-829e-e865c9ecc171",
      "description": "Optional. The param is used to tune the application in the \"Desktop\" MODE",
      "queryGroupId": "3c598972-2685-4d67-9d26-73285509eef9",
      "text": [
        "\"X:\\\" meta [IsParameterQuery=true, Type=\"Text\", IsParameterQueryRequired=false]"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Text",
      "isHidden": false
    },
    {
      "name": "11 HTTP(S)://HOST:PORT",
      "lineageTag": "e43c0deb-abe9-406f-98fd-3918ade46b41",
      "description": "Mandatory.The address of the http(s) connection to the server. Use \"http(s)://HttpHost:HttpPort\" pattern.",
      "queryGroupId": "3c598972-2685-4d67-9d26-73285509eef9",
      "text": [
        "\"https://localhost:8886\" meta [IsParameterQuery=true, Type=\"Text\", IsParameterQueryRequired=false]"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Text",
      "isHidden": false
    },
    {
      "name": "12 LOGIN",
      "lineageTag": "f251a30b-f5b0-4736-8fc3-4c5ac41d1e1b",
      "description": "Mandatory.",
      "queryGroupId": "3c598972-2685-4d67-9d26-73285509eef9",
      "text": [
        "\"admin\" meta [IsParameterQuery=true, Type=\"Text\", IsParameterQueryRequired=false]"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Text",
      "isHidden": false
    },
    {
      "name": "13 PASSWORD",
      "lineageTag": "24f209f8-7711-454f-aae8-62f61c2863cb",
      "description": "Mandatory.\nThe password entered is not hidden behind asterisks!",
      "queryGroupId": "3c598972-2685-4d67-9d26-73285509eef9",
      "text": [
        "\"apple\" meta [IsParameterQuery=true, Type=\"Text\", IsParameterQueryRequired=false]"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Text",
      "isHidden": false
    },
    {
      "name": "14 NAMESPACE",
      "lineageTag": "6ec7006f-d327-4381-b100-da2ff4a37f3c",
      "description": "Mandatory if the server security mode is set to CAM authentication",
      "queryGroupId": "3c598972-2685-4d67-9d26-73285509eef9",
      "text": [
        "null meta [IsParameterQuery=true, Type=\"Text\", IsParameterQueryRequired=false]"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Null",
      "isHidden": false
    },
    {
      "name": "21 MAX TREE PATHS COUNT",
      "lineageTag": "e855521e-cd44-462d-aaa6-240907f71ce4",
      "description": "Mandatory. The maximum number of calculated paths in the model chains. The value depends on the Power BI Server performance",
      "queryGroupId": "3c598972-2685-4d67-9d26-73285509eef9",
      "text": [
        "10000000 meta [IsParameterQuery=true, Type=\"Number\", IsParameterQueryRequired=true]"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Number",
      "isHidden": false
    },
    {
      "name": "22 ALIASES",
      "lineageTag": "c8491541-15c9-443b-ab1c-e0f7e1487bf0",
      "description": "Optional. Aliases listed here separated by commas or semicolons will limit the loading of other aliases in the model, which can significantly speed up the overall data loading",
      "queryGroupId": "3c598972-2685-4d67-9d26-73285509eef9",
      "text": [
        "null meta [IsParameterQuery=true, Type=\"Text\", IsParameterQueryRequired=false]"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Null",
      "isHidden": false
    },
    {
      "name": "fn_extractFunctionEntries",
      "lineageTag": "334a0b76-23de-4ac6-a533-aaff43b4cf4c",
      "queryGroupId": "7e862cc9-af5a-4123-9678-c848a95d8d11",
      "text": [
        "// Function returns a list of objects extracted from the text, defined by incoming keywords and a marker-function.",
        "// Parameters: ",
        "//\t\tTextToParse: Prepared text ( returned by prepareCodeContent() )",
        "//\t\tKeyWords: one or several combined values from KeyWords or any other source;",
        "//      ParamNos: parameter number in KeyWords functions",
        "//\t\tVariablesDict: if variables Dictionary is needed (see fn_getProcessVariablesDict())",
        "//      EntriesListByKeyWords: list of target entries by all KeyWords",
        "//      KeyWordNo: KeyWord iterator",
        "//\t\tEntriesList: accumulated list of target entries while parsing",
        "//\t\tEntryNo: entry iterator for a KeyWord",
        "",
        "",
        "(TextToParse as text, KeyWords as list, ParamNos as list, optional VariablesDict as list) as list =>",
        "    let",
        "        fn_appendObjectToList_KeyWordNo = (EntriesListByKeyWords as list, KeyWordNo as number) as list =>",
        "            let",
        "            // Append next entry for the current KeyWord",
        "                fn_appendObjectToList_EntryNo = (EntriesList as list, KeyWord as text, EntryNo as number) as list =>  ",
        "                let",
        "                    NextFunction = Text_BetweenOuterDelimiters(Text.AfterDelimiter(TextToParse, KeyWord & \"(\", EntryNo), \"(\", \")\"),",
        "                    AppendedList = if NextFunction = \"\"",
        "                        then EntriesList",
        "                        else ",
        "                            let ",
        "                                // Escaping any inner commas for subsequent splitting",
        "                                TransformNestedOpeningParenthesis = Text.Replace(NextFunction, \"(\", \"\"\"(\"),",
        "                                TransformNestedClosingParenthesis = Text.Replace(TransformNestedOpeningParenthesis, \")\", \")\"\"\"),",
        "                                TransformSingleQuotes = Text.Replace(TransformNestedClosingParenthesis, \"'\", \"\"\"'\"),",
        "",
        "                                // Extracting parametres",
        "                                ParameterList = Splitter.SplitTextByDelimiter(\",\", QuoteStyle.Csv)(TransformSingleQuotes),",
        "                                ReplaceVariablesWithValue = ",
        "                                    if VariablesDict = null or List.IsEmpty(VariablesDict) // Only for Processes ",
        "                                    then ParameterList ",
        "                                    else List.Transform(ParameterList, ( val ) => if Text.StartsWith ( val , \"'\") then val else try List.Last(List.Select(VariablesDict, each _{0} = val)){1} otherwise \"''\")",
        "                                ,",
        "                                RemovedQuotationsParameterList = List.Transform(ReplaceVariablesWithValue, each Text.Remove( _ , {\"'\"} )),",
        "                                Object = RemovedQuotationsParameterList{ParamNos{KeyWordNo}},",
        "                                EntriesList = ",
        "                                    if Object <> null and Text.Trim(Object) <> \"\" and not List.Contains(EntriesList, Object)",
        "                                    then EntriesList & { Object }",
        "                                    else EntriesList",
        "                                ,",
        "                                Recursion = @fn_appendObjectToList_EntryNo(EntriesList, KeyWords{KeyWordNo}, EntryNo + 1)",
        "                            in ",
        "                                Recursion               ",
        "                in ",
        "                    AppendedList,",
        "",
        "                EntriesListByKeyWords = List.Combine({EntriesListByKeyWords, fn_appendObjectToList_EntryNo({}, KeyWords{KeyWordNo}, 0 )})",
        "            in",
        "                if KeyWordNo = List.Count(KeyWords) - 1",
        "                    then EntriesListByKeyWords",
        "                    else @fn_appendObjectToList_KeyWordNo(EntriesListByKeyWords, KeyWordNo + 1)",
        "            ,",
        "            ",
        "        Entires = fn_appendObjectToList_KeyWordNo({}, 0),",
        "        DistinctList = List.Distinct(Entires)",
        "    in ",
        "        DistinctList"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "xDel_fn_getRelatedObjects",
      "lineageTag": "4f1d9a2d-6552-405b-a4f5-b30c76603a4f",
      "queryGroupId": "7e862cc9-af5a-4123-9678-c848a95d8d11",
      "text": [
        "(TextToParse as text, KeyWords as list, ParamNos as list) =>",
        "let    ",
        "  // Function: Prepare Variables Dictionary",
        "    // ***************************************",
        "    fn_getVariablesDict = (TextToParse as text, VariableQuote as text) as list =>  ",
        "    let",
        "    // Select variables: keys cannot contain special symbols, values are not functions",
        "        Rows = Text.Split(TextToParse, \";\"),",
        "        RawsKeyValue = List.Transform(Rows, each if Text.Contains( _ , \"=\" ) then Splitter.SplitTextByAnyDelimiter({ \"@=\", \"=\" })( _ ) else { null, _ } ),",
        "        VariableDict = List.Select(RawsKeyValue, each _{0} <> null and not Text_ContainsAnyOf( _{0} , { \"(\", \"[\" } ) and not Text_ContainsAnyOf( _{1} , { \"(\", \"[\" } )),",
        "",
        "        //Replace variable references with real values",
        "        // 0 - Key, 1 - Value",
        "        Counter = List.Count(VariableDict),",
        "        fn_getRealVairableValue = (i as number, optional DictToSearchIn as list) as list =>",
        "            let",
        "                ReferredVariableKey = VariableDict{i}{1},",
        "                VariableNewValue = if Text.Contains( ReferredVariableKey, VariableQuote ) then ReferredVariableKey else try List.Last(List.Select(DictToSearchIn, each _{0} = ReferredVariableKey)){1} otherwise VariableQuote & VariableQuote,",
        "                TransformedVariableDict = if DictToSearchIn = null then {{ VariableDict{i}{0}, VariableNewValue }} else DictToSearchIn & {{ VariableDict{i}{0}, VariableNewValue }}",
        "            in",
        "                if i >= Counter - 1",
        "                    then TransformedVariableDict",
        "                    else @fn_getRealVairableValue(i + 1, TransformedVariableDict),",
        "        ",
        "        ReplaceVariableReferenceWithValue = fn_getRealVairableValue(0)",
        "    in",
        "        ReplaceVariableReferenceWithValue,",
        "",
        "    // Function: Get Metadata List",
        "    // ***************************************",
        "    // Append a list of entries for a next KeyWord",
        "    fn_appendObjectToList_KeyWordNo = (KeyWordsEntriesList as list, KeyWordNo as number) as list =>",
        "    let",
        "      // Append next entry for the current KeyWord",
        "        fn_appendObjectToList_EntryNo = (EntriesList as list, KeyWord as text, EntryNo as number) as list =>  ",
        "        let",
        "            NextFunction = Text_BetweenOuterDelimiters(Text.AfterDelimiter(TextToParse, KeyWord & \"(\", EntryNo), \"(\", \")\"),",
        "            AppendedList = if NextFunction = \"\"",
        "                then EntriesList",
        "                else ",
        "                    let ",
        "                        // Escaping any inner commas for subsequent splitting",
        "                        TransformNestedOpeningParenthesis = Text.Replace(NextFunction, \"(\", \"\"\"(\"),",
        "                        TransformNestedClosingParenthesis = Text.Replace(TransformNestedOpeningParenthesis, \")\", \")\"\"\"),",
        "                        TransformSingleQuotes = Text.Replace(TransformNestedClosingParenthesis, \"'\", \"\"\"'\"),",
        "                        ",
        "                        // Extracting parametres",
        "                        ParameterList = Splitter.SplitTextByDelimiter(\",\", QuoteStyle.Csv)(TransformSingleQuotes),",
        "                        ReplaceVariablesWithValue = List.Transform(ParameterList, ( val ) => if Text.StartsWith ( val , \"'\") then val else try List.Last(List.Select(VariablesDict, each _{0} = val)){1} otherwise \"''\"),",
        "                        RemovedQuotationsParameterList = List.Transform(ReplaceVariablesWithValue, each Text.Remove( _ , {\"'\"} )),",
        "                        Object = RemovedQuotationsParameterList{ParamNos{KeyWordNo}},",
        "                        EntriesList = ",
        "                            if Object <> null and Object <> \"\" and not List.Contains(EntriesList, Object)",
        "                            then EntriesList & { Object }",
        "                            else EntriesList",
        "                        ,",
        "                        Recursion = @fn_appendObjectToList_EntryNo(EntriesList, KeyWords{KeyWordNo}, EntryNo + 1)",
        "                    in ",
        "                        Recursion               ",
        "        in ",
        "            AppendedList,",
        "",
        "        KeyWordsEntriesList = List.Combine({KeyWordsEntriesList, fn_appendObjectToList_EntryNo({}, KeyWords{KeyWordNo}, 0 )})",
        "    in",
        "    if KeyWordNo = Counter - 1",
        "        then KeyWordsEntriesList",
        "        else @fn_appendObjectToList_KeyWordNo(KeyWordsEntriesList, KeyWordNo + 1)",
        "    ,",
        "",
        "    // 1. Prepare Variables Dictionary",
        "    VariablesDict = fn_getVariablesDict(TextToParse, \"'\"),",
        "",
        "    // 2. Main",
        "    Counter = List.Count(KeyWords),",
        "    Entires = fn_appendObjectToList_KeyWordNo({}, 0),",
        "    DistinctList = List.Distinct(Entires)",
        "in ",
        "    DistinctList"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Unknown",
      "isHidden": false
    },
    {
      "name": "fn_calcMaxTreeDepth",
      "lineageTag": "dd9d78af-84ef-465f-8209-3d6a62efcd8a",
      "queryGroupId": "7e862cc9-af5a-4123-9678-c848a95d8d11",
      "text": [
        "( RelatedObjects as list ) as number =>",
        "let   ",
        "    MaxTreePathsCount = SettingsConfig[MaxTreePathsCount],",
        "    InterfaceMaxTreeDepth = SettingsConfig[InterfaceMaxTreeDepth],",
        "    AvgRelatedObjects1 = ",
        "        Value_SafeDivision( ",
        "            try List.Count(List.Combine(RelatedObjects)) ",
        "            otherwise try  List.Count( Table.ExpandTableColumn(Table.FromList(RelatedObjects, Splitter.SplitByNothing(), {\"RelatedObjects\"}, null, ExtraValues.Error), \"RelatedObjects\", { \"RelatedObjects\" } )[RelatedObjects] )",
        "            otherwise 1",
        "        , List.Count(RelatedObjects) ",
        "        ), ",
        "    AvgRelatedObjects2 = if AvgRelatedObjects1 < 1 then 1 else AvgRelatedObjects1 ,",
        "    CalcMaxTreeDepth = Number.RoundDown( Number.Log( Value_SafeDivision(MaxTreePathsCount, List.Count(RelatedObjects)),  AvgRelatedObjects2 )),",
        "    MaxTreeDepth = if Number.IsNaN(CalcMaxTreeDepth) or CalcMaxTreeDepth <= 1 or CalcMaxTreeDepth > InterfaceMaxTreeDepth then InterfaceMaxTreeDepth else CalcMaxTreeDepth",
        "in",
        "    MaxTreeDepth"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "fn_prepareCodeContent",
      "lineageTag": "c60c99bb-9925-4d87-a362-792ca30b13a0",
      "queryGroupId": "7e862cc9-af5a-4123-9678-c848a95d8d11",
      "text": [
        "// Сleaning and preparing the code of rules and processes before any parsing",
        "(RawText as text) =>",
        "    let",
        "        KeyWords = List.Combine({ KeyWords[RuleCubeRef], KeyWords[RuleAttrRef], KeyWords[ProcessCubeRef], KeyWords[ProcessProcessRef], { KeyWords[SkipcheckRef] }, { KeyWords[FeederRef] } }),",
        "        Counter = List.Count(KeyWords),",
        "",
        "        // Remove commented blocks: #, line feeds: #(lf).",
        "\t    // Commented blocks should be removed before the quote-dependent splitting since non-closed quotes may occur in commented rows",
        "        SplitTextByCarriageReturn = Splitter.SplitTextByAnyDelimiter({\"#(cr)\", \"#(lf)\"}, QuoteStyle.None)(RawText), ",
        "        RemoveCommentedRows = List.Select(SplitTextByCarriageReturn, each not Text.StartsWith( Text.Trim ( _ ) ,\"#\" )), ",
        "        TextWithoutComments = Text.Combine(RemoveCommentedRows),\t\t",
        "",
        "        // Remove control characters",
        "        CleanedText = Text.Clean(TextWithoutComments),",
        "\t\t",
        "        // Upper KeyWords ",
        "        fn_upperKeyWords = (text as text, i as number) =>",
        "            let",
        "                ReplaceTextCase = Text_ReplaceSubstring(text, KeyWords{i}, KeyWords{i}, true)",
        "            in",
        "                if i >= Counter",
        "                then text",
        "                else @fn_upperKeyWords(ReplaceTextCase, i + 1)",
        "        ,  ",
        "",
        "        PreparedText = fn_upperKeyWords(CleanedText, 0)",
        "                   ",
        "    in ",
        "        PreparedText"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "xDel_fn_createHierarchyPath_ByList",
      "lineageTag": "21452774-9b21-4072-8e02-3f99c4290ecd",
      "queryGroupId": "7e862cc9-af5a-4123-9678-c848a95d8d11",
      "text": [
        "(SourceTable as table, KeyField as any, ChildrenObjectsField as text, TreeNodeName as text, HierarchyDepth as number) =>",
        "   let",
        "      fn_nextNode = (NodesTable as table, NodeNo as number) =>",
        "         let",
        "            ExpandLevel_N = Table.ExpandListColumn(NodesTable, TreeNodeName & Text.From(NodeNo)),",
        "            RemoveCircularRefLevel_N = Table.ReplaceValue(",
        "                                                      ExpandLevel_N",
        "                                                      , each Text.EndsWith(Splitter & Record.Field( _ ,  \"HierarchyPath\"), Splitter & Record.Field( _ , TreeNodeName & Text.From(NodeNo)))",
        "                                                      , each null",
        "                                                      , (currentValue, isTrue, replacementValue) => if isTrue then replacementValue else currentValue  ",
        "                                                      , {TreeNodeName & Text.From(NodeNo)}",
        "                                                   ),",
        "            //Update hierarchy path with new meaningful values",
        "            AppendHierarchyPath = Table.ReplaceValue(",
        "                                                         RemoveCircularRefLevel_N ",
        "                                                         , each Record.Field( _ , TreeNodeName & Text.From(NodeNo)) = null",
        "                                                         , each Record.Field( _ , TreeNodeName & Text.From(NodeNo)) ",
        "                                                         , (currentValue, isTrue, replacementValue) => if isTrue then currentValue else Text.Combine({ currentValue, Splitter, replacementValue })  ",
        "                                                         , {\"HierarchyPath\"}                                                       ",
        "                                                      ),",
        "            ",
        "            NextNodeTable = ",
        "               if (NodeNo = InterfaceMaxTreeDepth - 2) then LastNodeTable ",
        "               else if (NodeNo = HierarchyDepth - 1) then LastNodeTable ",
        "               else if (NodeNo < HierarchyDepth - 1) then SourceTable ",
        "               else NullNodeTable,",
        "           ",
        "            HierarchyTable = if (NodeNo >= InterfaceMaxTreeDepth - 1)",
        "                                 then",
        "                                     AppendHierarchyPath       ",
        "                                 else ",
        "                                    let",
        "                                       AddNextNodeTable = Table.NestedJoin(",
        "                                                  AppendHierarchyPath",
        "                                                , TreeNodeName & Text.From(NodeNo)",
        "                                                , NextNodeTable",
        "                                                , KeyField",
        "                                                , \"TableColumn\"",
        "                                                , JoinKind.LeftOuter ",
        "                                             ),",
        "                                       ExpandNextNodeTable = Table.ExpandTableColumn(AddNextNodeTable, \"TableColumn\", { ChildrenObjectsField }, { TreeNodeName & Text.From(NodeNo + 1) })",
        "                                    in",
        "                                       @fn_nextNode(ExpandNextNodeTable, NodeNo + 1)",
        "         in",
        "            HierarchyTable,",
        "",
        "      InterfaceMaxTreeDepth = SettingsConfig[InterfaceMaxTreeDepth],",
        "      RootNodeTable = Table.AddColumn(Table.RenameColumns(SourceTable, {{ KeyField, TreeNodeName & Text.From(0) }, { ChildrenObjectsField, TreeNodeName & Text.From(1) }}), \"HierarchyPath\", each Record.Field( _ , TreeNodeName & Text.From(0))),",
        "      LastNodeTable = Table.AddColumn(Table.SelectColumns(SourceTable, KeyField), ChildrenObjectsField, each {\"[ ... ]\"}),",
        "      NullNodeTable = Table.AddColumn(Table.SelectColumns(SourceTable, KeyField), ChildrenObjectsField, each null),",
        "      Splitter = \"|\",",
        "      ",
        "      Return = fn_nextNode(RootNodeTable, 1)",
        "   in ",
        "      Return"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "fn_createHierarchyPath",
      "lineageTag": "371b48d7-3c41-427f-ad4c-3832baa17964",
      "queryGroupId": "7e862cc9-af5a-4123-9678-c848a95d8d11",
      "text": [
        "(SourceTable as table, KeyField as any, ChildrenObjectsField as text, TreeNodeName as text, HierarchyDepth as number, optional DefinitionMap as list) =>",
        "   let",
        "      fn_nextNode = (NodesTable as table, NodeNo as number) =>",
        "         let",
        "            ExpandLevel_N = Table_ExpandAnyColumn(",
        "                                                      NodesTable",
        "                                                      , TreeNodeName & Text.From(NodeNo)",
        "                                                      , if DefinitionMap = null then null else DefinitionMap // to handle properly the entirely null nodes ",
        "                                                      , if DefinitionMap = null then null else { TreeNodeName & Text.From(NodeNo), TreeNodeName & Text.From(NodeNo) & \": \" & SysName[CubeTreeAreaDefinition] }",
        "                                                      , if DefinitionMap = null then null else type table // to handle properly the entirely null nodes ",
        "                                                ),",
        "            RemoveCircularRefLevel_N = Table.ReplaceValue(",
        "                                                      ExpandLevel_N",
        "                                                      , each Text.EndsWith(Splitter & Record.Field( _ ,  \"HierarchyPath\"), Splitter & Record.Field( _ , TreeNodeName & Text.From(NodeNo)))",
        "                                                      , each null",
        "                                                      , (currentValue, isTrue, replacementValue) => if isTrue then replacementValue else currentValue  ",
        "                                                      , List.Select(Table.ColumnNames(ExpandLevel_N), each Text.StartsWith( _ , TreeNodeName & Text.From(NodeNo) ))",
        "                                                   ),",
        "            //Update hierarchy path with new meaningful values",
        "            AppendHierarchyPath = Table.ReplaceValue(",
        "                                                         RemoveCircularRefLevel_N ",
        "                                                         , each Record.Field( _ , TreeNodeName & Text.From(NodeNo)) = null",
        "                                                         , each Record.Field( _ , TreeNodeName & Text.From(NodeNo)) ",
        "                                                         , (currentValue, isTrue, replacementValue) => if isTrue then currentValue else Text.Combine({ currentValue, Splitter, replacementValue })  ",
        "                                                         , {\"HierarchyPath\"}                                                       ",
        "                                                      ),",
        "            ",
        "            NextNodeTable = ",
        "               if (NodeNo = InterfaceMaxTreeDepth - 2) then LastNodeTable ",
        "               else if (NodeNo = HierarchyDepth - 1) then LastNodeTable ",
        "               else if (NodeNo < HierarchyDepth - 1) then SourceTable ",
        "               else NullNodeTable,           ",
        "            HierarchyTable = if (NodeNo >= InterfaceMaxTreeDepth - 1)",
        "                                 then",
        "                                     AppendHierarchyPath       ",
        "                                 else ",
        "                                    let",
        "                                       AddNextNodeTable = Table.NestedJoin(",
        "                                                  AppendHierarchyPath",
        "                                                , TreeNodeName & Text.From(NodeNo)",
        "                                                , NextNodeTable",
        "                                                , KeyField",
        "                                                , \"TableColumn\"",
        "                                                , JoinKind.LeftOuter ",
        "                                             ),",
        "                                       ExpandedNextNodeTable = Table.ExpandTableColumn(AddNextNodeTable, \"TableColumn\", { ChildrenObjectsField }, { TreeNodeName & Text.From(NodeNo + 1) })",
        "                                    in ",
        "                                       @fn_nextNode(ExpandedNextNodeTable, NodeNo + 1) ",
        "         in",
        "            HierarchyTable,",
        "",
        "",
        "      InterfaceMaxTreeDepth = SettingsConfig[InterfaceMaxTreeDepth],",
        "      RootNodeTable = Table.AddColumn(Table.RenameColumns(SourceTable, {{ KeyField, TreeNodeName & Text.From(0) }, { ChildrenObjectsField, TreeNodeName & Text.From(1) }}), \"HierarchyPath\", each Record.Field( _ , TreeNodeName & Text.From(0))),",
        "      LastNodeTable = Table.AddColumn(Table.SelectColumns(SourceTable, KeyField), ChildrenObjectsField, each {\"[ ... ]\"}),",
        "      NullNodeTable = Table.AddColumn(Table.SelectColumns(SourceTable, KeyField), ChildrenObjectsField, each null),",
        "      Splitter = \"|\",",
        "      ",
        "      Return = fn_nextNode(RootNodeTable, 1)",
        "   in ",
        "      Return"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "fn_nestedExpressionsCount",
      "lineageTag": "cd51457d-0c9d-45ec-9d3f-643e409639ee",
      "queryGroupId": "7e862cc9-af5a-4123-9678-c848a95d8d11",
      "text": [
        "(TextToParse as text, Expression as text, NestedExpressions as list) as number =>",
        "let",
        "\tfn_appendObjectToList_EntryNo = (EntriesList as list, KeyWord as text, EntryNo as number) as list =>  ",
        "\tlet",
        "\t\tNextEntry = Text_BetweenOuterDelimiters(Text.AfterDelimiter(TextToParse, KeyWord & \"(\", EntryNo), \"(\", \")\"),",
        "\t\tAppendedList = if NextEntry = \"\"",
        "\t\t\tthen EntriesList",
        "\t\t\telse ",
        "\t\t\t\tlet ",
        "\t\t\t\t\tEntriesList = EntriesList & { NextEntry },",
        "\t\t\t\t\tRecursion = @fn_appendObjectToList_EntryNo(EntriesList, KeyWord, EntryNo + 1)",
        "\t\t\t\tin",
        "\t\t\t\t\tRecursion",
        "\tin",
        "\t\tAppendedList,",
        "\t\t\t\t\t",
        "\tEntriesList = fn_appendObjectToList_EntryNo({}, Expression, 0 ),",
        "\tEntriesWithNestedExpressions = List.Select(EntriesList, each Text_ContainsAnyOf( _ , NestedExpressions))",
        "in",
        "\tList.Count(EntriesWithNestedExpressions)"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Unknown",
      "isHidden": false
    },
    {
      "name": "Source_Rules",
      "lineageTag": "5b515ed7-b609-4f29-b2bf-22f6ae6855ef",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[Name = text, TextContent = text, MetaData = text], {}),",
        "",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(sREST_Rules[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                let",
        "                    Value = sREST_Rules[value],",
        "                    ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\"RecordSet\"}, null, ExtraValues.Ignore),",
        "                    ExpandRecordSet = Table.ExpandRecordColumn(ConvertToTable, \"RecordSet\", {\"Name\", \"Rules\"}, {\"Name\", \"TextContent\"}),",
        "                    AddMetaDataName = Table.AddColumn(ExpandRecordSet, \"MetaData\", each FileExtentions{[Name = \"Rule\"]}[Name])    ",
        "                in",
        "                    AddMetaDataName                                       ",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\"",
        "        then",
        "            DataFiles_RulesAndProcesses",
        "        else",
        "            NullTable,",
        "    MetaDataSelection = Table.SelectRows(Source, each FileExtentions{[Name = \"Rule\"]}[Name] = Text.From([MetaData])),",
        "    CubesWithRules = Table.SelectRows(MetaDataSelection, each [TextContent] <> null),",
        "    //Prepare Content for Parsing",
        "    PreparedContent = Table.TransformColumns(CubesWithRules, { \"TextContent\", ( text ) => fn_prepareCodeContent(text) })",
        "in",
        "    PreparedContent"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Source_Processes",
      "lineageTag": "32ef5e25-1dfd-4a2a-a7ed-1d5acc8bcc4f",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[Name = text, TextContent = text, MetaData = text], {}),",
        "",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(sREST_Processes[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                let",
        "                    Value = sREST_Processes[value],",
        "                    ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\"RecordSet\"}, null, ExtraValues.Ignore),",
        "                    ExpandRecordSet = Table.ExpandRecordColumn(ConvertToTable, \"RecordSet\", {\"Name\", \"PrologProcedure\", \"MetadataProcedure\", \"DataProcedure\", \"EpilogProcedure\"}),",
        "//                    NameSelection = Table.SelectRows(ExpandRecordSet, each ",
        "//                                                        let ",
        "//                                                            Name = [Name], ",
        "//                                                            NameFilter = List.MatchesAny( KeyWords[SysMetaDataRef], each not Text.StartsWith( Name, _ ))",
        "//                                                        in ",
        "//                                                            NameFilter",
        "//                                                ),",
        "                    AddTextContent = Table.AddColumn(ExpandRecordSet, \"TextContent\", each ",
        "                                    [PrologProcedure]",
        "                                    & \"#(cr)#(lf)\"",
        "                                    & [MetadataProcedure]",
        "                                    & \"#(cr)#(lf)\"",
        "                                    & [DataProcedure]",
        "                                    & \"#(cr)#(lf)\"",
        "                                    & [EpilogProcedure]),",
        "                    RemoveColumns = Table.RemoveColumns(AddTextContent,{\"PrologProcedure\", \"MetadataProcedure\", \"DataProcedure\", \"EpilogProcedure\"}),",
        "                    AddMetaDataName = Table.AddColumn(RemoveColumns, \"MetaData\", each FileExtentions{[Name = \"Process\"]}[Name])",
        "                in",
        "                    AddMetaDataName",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            DataFiles_RulesAndProcesses",
        "        else",
        "            NullTable,",
        "",
        "    MetaDataSelection = Table.SelectRows(Source, each FileExtentions{[Name = \"Process\"]}[Name] = Text.From([MetaData])),",
        "",
        "    PreparedContent = Table.TransformColumns(MetaDataSelection, { \"TextContent\", ( text ) => ",
        "                                                                                            let",
        "                                                                                                StartPos = if Text.PositionOf(text, \"#****Begin: Generated Statements***\") > 0 then Text.PositionOf(text, \"#****Begin: Generated Statements***\", Occurrence.First) else 0,",
        "                                                                                                EndPos = if Text.PositionOf(text, \"#****End: Generated Statements****\") > 0 then Text.PositionOf(text, \"#****End: Generated Statements****\", Occurrence.Last) else Text.Length(text),",
        "                                                                                                SubText = Text.Middle(text, StartPos, EndPos - StartPos + 1)",
        "                                                                                            in",
        "                                                                                                fn_prepareCodeContent(SubText) ",
        "                                                                }",
        "    )",
        "in",
        "    PreparedContent"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Configuration",
      "lineageTag": "a73e74d1-340a-4f41-93bc-2de8d5560822",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[Name = text, Value = text], {}),",
        "",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "        then",
        "            if (try not ( fn_isSuccessfulHttpRequest( sREST_Configuration[#\"@metadata\"] ) or fn_isSuccessfulHttpRequest(sREST_Server[#\"@metadata\"] )) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                let",
        "                    Value1 = sREST_Configuration,",
        "                    ConvertToTable1 = Record.ToTable(Value1),",
        "",
        "                    Value2 = sREST_Server,",
        "                    ConvertToTable2 = Record.ToTable(Value2),",
        "",
        "                    CombineTable = Table.Distinct(Table.Combine({ ConvertToTable1, ConvertToTable2 })),",
        "                    FilterRows = Table.SelectRows(CombineTable, each (not Text.StartsWith([Name], \"@\") and [Name] <> \"Name\"))",
        "                in",
        "                    FilterRows",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            NullTable    ",
        "        else",
        "            NullTable",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[Name = text, Value = text], {}),\\n\\n    Source = \\n        if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\"\\n        then\\n            if (try not ( fn_isSuccessfulHttpRequest( sREST_Configuration[#\\\"@metadata\\\"] ) or fn_isSuccessfulHttpRequest(sREST_Server[#\\\"@metadata\\\"] )) otherwise true) \\n            then     \\n                NullTable\\n            else\\n                let\\n                    Value1 = sREST_Configuration,\\n                    ConvertToTable1 = Record.ToTable(Value1),\\n\\n                    Value2 = sREST_Server,\\n                    ConvertToTable2 = Record.ToTable(Value2),\\n\\n                    CombineTable = Table.Distinct(Table.Combine({ ConvertToTable1, ConvertToTable2 })),\\n                    FilterRows = Table.SelectRows(CombineTable, each (not Text.StartsWith([Name], \\\"@\\\") and [Name] <> \\\"Name\\\"))\\n                in\\n                    FilterRows\\n        else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n        then\\n            NullTable    \\n        else\\n            NullTable\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "CubeDimensions",
      "lineageTag": "0a13b22d-a1b8-4050-a58a-a566298f322b",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[Cube = text, Dimension = text], {}),",
        "",
        "     Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(sREST_CubeDimensions[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                    let",
        "                        Value = sREST_CubeDimensions[value],",
        "                        ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\"RecordSet\"}, null, ExtraValues.Ignore),",
        "                        ExpandRecordSet = Table.ExpandRecordColumn(ConvertToTable, \"RecordSet\", {\"Name\", \"Dimensions\"}, {\"Cube\", \"Dimensions\"}),",
        "                        ExpandedDimensionList = Table.ExpandListColumn(ExpandRecordSet, \"Dimensions\"),",
        "                        ExpandedDimensionRecords = Table.ExpandRecordColumn(ExpandedDimensionList, \"Dimensions\", {\"Name\"}, {\"Dimension\"})",
        "                    in",
        "                        ExpandedDimensionRecords      ",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            NullTable",
        "        else",
        "            NullTable",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[Cube = text, Dimension = text], {}),\\n\\n     Source = \\n        if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\" \\n        then\\n            if (try not fn_isSuccessfulHttpRequest(sREST_CubeDimensions[#\\\"@metadata\\\"]) otherwise true) \\n            then     \\n                NullTable\\n            else\\n                    let\\n                        Value = sREST_CubeDimensions[value],\\n                        ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\\\"RecordSet\\\"}, null, ExtraValues.Ignore),\\n                        ExpandRecordSet = Table.ExpandRecordColumn(ConvertToTable, \\\"RecordSet\\\", {\\\"Name\\\", \\\"Dimensions\\\"}, {\\\"Cube\\\", \\\"Dimensions\\\"}),\\n                        ExpandedDimensionList = Table.ExpandListColumn(ExpandRecordSet, \\\"Dimensions\\\"),\\n                        ExpandedDimensionRecords = Table.ExpandRecordColumn(ExpandedDimensionList, \\\"Dimensions\\\", {\\\"Name\\\"}, {\\\"Dimension\\\"})\\n                    in\\n                        ExpandedDimensionRecords      \\n        else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n        then\\n            NullTable\\n        else\\n            NullTable\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "Cubes",
      "lineageTag": "86694008-8ea7-4635-b4a9-665b8a41f103",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[Cube = text], {}),",
        "",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(sREST_CubeDimensions[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                Table.FromList(List.Distinct(CubeDimensions[Cube]), Splitter.SplitByNothing(), {\"Cube\"}, null, ExtraValues.Ignore)     ",
        "           else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "           then",
        "               Table.Distinct(DataFiles_Cubes)",
        "        else",
        "            NullTable",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[Cube = text], {}),\\n\\n    Source = \\n        if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\" \\n        then\\n            if (try not fn_isSuccessfulHttpRequest(sREST_CubeDimensions[#\\\"@metadata\\\"]) otherwise true) \\n            then     \\n                NullTable\\n            else\\n                Table.FromList(List.Distinct(CubeDimensions[Cube]), Splitter.SplitByNothing(), {\\\"Cube\\\"}, null, ExtraValues.Ignore)     \\n           else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n           then\\n               Table.Distinct(DataFiles_Cubes)\\n        else\\n            NullTable\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "Dimensions",
      "lineageTag": "22f2d295-fe17-4612-b5f5-4fba22b2071b",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[Dimension = text], {}),",
        "",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(sREST_CubeDimensions[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                Table.FromList(List.Distinct(CubeDimensions[Dimension]), Splitter.SplitByNothing(), {\"Dimension\"}, null, ExtraValues.Ignore)        ",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            Table.Distinct(DataFiles_Dimensions)",
        "        else",
        "            NullTable",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[Dimension = text], {}),\\n\\n    Source = \\n        if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\" \\n        then\\n            if (try not fn_isSuccessfulHttpRequest(sREST_CubeDimensions[#\\\"@metadata\\\"]) otherwise true) \\n            then     \\n                NullTable\\n            else\\n                Table.FromList(List.Distinct(CubeDimensions[Dimension]), Splitter.SplitByNothing(), {\\\"Dimension\\\"}, null, ExtraValues.Ignore)        \\n        else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n        then\\n            Table.Distinct(DataFiles_Dimensions)\\n        else\\n            NullTable\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "DimensionAttributes",
      "lineageTag": "6fa34f19-9794-4e18-9de6-b46a455561d0",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[Dimension = text, Hierarchy = text, Attribute = text, AttributeType = text], {}),",
        "",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(sREST_DimensionAttributes[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                let",
        "                    Value = sREST_DimensionAttributes[value],",
        "                    ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\"RecordSet\"}, null, ExtraValues.Ignore),",
        "                    ExpandRecordSet = Table.ExpandRecordColumn(ConvertToTable, \"RecordSet\", {\"Name\", \"Hierarchies\"}, {\"Dimension\", \"Hierarchies\"}),",
        "                    NameSelection = Table.SelectRows(ExpandRecordSet, each ",
        "                                                                    let ",
        "                                                                        Dim = [Dimension], ",
        "                                                                        NameFilter = List.MatchesAny( Dimensions[Dimension], each _ = Text.From ( Dim ))",
        "                                                                    in ",
        "                                                                        NameFilter",
        "                                            ),",
        "                    ExpandHierarchiesList = Table.ExpandListColumn(NameSelection, \"Hierarchies\"),",
        "                    ExpandHierarchiesRecordSet = Table.ExpandRecordColumn(ExpandHierarchiesList, \"Hierarchies\", {\"Name\", \"ElementAttributes\"}, {\"Hierarchy\", \"ElementAttributes\"}),",
        "                    ExpandElementAttributesList = Table.ExpandListColumn(ExpandHierarchiesRecordSet, \"ElementAttributes\"),",
        "                    ExpandElementAttributesRecordSet = Table.ExpandRecordColumn(ExpandElementAttributesList, \"ElementAttributes\", {\"Name\", \"Type\"}, {\"Attribute\", \"AttributeType\"})",
        "                in",
        "                    ExpandElementAttributesRecordSet        ",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            NullTable",
        "        else",
        "            NullTable",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[Dimension = text, Hierarchy = text, Attribute = text, AttributeType = text], {}),\\n\\n    Source = \\n        if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\" \\n        then\\n            if (try not fn_isSuccessfulHttpRequest(sREST_DimensionAttributes[#\\\"@metadata\\\"]) otherwise true) \\n            then     \\n                NullTable\\n            else\\n                let\\n                    Value = sREST_DimensionAttributes[value],\\n                    ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\\\"RecordSet\\\"}, null, ExtraValues.Ignore),\\n                    ExpandRecordSet = Table.ExpandRecordColumn(ConvertToTable, \\\"RecordSet\\\", {\\\"Name\\\", \\\"Hierarchies\\\"}, {\\\"Dimension\\\", \\\"Hierarchies\\\"}),\\n                    NameSelection = Table.SelectRows(ExpandRecordSet, each \\n                                                                    let \\n                                                                        Dim = [Dimension], \\n                                                                        NameFilter = List.MatchesAny( Dimensions[Dimension], each _ = Text.From ( Dim ))\\n                                                                    in \\n                                                                        NameFilter\\n                                            ),\\n                    ExpandHierarchiesList = Table.ExpandListColumn(NameSelection, \\\"Hierarchies\\\"),\\n                    ExpandHierarchiesRecordSet = Table.ExpandRecordColumn(ExpandHierarchiesList, \\\"Hierarchies\\\", {\\\"Name\\\", \\\"ElementAttributes\\\"}, {\\\"Hierarchy\\\", \\\"ElementAttributes\\\"}),\\n                    ExpandElementAttributesList = Table.ExpandListColumn(ExpandHierarchiesRecordSet, \\\"ElementAttributes\\\"),\\n                    ExpandElementAttributesRecordSet = Table.ExpandRecordColumn(ExpandElementAttributesList, \\\"ElementAttributes\\\", {\\\"Name\\\", \\\"Type\\\"}, {\\\"Attribute\\\", \\\"AttributeType\\\"})\\n                in\\n                    ExpandElementAttributesRecordSet        \\n        else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n        then\\n            NullTable\\n        else\\n            NullTable\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "DimensionElements",
      "lineageTag": "715bccf4-8996-418f-8df0-c40e250473d0",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "  NullTable = #table(type table[    Dimension = text",
        "                                    , Hierarchy = text",
        "                                    , ElementType = text",
        "                                    , ElementLevel = text",
        "                                    , ElementIndex = number",
        "                                    , Element_0 = text",
        "                                    , Element_1 = text",
        "                                    , Element_2 = text            ",
        "                                    , Element_3 = text                                    ",
        "                                    , Element_4 = text                                   ",
        "                                    , Element_5 = text                                  ",
        "                                    , Element_6 = text                                   ",
        "                                    , Element_7 = text                                  ",
        "                                    , Element_8 = text                                 ",
        "                                    , Element_9 = text                                   ",
        "                                    , Element_10 = text                              ",
        "                                    , ElementKey = text",
        "                                    , HierarchyPath = text",
        "                                ], {}),",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(sREST_DimensionElements[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else ",
        "                let",
        "                    Value = sREST_DimensionElements[value],",
        "                    ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\"RecordSet\"}, null, ExtraValues.Ignore),",
        "                    ExpandRecordSet = Table.ExpandRecordColumn(ConvertToTable, \"RecordSet\", {\"Name\", \"Hierarchies\"}, {\"Dimension\", \"Hierarchies\"}),",
        "                    NameSelection = Table.SelectRows(ExpandRecordSet, each ",
        "                                                                    let ",
        "                                                                        Dim = [Dimension], ",
        "                                                                        NameFilter = List.MatchesAny( Dimensions[Dimension], each _ = Text.From ( Dim ))",
        "                                                                    in ",
        "                                                                        NameFilter",
        "                                            ),",
        "                    ExpandHierarchiesList = Table.ExpandListColumn(NameSelection, \"Hierarchies\"),",
        "                    ExpandHierarchiesRecordSet = Table.ExpandRecordColumn(ExpandHierarchiesList, \"Hierarchies\", {\"Name\", \"Elements\"}, {\"Hierarchy\", \"Elements\"}),",
        "                    ",
        "                    ExpandElementsList_0 = Table.ExpandListColumn(ExpandHierarchiesRecordSet, \"Elements\"),",
        "                    ExpandElementsRecordSet_0 = Table.ExpandRecordColumn(ExpandElementsList_0, \"Elements\", {\"Name\", \"Type\", \"Level\", \"Index\", \"Parents\"}, {SysName[DimHierarchyNodeName] & Text.From(0), \"ElementType\", \"ElementLevel\", \"ElementIndex\", \"Parents_0\"}),",
        "                ",
        "                    ExpandParentElementsList_1 = Table.ExpandListColumn(ExpandElementsRecordSet_0, \"Parents_0\"),",
        "                    ExpandParentElementsRecordSet_1 = Table.ExpandRecordColumn(ExpandParentElementsList_1, \"Parents_0\", {\"Name\", \"Parents\"}, {SysName[DimHierarchyNodeName] & Text.From(1), \"Parents_1\"}),",
        "                    ExpandParentElementsList_2 = Table.ExpandListColumn(ExpandParentElementsRecordSet_1, \"Parents_1\"),",
        "                    ExpandParentElementsRecordSet_2 = Table.ExpandRecordColumn(ExpandParentElementsList_2, \"Parents_1\", {\"Name\", \"Parents\"}, {SysName[DimHierarchyNodeName] & Text.From(2), \"Parents_2\"}),",
        "                    ExpandParentElementsList_3 = Table.ExpandListColumn(ExpandParentElementsRecordSet_2, \"Parents_2\"),",
        "                    ExpandParentElementsRecordSet_3 = Table.ExpandRecordColumn(ExpandParentElementsList_3, \"Parents_2\", {\"Name\", \"Parents\"}, {SysName[DimHierarchyNodeName] & Text.From(3), \"Parents_3\"}),",
        "                    ExpandParentElementsList_4 = Table.ExpandListColumn(ExpandParentElementsRecordSet_3, \"Parents_3\"),",
        "                    ExpandParentElementsRecordSet_4 = Table.ExpandRecordColumn(ExpandParentElementsList_4, \"Parents_3\", {\"Name\", \"Parents\"}, {SysName[DimHierarchyNodeName] & Text.From(4), \"Parents_4\"}),",
        "                    ExpandParentElementsList_5 = Table.ExpandListColumn(ExpandParentElementsRecordSet_4, \"Parents_4\"),",
        "                    ExpandParentElementsRecordSet_5 = Table.ExpandRecordColumn(ExpandParentElementsList_5, \"Parents_4\", {\"Name\", \"Parents\"}, {SysName[DimHierarchyNodeName] & Text.From(5), \"Parents_5\"}),",
        "                    ExpandParentElementsList_6 = Table.ExpandListColumn(ExpandParentElementsRecordSet_5, \"Parents_5\"),",
        "                    ExpandParentElementsRecordSet_6 = Table.ExpandRecordColumn(ExpandParentElementsList_6, \"Parents_5\", {\"Name\", \"Parents\"}, {SysName[DimHierarchyNodeName] & Text.From(6), \"Parents_6\"}),",
        "                    ExpandParentElementsList_7 = Table.ExpandListColumn(ExpandParentElementsRecordSet_6, \"Parents_6\"),",
        "                    ExpandParentElementsRecordSet_7 = Table.ExpandRecordColumn(ExpandParentElementsList_7, \"Parents_6\", {\"Name\", \"Parents\"}, {SysName[DimHierarchyNodeName] & Text.From(7), \"Parents_7\"}),",
        "                    ExpandParentElementsList_8 = Table.ExpandListColumn(ExpandParentElementsRecordSet_7, \"Parents_7\"),",
        "                    ExpandParentElementsRecordSet_8 = Table.ExpandRecordColumn(ExpandParentElementsList_8, \"Parents_7\", {\"Name\", \"Parents\"}, {SysName[DimHierarchyNodeName] & Text.From(8), \"Parents_8\"}),",
        "                    ExpandParentElementsList_9 = Table.ExpandListColumn(ExpandParentElementsRecordSet_8, \"Parents_8\"),",
        "                    ExpandParentElementsRecordSet_9 = Table.ExpandRecordColumn(ExpandParentElementsList_9, \"Parents_8\", {\"Name\", \"Parents\"}, {SysName[DimHierarchyNodeName] & Text.From(9), \"Parents_9\"}),",
        "                    ExpandParentElementsList_10 = Table.ExpandListColumn(ExpandParentElementsRecordSet_9, \"Parents_9\"),",
        "                    ExpandParentElementsRecordSet_10 = Table.ExpandRecordColumn(ExpandParentElementsList_10, \"Parents_9\", {\"Name\"}, {SysName[DimHierarchyNodeName] & Text.From(10)}),",
        "",
        "                    DimensionElements = ExpandParentElementsRecordSet_10,",
        "                    RemoveNullElements = Table.SelectRows(DimensionElements, each Record.Field( _ , SysName[DimHierarchyNodeName] & Text.From(0)) <> null),   //null-elements are to be removed for the hierarchy flattening function (if any) to work correctly ",
        "                    AddElementKey = Table.AddColumn(RemoveNullElements, \"ElementKey\", each \"[\" & [Dimension] & \"].[\" & Text.From(Record.Field( _ , SysName[DimHierarchyNodeName] & Text.From(0))) & \"]\", type text),",
        "                    ",
        "                    AddHierarchyPath = Table.AddColumn(AddElementKey, \"HierarchyPath\", each null, type text),",
        "                    TreeNodeNames = List.Select(Table.ColumnNames(AddHierarchyPath), each Text.StartsWith( _ , SysName[DimHierarchyNodeName]) ),",
        "                    ReverseHierachy = fn_reverseHierarchy(AddHierarchyPath, TreeNodeNames, \"HierarchyPath\"),",
        "",
        "                    TransformColumnTypes = Table.TransformColumnTypes(ReverseHierachy, {{\"ElementIndex\", Int64.Type}})",
        "                in",
        "                    TransformColumnTypes",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            if Table.RowCount(Source_TransactionLog) > 0",
        "            then",
        "                Table.FromColumns(",
        "                    {     ",
        "                          {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                        , List.Distinct(TransactionLogDimensions[ElementKey])",
        "                        , {}",
        "                    }, Table.ColumnNames(NullTable)",
        "                )",
        "            else",
        "                NullTable",
        "        else",
        "            NullTable",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n  NullTable = #table(type table[    Dimension = text\\n                                    , Hierarchy = text\\n                                    , ElementType = text\\n                                    , ElementLevel = text\\n                                    , ElementIndex = number\\n                                    , Element_0 = text\\n                                    , Element_1 = text\\n                                    , Element_2 = text            \\n                                    , Element_3 = text                                    \\n                                    , Element_4 = text                                   \\n                                    , Element_5 = text                                  \\n                                    , Element_6 = text                                   \\n                                    , Element_7 = text                                  \\n                                    , Element_8 = text                                 \\n                                    , Element_9 = text                                   \\n                                    , Element_10 = text                              \\n                                    , ElementKey = text\\n                                    , HierarchyPath = text\\n                                ], {}),\\n    Source = \\n        if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\" \\n        then\\n            if (try not fn_isSuccessfulHttpRequest(sREST_DimensionElements[#\\\"@metadata\\\"]) otherwise true) \\n            then     \\n                NullTable\\n            else \\n                let\\n                    Value = sREST_DimensionElements[value],\\n                    ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\\\"RecordSet\\\"}, null, ExtraValues.Ignore),\\n                    ExpandRecordSet = Table.ExpandRecordColumn(ConvertToTable, \\\"RecordSet\\\", {\\\"Name\\\", \\\"Hierarchies\\\"}, {\\\"Dimension\\\", \\\"Hierarchies\\\"}),\\n                    NameSelection = Table.SelectRows(ExpandRecordSet, each \\n                                                                    let \\n                                                                        Dim = [Dimension], \\n                                                                        NameFilter = List.MatchesAny( Dimensions[Dimension], each _ = Text.From ( Dim ))\\n                                                                    in \\n                                                                        NameFilter\\n                                            ),\\n                    ExpandHierarchiesList = Table.ExpandListColumn(NameSelection, \\\"Hierarchies\\\"),\\n                    ExpandHierarchiesRecordSet = Table.ExpandRecordColumn(ExpandHierarchiesList, \\\"Hierarchies\\\", {\\\"Name\\\", \\\"Elements\\\"}, {\\\"Hierarchy\\\", \\\"Elements\\\"}),\\n                    \\n                    ExpandElementsList_0 = Table.ExpandListColumn(ExpandHierarchiesRecordSet, \\\"Elements\\\"),\\n                    ExpandElementsRecordSet_0 = Table.ExpandRecordColumn(ExpandElementsList_0, \\\"Elements\\\", {\\\"Name\\\", \\\"Type\\\", \\\"Level\\\", \\\"Index\\\", \\\"Parents\\\"}, {SysName[DimHierarchyNodeName] & Text.From(0), \\\"ElementType\\\", \\\"ElementLevel\\\", \\\"ElementIndex\\\", \\\"Parents_0\\\"}),\\n                \\n                    ExpandParentElementsList_1 = Table.ExpandListColumn(ExpandElementsRecordSet_0, \\\"Parents_0\\\"),\\n                    ExpandParentElementsRecordSet_1 = Table.ExpandRecordColumn(ExpandParentElementsList_1, \\\"Parents_0\\\", {\\\"Name\\\", \\\"Parents\\\"}, {SysName[DimHierarchyNodeName] & Text.From(1), \\\"Parents_1\\\"}),\\n                    ExpandParentElementsList_2 = Table.ExpandListColumn(ExpandParentElementsRecordSet_1, \\\"Parents_1\\\"),\\n                    ExpandParentElementsRecordSet_2 = Table.ExpandRecordColumn(ExpandParentElementsList_2, \\\"Parents_1\\\", {\\\"Name\\\", \\\"Parents\\\"}, {SysName[DimHierarchyNodeName] & Text.From(2), \\\"Parents_2\\\"}),\\n                    ExpandParentElementsList_3 = Table.ExpandListColumn(ExpandParentElementsRecordSet_2, \\\"Parents_2\\\"),\\n                    ExpandParentElementsRecordSet_3 = Table.ExpandRecordColumn(ExpandParentElementsList_3, \\\"Parents_2\\\", {\\\"Name\\\", \\\"Parents\\\"}, {SysName[DimHierarchyNodeName] & Text.From(3), \\\"Parents_3\\\"}),\\n                    ExpandParentElementsList_4 = Table.ExpandListColumn(ExpandParentElementsRecordSet_3, \\\"Parents_3\\\"),\\n                    ExpandParentElementsRecordSet_4 = Table.ExpandRecordColumn(ExpandParentElementsList_4, \\\"Parents_3\\\", {\\\"Name\\\", \\\"Parents\\\"}, {SysName[DimHierarchyNodeName] & Text.From(4), \\\"Parents_4\\\"}),\\n                    ExpandParentElementsList_5 = Table.ExpandListColumn(ExpandParentElementsRecordSet_4, \\\"Parents_4\\\"),\\n                    ExpandParentElementsRecordSet_5 = Table.ExpandRecordColumn(ExpandParentElementsList_5, \\\"Parents_4\\\", {\\\"Name\\\", \\\"Parents\\\"}, {SysName[DimHierarchyNodeName] & Text.From(5), \\\"Parents_5\\\"}),\\n                    ExpandParentElementsList_6 = Table.ExpandListColumn(ExpandParentElementsRecordSet_5, \\\"Parents_5\\\"),\\n                    ExpandParentElementsRecordSet_6 = Table.ExpandRecordColumn(ExpandParentElementsList_6, \\\"Parents_5\\\", {\\\"Name\\\", \\\"Parents\\\"}, {SysName[DimHierarchyNodeName] & Text.From(6), \\\"Parents_6\\\"}),\\n                    ExpandParentElementsList_7 = Table.ExpandListColumn(ExpandParentElementsRecordSet_6, \\\"Parents_6\\\"),\\n                    ExpandParentElementsRecordSet_7 = Table.ExpandRecordColumn(ExpandParentElementsList_7, \\\"Parents_6\\\", {\\\"Name\\\", \\\"Parents\\\"}, {SysName[DimHierarchyNodeName] & Text.From(7), \\\"Parents_7\\\"}),\\n                    ExpandParentElementsList_8 = Table.ExpandListColumn(ExpandParentElementsRecordSet_7, \\\"Parents_7\\\"),\\n                    ExpandParentElementsRecordSet_8 = Table.ExpandRecordColumn(ExpandParentElementsList_8, \\\"Parents_7\\\", {\\\"Name\\\", \\\"Parents\\\"}, {SysName[DimHierarchyNodeName] & Text.From(8), \\\"Parents_8\\\"}),\\n                    ExpandParentElementsList_9 = Table.ExpandListColumn(ExpandParentElementsRecordSet_8, \\\"Parents_8\\\"),\\n                    ExpandParentElementsRecordSet_9 = Table.ExpandRecordColumn(ExpandParentElementsList_9, \\\"Parents_8\\\", {\\\"Name\\\", \\\"Parents\\\"}, {SysName[DimHierarchyNodeName] & Text.From(9), \\\"Parents_9\\\"}),\\n                    ExpandParentElementsList_10 = Table.ExpandListColumn(ExpandParentElementsRecordSet_9, \\\"Parents_9\\\"),\\n                    ExpandParentElementsRecordSet_10 = Table.ExpandRecordColumn(ExpandParentElementsList_10, \\\"Parents_9\\\", {\\\"Name\\\"}, {SysName[DimHierarchyNodeName] & Text.From(10)}),\\n\\n                    DimensionElements = ExpandParentElementsRecordSet_10,\\n                    RemoveNullElements = Table.SelectRows(DimensionElements, each Record.Field( _ , SysName[DimHierarchyNodeName] & Text.From(0)) <> null),   //null-elements are to be removed for the hierarchy flattening function (if any) to work correctly \\n                    AddElementKey = Table.AddColumn(RemoveNullElements, \\\"ElementKey\\\", each \\\"[\\\" & [Dimension] & \\\"].[\\\" & Text.From(Record.Field( _ , SysName[DimHierarchyNodeName] & Text.From(0))) & \\\"]\\\", type text),\\n                    \\n                    AddHierarchyPath = Table.AddColumn(AddElementKey, \\\"HierarchyPath\\\", each null, type text),\\n                    TreeNodeNames = List.Select(Table.ColumnNames(AddHierarchyPath), each Text.StartsWith( _ , SysName[DimHierarchyNodeName]) ),\\n                    ReverseHierachy = fn_reverseHierarchy(AddHierarchyPath, TreeNodeNames, \\\"HierarchyPath\\\"),\\n\\n                    TransformColumnTypes = Table.TransformColumnTypes(ReverseHierachy, {{\\\"ElementIndex\\\", Int64.Type}})\\n                in\\n                    TransformColumnTypes\\n        else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n        then\\n            if Table.RowCount(Source_TransactionLog) > 0\\n            then\\n                Table.FromColumns(\\n                    {     \\n                          {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , {}\\n                        , List.Distinct(TransactionLogDimensions[ElementKey])\\n                        , {}\\n                    }, Table.ColumnNames(NullTable)\\n                )\\n            else\\n                NullTable\\n        else\\n            NullTable\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "ElementAliases",
      "lineageTag": "e98314ee-fa39-4108-b0a0-71fafc3d6c36",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[ElementKey = text, Dimension = text, Element = text, Alias = text, ElementAlias = text], {}),",
        "    Source = ",
        "            if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "            then",
        "                if (try not fn_isSuccessfulHttpRequest(sREST_DimensionElements[#\"@metadata\"]) otherwise true) ",
        "                then     ",
        "                    NullTable",
        "                else ",
        "                    let",
        "                        //Aliases in Dimensions",
        "                        Aliases = Table.Distinct(Table.SelectRows(DimensionAttributes, each [AttributeType] = \"Alias\")[[Dimension], [Attribute]]),",
        "                        AliasesList = Table.Group(Aliases, {\"Dimension\"}, {{\"Attribute\", each List.Combine( {[Attribute]} ) }}),",
        "",
        "                        //Aliases of Elements",
        "                        Value = sREST_DimensionElements[value],",
        "                        ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\"RecordSet\"}, null, ExtraValues.Ignore),",
        "                        ExpandRecordSet = Table.ExpandRecordColumn(ConvertToTable, \"RecordSet\", {\"Name\", \"Hierarchies\"}, {\"Dimension\", \"Hierarchies\"}),",
        "                        NameSelection = Table.SelectRows(ExpandRecordSet, each ",
        "                                                                        let ",
        "                                                                            Dim = [Dimension], ",
        "                                                                            NameFilter = List.MatchesAny( Dimensions[Dimension], each _ = Text.From ( Dim ))",
        "                                                                        in ",
        "                                                                            NameFilter",
        "                                                ),",
        "                        ExpandHierarchiesList = Table.ExpandListColumn(NameSelection, \"Hierarchies\"),",
        "                        SelectDefaultHierarchies = Table.SelectRows(ExpandHierarchiesList, each [Hierarchies][Name] = [Dimension]), // removing all virtual hierarchies",
        "                        ExpandHierarchiesRecordSet = Table.ExpandRecordColumn(SelectDefaultHierarchies, \"Hierarchies\", {\"Name\", \"Elements\"}, {\"Hierarchy\", \"Elements\"}),",
        "                        ExtractAttributes = Table.AddColumn(ExpandHierarchiesRecordSet, \"Attributes\", each List.Transform( [Elements] , each Record.SelectFields( _ , {\"Name\", \"Attributes\"} ))),",
        "                        AddAliasesList = Table.NestedJoin(",
        "                                                            ExtractAttributes,",
        "                                                            \"Dimension\",   ",
        "                                                            AliasesList,",
        "                                                            \"Dimension\",",
        "                                                            \"Aliases\",",
        "                                                            JoinKind.LeftOuter",
        "                        ),",
        "                        ExpandAliases = Table.ExpandTableColumn(AddAliasesList, \"Aliases\", {\"Attribute\"}, {\"Aliases\"}),",
        "                        SelectAliasesFieldNames = Table.FromRecords(Table.TransformRows(ExpandAliases, ",
        "                                                                        ( row ) => Record.TransformFields(row, { \"Attributes\", ( ListValue ) => ",
        "                                                                                                                    List.Transform( ListValue , each",
        "                                                                                                                        let",
        "                                                                                                                            RenameElementFileld = Record.RenameFields( _ , { \"Name\", \"Element\" } ), // Assigning a target element name ",
        "                                                                                                                            AttributsUnionElement = RenameElementFileld[Attributes] & RenameElementFileld[[Element]], // The object-element replaces the \"Element\" attribute value, if any",
        "                                                                                                                            Attributes = if row[Aliases] <> null then row[Aliases] else {},",
        "                                                                                                                            SelectFields = Record.SelectFields( AttributsUnionElement, List.Union({ {\"Element\"}, { \"Caption\" }, Attributes } ), MissingField.Ignore )",
        "                                                                                                                        in",
        "                                                                                                                            SelectFields",
        "                                                                                                                    )",
        "                                                                                                                }",
        "                                                                                                        )",
        "                                                                    )",
        "                        ),",
        "                        CreateTableFromListOfRecords = Table.TransformColumns(SelectAliasesFieldNames, { \"Attributes\", ( value ) => Table.FromRecords(value) }),",
        "                        UnpivotAliases = Table.TransformColumns(CreateTableFromListOfRecords, { \"Attributes\", ( value ) => Table.UnpivotOtherColumns(value, {\"Element\"}, \"Alias\", \"ElementAlias\") }),",
        "                        FinalizeAliases = Table.ExpandTableColumn(UnpivotAliases, \"Attributes\", {\"Element\", \"Alias\", \"ElementAlias\"}),",
        "                        AddElementKey = Table.AddColumn(FinalizeAliases, \"ElementKey\", each \"[\" & [Dimension] & \"].[\" & [Element] & \"]\"),",
        "                        ElementAliases = AddElementKey[[ElementKey], [Dimension], [Element], [Alias], [ElementAlias]]        ",
        "                    in",
        "                        ElementAliases    ",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            NullTable",
        "        else",
        "            NullTable",
        "    in",
        "        Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[ElementKey = text, Dimension = text, Element = text, Alias = text, ElementAlias = text], {}),\\n    Source = \\n            if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\" \\n            then\\n                if (try not fn_isSuccessfulHttpRequest(sREST_DimensionElements[#\\\"@metadata\\\"]) otherwise true) \\n                then     \\n                    NullTable\\n                else \\n                    let\\n                        //Aliases in Dimensions\\n                        Aliases = Table.Distinct(Table.SelectRows(DimensionAttributes, each [AttributeType] = \\\"Alias\\\")[[Dimension], [Attribute]]),\\n                        AliasesList = Table.Group(Aliases, {\\\"Dimension\\\"}, {{\\\"Attribute\\\", each List.Combine( {[Attribute]} ) }}),\\n\\n                        //Aliases of Elements\\n                        Value = sREST_DimensionElements[value],\\n                        ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\\\"RecordSet\\\"}, null, ExtraValues.Ignore),\\n                        ExpandRecordSet = Table.ExpandRecordColumn(ConvertToTable, \\\"RecordSet\\\", {\\\"Name\\\", \\\"Hierarchies\\\"}, {\\\"Dimension\\\", \\\"Hierarchies\\\"}),\\n                        NameSelection = Table.SelectRows(ExpandRecordSet, each \\n                                                                        let \\n                                                                            Dim = [Dimension], \\n                                                                            NameFilter = List.MatchesAny( Dimensions[Dimension], each _ = Text.From ( Dim ))\\n                                                                        in \\n                                                                            NameFilter\\n                                                ),\\n                        ExpandHierarchiesList = Table.ExpandListColumn(NameSelection, \\\"Hierarchies\\\"),\\n                        SelectDefaultHierarchies = Table.SelectRows(ExpandHierarchiesList, each [Hierarchies][Name] = [Dimension]), // removing all virtual hierarchies\\n                        ExpandHierarchiesRecordSet = Table.ExpandRecordColumn(SelectDefaultHierarchies, \\\"Hierarchies\\\", {\\\"Name\\\", \\\"Elements\\\"}, {\\\"Hierarchy\\\", \\\"Elements\\\"}),\\n                        ExtractAttributes = Table.AddColumn(ExpandHierarchiesRecordSet, \\\"Attributes\\\", each List.Transform( [Elements] , each Record.SelectFields( _ , {\\\"Name\\\", \\\"Attributes\\\"} ))),\\n                        AddAliasesList = Table.NestedJoin(\\n                                                            ExtractAttributes,\\n                                                            \\\"Dimension\\\",   \\n                                                            AliasesList,\\n                                                            \\\"Dimension\\\",\\n                                                            \\\"Aliases\\\",\\n                                                            JoinKind.LeftOuter\\n                        ),\\n                        ExpandAliases = Table.ExpandTableColumn(AddAliasesList, \\\"Aliases\\\", {\\\"Attribute\\\"}, {\\\"Aliases\\\"}),\\n                        SelectAliasesFieldNames = Table.FromRecords(Table.TransformRows(ExpandAliases, \\n                                                                        ( row ) => Record.TransformFields(row, { \\\"Attributes\\\", ( ListValue ) => \\n                                                                                                                    List.Transform( ListValue , each\\n                                                                                                                        let\\n                                                                                                                            RenameElementFileld = Record.RenameFields( _ , { \\\"Name\\\", \\\"Element\\\" } ), // Assigning a target element name \\n                                                                                                                            AttributsUnionElement = RenameElementFileld[Attributes] & RenameElementFileld[[Element]], // The object-element replaces the \\\"Element\\\" attribute value, if any\\n                                                                                                                            Attributes = if row[Aliases] <> null then row[Aliases] else {},\\n                                                                                                                            SelectFields = Record.SelectFields( AttributsUnionElement, List.Union({ {\\\"Element\\\"}, { \\\"Caption\\\" }, Attributes } ), MissingField.Ignore )\\n                                                                                                                        in\\n                                                                                                                            SelectFields\\n                                                                                                                    )\\n                                                                                                                }\\n                                                                                                        )\\n                                                                    )\\n                        ),\\n                        CreateTableFromListOfRecords = Table.TransformColumns(SelectAliasesFieldNames, { \\\"Attributes\\\", ( value ) => Table.FromRecords(value) }),\\n                        UnpivotAliases = Table.TransformColumns(CreateTableFromListOfRecords, { \\\"Attributes\\\", ( value ) => Table.UnpivotOtherColumns(value, {\\\"Element\\\"}, \\\"Alias\\\", \\\"ElementAlias\\\") }),\\n                        FinalizeAliases = Table.ExpandTableColumn(UnpivotAliases, \\\"Attributes\\\", {\\\"Element\\\", \\\"Alias\\\", \\\"ElementAlias\\\"}),\\n                        AddElementKey = Table.AddColumn(FinalizeAliases, \\\"ElementKey\\\", each \\\"[\\\" & [Dimension] & \\\"].[\\\" & [Element] & \\\"]\\\"),\\n                        ElementAliases = AddElementKey[[ElementKey], [Dimension], [Element], [Alias], [ElementAlias]]        \\n                    in\\n                        ElementAliases    \\n        else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n        then\\n            NullTable\\n        else\\n            NullTable\\n    in\\n        Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Users",
      "lineageTag": "6cb7f69b-0b5d-46fc-b059-433739ae4d57",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[User = text, UserName = text, UserType = text, IsUserActive = logical, UserEnabled = logical], {}),",
        "",
        "     Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(sREST_Users[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                let",
        "                    Value = sREST_Users[value],",
        "                    ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\"RecordSet\"}, null, ExtraValues.Ignore),",
        "                    ExpandRecordSet = Table.ExpandRecordColumn(ConvertToTable, \"RecordSet\", {\"Name\", \"FriendlyName\", \"Type\", \"IsActive\", \"Enabled\"}, {\"User\", \"UserName\", \"UserType\", \"IsUserActive\", \"UserEnabled\"})",
        "                in",
        "                    ExpandRecordSet        ",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            if Table.RowCount(Source_TransactionLog) > 0",
        "            then",
        "                Table.FromColumns(",
        "                    {",
        "                          List.Distinct(Source_TransactionLog[User])",
        "                        , List.Distinct(Source_TransactionLog[User])",
        "                        , {}",
        "                        , {}",
        "                        , {}",
        "                    }, Table.ColumnNames(NullTable)",
        "                )",
        "            else",
        "                NullTable",
        "        else",
        "            NullTable",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[User = text, UserName = text, UserType = text, IsUserActive = logical, UserEnabled = logical], {}),\\n\\n     Source = \\n        if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\"\\n        then\\n            if (try not fn_isSuccessfulHttpRequest(sREST_Users[#\\\"@metadata\\\"]) otherwise true) \\n            then     \\n                NullTable\\n            else\\n                let\\n                    Value = sREST_Users[value],\\n                    ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\\\"RecordSet\\\"}, null, ExtraValues.Ignore),\\n                    ExpandRecordSet = Table.ExpandRecordColumn(ConvertToTable, \\\"RecordSet\\\", {\\\"Name\\\", \\\"FriendlyName\\\", \\\"Type\\\", \\\"IsActive\\\", \\\"Enabled\\\"}, {\\\"User\\\", \\\"UserName\\\", \\\"UserType\\\", \\\"IsUserActive\\\", \\\"UserEnabled\\\"})\\n                in\\n                    ExpandRecordSet        \\n        else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n        then\\n            if Table.RowCount(Source_TransactionLog) > 0\\n            then\\n                Table.FromColumns(\\n                    {\\n                          List.Distinct(Source_TransactionLog[User])\\n                        , List.Distinct(Source_TransactionLog[User])\\n                        , {}\\n                        , {}\\n                        , {}\\n                    }, Table.ColumnNames(NullTable)\\n                )\\n            else\\n                NullTable\\n        else\\n            NullTable\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "UserGroups",
      "lineageTag": "487fd2c4-11a1-4e35-a215-fa4be3fde935",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[User = text, InGroup = text, GroupName = text], {}),",
        "",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(#\"sREST_}ClientGroups\"[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                let",
        "                    Dim1 = \"}Clients\",",
        "                    Dim2 = \"}Groups\",",
        "                    Dim3 = \"}ElementAttributes_}Groups\",",
        "                    ",
        "                    TabulateClientGroups = fn_tabulateCubeData(#\"sREST_}ClientGroups\"[Axes], #\"sREST_}ClientGroups\"[Cells]),",
        "                    CheckClientGroups = if Table.IsEmpty(TabulateClientGroups) then Table.FromRows({}, {Dim1, Dim2, \"Value\"}) else TabulateClientGroups,",
        "                    ClientGroups = Table.RenameColumns(CheckClientGroups, {{Dim1, \"User\"}, {Dim2, \"Group\"}, {\"Value\", \"InGroup\"}}),",
        "",
        "                    TabulateGroups = fn_tabulateCubeData(#\"sREST_}ElementAttributes_}Groups\"[Axes], #\"sREST_}ElementAttributes_}Groups\"[Cells]),",
        "                    CheckGroups = if Table.IsEmpty(TabulateGroups) then Table.FromRows({}, {Dim2, Dim3, \"Value\"}) else TabulateGroups,",
        "                    RenameGroupsColumns = Table.RenameColumns(CheckGroups, {{Dim2, \"Group\"}, {Dim3, \"DefaultDisplayValue\"}, {\"Value\", \"GroupName\"}}),",
        "                    Groups = Table.SelectRows(RenameGroupsColumns, each ([DefaultDisplayValue] = \"}TM1_DefaultDisplayValue\")),",
        "",
        "                    ExtendedClientGroups = Table.NestedJoin(",
        "                                          Table.SelectColumns(ClientGroups , {\"User\", \"InGroup\"})",
        "                                        , \"InGroup\"",
        "                                        , Table.SelectColumns(Groups, {\"Group\", \"GroupName\"})",
        "                                        , \"Group\"",
        "                                        , \"GroupName\"",
        "                                        , JoinKind.LeftOuter",
        "                    ),",
        "                    ExpandGroupName = Table.ExpandTableColumn(ExtendedClientGroups, \"GroupName\", {\"GroupName\"}),",
        "                    ReplaceNullFriendlyName = Table.ReplaceValue(",
        "                                                              ExpandGroupName",
        "                                                            , each null",
        "                                                            , each [InGroup]",
        "                                                            , Replacer.ReplaceValue",
        "                                                            , {\"GroupName\"}",
        "                    )",
        "                in ",
        "                    ReplaceNullFriendlyName",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            if Table.RowCount(Source_TransactionLog) > 0",
        "            then",
        "                Table.FromColumns(",
        "                    {",
        "                          List.Distinct(Source_TransactionLog[User])",
        "                        , {}",
        "                        , {}",
        "                    }, Table.ColumnNames(NullTable)",
        "                )",
        "            else",
        "                NullTable",
        "        else",
        "            NullTable",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[User = text, InGroup = text, GroupName = text], {}),\\n\\n    Source = \\n        if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\" \\n        then\\n            if (try not fn_isSuccessfulHttpRequest(#\\\"sREST_}ClientGroups\\\"[#\\\"@metadata\\\"]) otherwise true) \\n            then     \\n                NullTable\\n            else\\n                let\\n                    Dim1 = \\\"}Clients\\\",\\n                    Dim2 = \\\"}Groups\\\",\\n                    Dim3 = \\\"}ElementAttributes_}Groups\\\",\\n                    \\n                    TabulateClientGroups = fn_tabulateCubeData(#\\\"sREST_}ClientGroups\\\"[Axes], #\\\"sREST_}ClientGroups\\\"[Cells]),\\n                    CheckClientGroups = if Table.IsEmpty(TabulateClientGroups) then Table.FromRows({}, {Dim1, Dim2, \\\"Value\\\"}) else TabulateClientGroups,\\n                    ClientGroups = Table.RenameColumns(CheckClientGroups, {{Dim1, \\\"User\\\"}, {Dim2, \\\"Group\\\"}, {\\\"Value\\\", \\\"InGroup\\\"}}),\\n\\n                    TabulateGroups = fn_tabulateCubeData(#\\\"sREST_}ElementAttributes_}Groups\\\"[Axes], #\\\"sREST_}ElementAttributes_}Groups\\\"[Cells]),\\n                    CheckGroups = if Table.IsEmpty(TabulateGroups) then Table.FromRows({}, {Dim2, Dim3, \\\"Value\\\"}) else TabulateGroups,\\n                    RenameGroupsColumns = Table.RenameColumns(CheckGroups, {{Dim2, \\\"Group\\\"}, {Dim3, \\\"DefaultDisplayValue\\\"}, {\\\"Value\\\", \\\"GroupName\\\"}}),\\n                    Groups = Table.SelectRows(RenameGroupsColumns, each ([DefaultDisplayValue] = \\\"}TM1_DefaultDisplayValue\\\")),\\n\\n                    ExtendedClientGroups = Table.NestedJoin(\\n                                          Table.SelectColumns(ClientGroups , {\\\"User\\\", \\\"InGroup\\\"})\\n                                        , \\\"InGroup\\\"\\n                                        , Table.SelectColumns(Groups, {\\\"Group\\\", \\\"GroupName\\\"})\\n                                        , \\\"Group\\\"\\n                                        , \\\"GroupName\\\"\\n                                        , JoinKind.LeftOuter\\n                    ),\\n                    ExpandGroupName = Table.ExpandTableColumn(ExtendedClientGroups, \\\"GroupName\\\", {\\\"GroupName\\\"}),\\n                    ReplaceNullFriendlyName = Table.ReplaceValue(\\n                                                              ExpandGroupName\\n                                                            , each null\\n                                                            , each [InGroup]\\n                                                            , Replacer.ReplaceValue\\n                                                            , {\\\"GroupName\\\"}\\n                    )\\n                in \\n                    ReplaceNullFriendlyName\\n        else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n        then\\n            if Table.RowCount(Source_TransactionLog) > 0\\n            then\\n                Table.FromColumns(\\n                    {\\n                          List.Distinct(Source_TransactionLog[User])\\n                        , {}\\n                        , {}\\n                    }, Table.ColumnNames(NullTable)\\n                )\\n            else\\n                NullTable\\n        else\\n            NullTable\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Source_MessageLog",
      "lineageTag": "f683b3c1-14ab-4b16-a102-d8cdf3d555b4",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    ///TODO - check fields!!!",
        "    NullTable = #table(type table[TimeStamp = datetime, Level = text, Message = text], {}),",
        "    ",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(sREST_MessageLog[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                let",
        "                    Value = sREST_MessageLog[value],",
        "                    ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\"RecordSet\"}, null, ExtraValues.Ignore),",
        "                    ExpandMessageLog = Table.ExpandRecordColumn(ConvertToTable, \"RecordSet\", {\"TimeStamp\", \"Level\", \"Message\"})",
        "                in",
        "                    ExpandMessageLog",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            let",
        "                SourceTable = ",
        "                    if DataFiles_MessageLog = null ",
        "                    then NullTable ",
        "                    else ",
        "                        let ",
        "                            Source = DataFiles_MessageLog",
        "                        in",
        "                           Source ",
        "            in",
        "                SourceTable",
        "        else",
        "            NullTable,",
        "        ",
        "    MessagesPattern = Record.ToList(SysMessageLog),",
        "    Selection = Table.SelectRows(Source, each ",
        "                                                let ",
        "                                                    Msg = [Message], ",
        "                                                    Filter = List.MatchesAny( MessagesPattern, each Text.Contains ( Msg, _ ))",
        "                                                in ",
        "                                                    Filter",
        "                                        ),",
        "    TransformColumnTypes = Table.TransformColumnTypes(Selection, {{\"TimeStamp\", type datetime}, {\"Level\", type text}, {\"Message\", type text}})",
        "in",
        "    TransformColumnTypes"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Unknown",
      "isHidden": false
    },
    {
      "name": "FeedersProcessing",
      "lineageTag": "8d2df2c6-f219-4a7c-9137-4ecd242b1c7b",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[TimeStamp = datetime, Message = text, msDuration = Int64.Type], {}),",
        "",
        "    FeedersProcessingLog = Source_MessageLog[[TimeStamp], [Message]],",
        "    MsgSelection = Table.SelectRows(FeedersProcessingLog, each Text.Contains( [Message], SysMessageLog[ProcessFeedersMsg] )),",
        "    AddCube = Table.AddColumn(",
        "        MsgSelection",
        "        , \"Cube\"",
        "        , each Text.BetweenDelimiters([Message], \"Done computing feeders for base cube '\", \"'.\")",
        "        , type text",
        "    ),",
        "    NameSelection = Table.SelectRows(AddCube, each ",
        "                                        let ",
        "                                            Name = [Cube], ",
        "                                            NameFilter = List.MatchesAny( KeyWords[SysMetaDataRef], each not Text.StartsWith( Name, _ ))",
        "                                        in ",
        "                                            NameFilter",
        "                ),",
        "    AddTime = Table.AddColumn(",
        "        NameSelection",
        "        , \"msDuration\"",
        "        , each try Number.FromText(Text.Trim(Text.BetweenDelimiters([Message], \"ProcessFeeders(in\", \"ms)\")), \"en-US\") otherwise 0",
        "        , Int64.Type",
        "    )",
        "   ",
        "in",
        "    AddTime[[TimeStamp], [Cube], [msDuration]]"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[TimeStamp = datetime, Message = text, msDuration = Int64.Type], {}),\\n\\n    FeedersProcessingLog = Source_MessageLog[[TimeStamp], [Message]],\\n    MsgSelection = Table.SelectRows(FeedersProcessingLog, each Text.Contains( [Message], SysMessageLog[ProcessFeedersMsg] )),\\n    AddCube = Table.AddColumn(\\n        MsgSelection\\n        , \\\"Cube\\\"\\n        , each Text.BetweenDelimiters([Message], \\\"Done computing feeders for base cube '\\\", \\\"'.\\\")\\n        , type text\\n    ),\\n    NameSelection = Table.SelectRows(AddCube, each \\n                                        let \\n                                            Name = [Cube], \\n                                            NameFilter = List.MatchesAny( KeyWords[SysMetaDataRef], each not Text.StartsWith( Name, _ ))\\n                                        in \\n                                            NameFilter\\n                ),\\n    AddTime = Table.AddColumn(\\n        NameSelection\\n        , \\\"msDuration\\\"\\n        , each try Number.FromText(Text.Trim(Text.BetweenDelimiters([Message], \\\"ProcessFeeders(in\\\", \\\"ms)\\\")), \\\"en-US\\\") otherwise 0\\n        , Int64.Type\\n    )\\n   \\nin\\n    AddTime[[TimeStamp], [Cube], [msDuration]]\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "ModelElapsedTime",
      "lineageTag": "8ddf7702-2e76-4fd9-8d92-6ced4bf94ee8",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[TimeStamp = datetime, Time = time], {}),",
        "    ",
        "    FeedersProcessingLog = Source_MessageLog[[TimeStamp], [Message]],",
        "    MsgSelection = Table.SelectRows(FeedersProcessingLog, each Text.Contains( [Message], SysMessageLog[ElapsedTimeMsg] )),",
        "    AddSeconds = Table.AddColumn(",
        "        MsgSelection",
        "        , \"Seconds\"",
        "        , each try Number.FromText(Text.Trim(Text.BetweenDelimiters([Message], \"TM1 Server is ready, elapsed time\", \"seconds\")), \"en-US\") otherwise 0",
        "        , Int64.Type",
        "    ),",
        "    AddTime = Table.AddColumn(",
        "       AddSeconds",
        "       , \"Time\"",
        "       , each #time(0, 0, 0) + #duration(0, 0, 0, [Seconds])",
        "       , type time",
        "    )",
        "in",
        "    AddTime[[TimeStamp], [Time]]"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[TimeStamp = datetime, Time = time], {}),\\n    \\n    FeedersProcessingLog = Source_MessageLog[[TimeStamp], [Message]],\\n    MsgSelection = Table.SelectRows(FeedersProcessingLog, each Text.Contains( [Message], SysMessageLog[ElapsedTimeMsg] )),\\n    AddSeconds = Table.AddColumn(\\n        MsgSelection\\n        , \\\"Seconds\\\"\\n        , each try Number.FromText(Text.Trim(Text.BetweenDelimiters([Message], \\\"TM1 Server is ready, elapsed time\\\", \\\"seconds\\\")), \\\"en-US\\\") otherwise 0\\n        , Int64.Type\\n    ),\\n    AddTime = Table.AddColumn(\\n       AddSeconds\\n       , \\\"Time\\\"\\n       , each #time(0, 0, 0) + #duration(0, 0, 0, [Seconds])\\n       , type time\\n    )\\nin\\n    AddTime[[TimeStamp], [Time]]\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Source_TransactionLog",
      "lineageTag": "2651dfdf-1ee7-4a65-908d-8aa6f117ffd9",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    ///TODO - check fields!!!",
        "    NullTable = #table(type table[RecordNo = number, TimeStamp = datetime, Tuple = any, User = text, Cube = text, OldValue = text, NewValue = text], {}),",
        "    ",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(sREST_TransactionLog[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                let",
        "                    Value = sREST_TransactionLog[value],",
        "                    ConvertToTable = Table.FromList(Value, Splitter.SplitByNothing(), {\"RecordSet\"}, null, ExtraValues.Ignore),",
        "                    ExpandTransactionLog = Table.ExpandRecordColumn(ConvertToTable, \"RecordSet\", {\"TimeStamp\", \"User\", \"Cube\", \"Tuple\", \"OldValue\", \"NewValue\"}),",
        "                    NameSelection = Table.SelectRows(ExpandTransactionLog, each ",
        "                                                                let ",
        "                                                                    Cube = [Cube], ",
        "                                                                    NameFilter = List.MatchesAny( Cubes[Cube], each _ = Text.From ( Cube ))",
        "                                                                in ",
        "                                                                    NameFilter",
        "                                        ),",
        "                    RemoveNullRows = Table.SelectRows(NameSelection, each [Cube] <> null),",
        "                    AddIndexColumn = Table.AddIndexColumn(RemoveNullRows, \"RecordNo\", 0)",
        "                in",
        "                    AddIndexColumn",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            let",
        "                SourceTable = ",
        "                    if DataFiles_TransactionLog = null ",
        "                    then NullTable ",
        "                    else ",
        "                        let ",
        "                            Source = DataFiles_TransactionLog,",
        "                            AddIndexColumn = Table.AddIndexColumn(SourceTable, \"RecordNo\", 0)",
        "                        in",
        "                           AddIndexColumn ",
        "            in",
        "                SourceTable",
        "        else",
        "            NullTable,",
        "    TransformColumnTypes = Table.TransformColumnTypes(Source, {{\"RecordNo\", type number}, {\"TimeStamp\", type datetime}, {\"User\", type text}, {\"Cube\", type text}, {\"OldValue\", type text}, {\"NewValue\", type text}})",
        "in",
        "    TransformColumnTypes"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "TransactionLog",
      "lineageTag": "f0f5b980-bf4e-429b-ba43-07aabf139a3b",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[RecordNo = number, TimeStamp = datetime, User = text, Cube = text, OldValue = text, NewValue = text], {}),",
        "",
        "    Source = Source_TransactionLog[[RecordNo], [TimeStamp], [User], [Cube], [OldValue], [NewValue]]",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[RecordNo = number, TimeStamp = datetime, User = text, Cube = text, OldValue = text, NewValue = text], {}),\\n\\n    Source = Source_TransactionLog[[RecordNo], [TimeStamp], [User], [Cube], [OldValue], [NewValue]]\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "TransactionLogDimensions",
      "lineageTag": "9b2e0921-681c-40c7-baed-3e895324c407",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    TransactionLogTuples = Source_TransactionLog[[RecordNo], [Cube], [Tuple]],",
        "",
        "    Dimensions = ",
        "        if Table.RowCount(CubeDimensions) > 0",
        "        then",
        "            let",
        "                CubeDimensionList = Table.Group(CubeDimensions, {\"Cube\"}, {{\"Dimension\", each List.Combine( {[Dimension]} ) }}),",
        "",
        "                JointTable = Table.NestedJoin(",
        "                                TransactionLogTuples",
        "                                , \"Cube\"",
        "                                , CubeDimensionList",
        "                                , \"Cube\"",
        "                                , \"CubeDimensions\"",
        "                                , JoinKind.LeftOuter",
        "                ),",
        "                ExpandCubeDimensions = Table.ExpandTableColumn(JointTable, \"CubeDimensions\", {\"Dimension\"})",
        "            in",
        "                ExpandCubeDimensions",
        "        else",
        "                Table.AddColumn(TransactionLogTuples, \"Dimension\",  (row) =>",
        "                                                            List.Generate(",
        "                                                                () => [Counter = 1, Dims = SysName[DimTransactionLogName] & Text.From(Counter) ]",
        "                                                                , each [Counter] <= List.Count(row[Tuple])",
        "                                                                , each [Counter = [Counter] + 1, Dims = SysName[DimTransactionLogName] & Text.From(Counter) ]",
        "                                                                , each [Dims]",
        "                                                            )",
        "                ),",
        "    ExpandDimension = Table.ExpandListColumn(Dimensions, \"Dimension\"),",
        "    ExpandTuple = Table.ExpandListColumn(Dimensions, \"Tuple\"),",
        "    TableFromColumns = Table.FromColumns(",
        "                                        {ExpandTuple[RecordNo], ExpandTuple[Cube], ExpandDimension[Dimension], ExpandTuple[Tuple] }",
        "                                        , {\"RecordNo\", \"Cube\", \"Dimension\", \"Element\"}",
        "                                    ),",
        "    AddElementKey = Table.AddColumn(TableFromColumns, \"ElementKey\", each \"[\" & [Dimension] & \"].[\" & [Element] & \"]\")",
        "in",
        "    AddElementKey"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    TransactionLogTuples = Source_TransactionLog[[RecordNo], [Cube], [Tuple]],\\n\\n    Dimensions = \\n        if Table.RowCount(CubeDimensions) > 0\\n        then\\n            let\\n                CubeDimensionList = Table.Group(CubeDimensions, {\\\"Cube\\\"}, {{\\\"Dimension\\\", each List.Combine( {[Dimension]} ) }}),\\n\\n                JointTable = Table.NestedJoin(\\n                                TransactionLogTuples\\n                                , \\\"Cube\\\"\\n                                , CubeDimensionList\\n                                , \\\"Cube\\\"\\n                                , \\\"CubeDimensions\\\"\\n                                , JoinKind.LeftOuter\\n                ),\\n                ExpandCubeDimensions = Table.ExpandTableColumn(JointTable, \\\"CubeDimensions\\\", {\\\"Dimension\\\"})\\n            in\\n                ExpandCubeDimensions\\n        else\\n                Table.AddColumn(TransactionLogTuples, \\\"Dimension\\\",  (row) =>\\n                                                            List.Generate(\\n                                                                () => [Counter = 1, Dims = SysName[DimTransactionLogName] & Text.From(Counter) ]\\n                                                                , each [Counter] <= List.Count(row[Tuple])\\n                                                                , each [Counter = [Counter] + 1, Dims = SysName[DimTransactionLogName] & Text.From(Counter) ]\\n                                                                , each [Dims]\\n                                                            )\\n                ),\\n    ExpandDimension = Table.ExpandListColumn(Dimensions, \\\"Dimension\\\"),\\n    ExpandTuple = Table.ExpandListColumn(Dimensions, \\\"Tuple\\\"),\\n    TableFromColumns = Table.FromColumns(\\n                                        {ExpandTuple[RecordNo], ExpandTuple[Cube], ExpandDimension[Dimension], ExpandTuple[Tuple] }\\n                                        , {\\\"RecordNo\\\", \\\"Cube\\\", \\\"Dimension\\\", \\\"Element\\\"}\\n                                    ),\\n    AddElementKey = Table.AddColumn(TableFromColumns, \\\"ElementKey\\\", each \\\"[\\\" & [Dimension] & \\\"].[\\\" & [Element] & \\\"]\\\")\\nin\\n    AddElementKey\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "CubeSecurity",
      "lineageTag": "a7b1b6e5-cb9e-42f8-a8a1-f73f0435d1dc",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[Cube = text, Group = text, AccessLevel = text], {}),",
        "",
        "     Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(#\"sREST_}CubeSecurity\"[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                let",
        "                    Dim1 = \"}Cubes\",",
        "                    Dim2 = \"}Groups\",",
        "",
        "                    TabulateCubeSecurity = fn_tabulateCubeData(#\"sREST_}CubeSecurity\"[Axes], #\"sREST_}CubeSecurity\"[Cells]),",
        "                    CheckCubeSecurity = if Table.IsEmpty(TabulateCubeSecurity) then Table.FromRows({}, {Dim1, Dim2, \"Value\"}) else TabulateCubeSecurity,",
        "                    RenameCubeSecurityColumns = Table.RenameColumns(CheckCubeSecurity, {{Dim1, \"Cube\"}, {Dim2, \"Group\"}, {\"Value\", \"AccessLevel\"}}),",
        "                    NameSelection = Table.SelectRows(RenameCubeSecurityColumns, each ",
        "                                                                let ",
        "                                                                    Name = [Cube], ",
        "                                                                    NameFilter = List.MatchesAny( KeyWords[SysMetaDataRef], each not Text.StartsWith( Name, _ ))",
        "                                                                in ",
        "                                                                    NameFilter",
        "                    ),",
        "                    CubeSecurity =  Table.SelectColumns(NameSelection, {\"Cube\", \"Group\", \"AccessLevel\"})",
        "                in",
        "                    CubeSecurity ",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            NullTable",
        "        else",
        "            NullTable",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[Cube = text, Group = text, AccessLevel = text], {}),\\n\\n     Source = \\n        if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\"\\n        then\\n            if (try not fn_isSuccessfulHttpRequest(#\\\"sREST_}CubeSecurity\\\"[#\\\"@metadata\\\"]) otherwise true) \\n            then     \\n                NullTable\\n            else\\n                let\\n                    Dim1 = \\\"}Cubes\\\",\\n                    Dim2 = \\\"}Groups\\\",\\n\\n                    TabulateCubeSecurity = fn_tabulateCubeData(#\\\"sREST_}CubeSecurity\\\"[Axes], #\\\"sREST_}CubeSecurity\\\"[Cells]),\\n                    CheckCubeSecurity = if Table.IsEmpty(TabulateCubeSecurity) then Table.FromRows({}, {Dim1, Dim2, \\\"Value\\\"}) else TabulateCubeSecurity,\\n                    RenameCubeSecurityColumns = Table.RenameColumns(CheckCubeSecurity, {{Dim1, \\\"Cube\\\"}, {Dim2, \\\"Group\\\"}, {\\\"Value\\\", \\\"AccessLevel\\\"}}),\\n                    NameSelection = Table.SelectRows(RenameCubeSecurityColumns, each \\n                                                                let \\n                                                                    Name = [Cube], \\n                                                                    NameFilter = List.MatchesAny( KeyWords[SysMetaDataRef], each not Text.StartsWith( Name, _ ))\\n                                                                in \\n                                                                    NameFilter\\n                    ),\\n                    CubeSecurity =  Table.SelectColumns(NameSelection, {\\\"Cube\\\", \\\"Group\\\", \\\"AccessLevel\\\"})\\n                in\\n                    CubeSecurity \\n        else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n        then\\n            NullTable\\n        else\\n            NullTable\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "CubeStats",
      "lineageTag": "f852f979-7750-45d5-b95d-9ff50d0f31d0",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[Cube = text, Indicator = text, TimeIntervals = text, DateTime = datetime, Value = Int64.Type, HoursOffset = Int64.Type], {}),",
        "",
        "    Source = ",
        "    if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "    then",
        "        if (try not fn_isSuccessfulHttpRequest(#\"sREST_}StatsByCube\"[#\"@metadata\"]) otherwise true) ",
        "        then     ",
        "            NullTable",
        "        else",
        "            let",
        "                Dim1 = \"}PerfCubes\",",
        "                Dim2 = \"}StatsStatsByCube\",",
        "                Dim3 = \"}TimeIntervals\",",
        "",
        "                TabulateCubeData = fn_tabulateCubeData(#\"sREST_}StatsByCube\"[Axes], #\"sREST_}StatsByCube\"[Cells]),",
        "                CheckCubeData = if Table.IsEmpty(TabulateCubeData) then Table.FromRows({}, {Dim1, Dim2, Dim3, \"Value\"}) else TabulateCubeData,",
        "                RenameCubeColumns = Table.RenameColumns(CheckCubeData, {{Dim1, \"Cube\"}, {Dim2, \"Indicator\"},  {Dim3, \"TimeIntervals\"}, {\"Value\", \"Value\"}}),",
        "                NameSelection = Table.SelectRows(RenameCubeColumns, each ",
        "                                                                        let ",
        "                                                                            Name = [Cube], ",
        "                                                                            NameFilter = List.MatchesAny( KeyWords[SysMetaDataRef], each not Text.StartsWith( Name, _ ))",
        "                                                                        in ",
        "                                                                            NameFilter",
        "                ),",
        "                CubeStats = Table.SelectColumns(NameSelection, {\"Cube\", \"Indicator\", \"TimeIntervals\", \"Value\"}),",
        "                RemoveCubesTotal = Table.SelectRows(CubeStats, each Text.From([Cube]) <> \"Cubes Total\"), // Not needed for BI reports",
        "                ReplaceNullValues = Table.ReplaceValue(RemoveCubesTotal, null, 0, Replacer.ReplaceValue, {\"Value\"}), ",
        "                AggregateMRecords = fn_aggregateMTimeIntervalsToCurrentHour(ReplaceNullValues,  {\"Cube\", \"Indicator\", \"TimeIntervals\"}, {{\"Value\", each List.Average([Value]), type nullable number}}, \"TimeIntervals\"),",
        "                DuplicateTimeIntervalsColumn = Table.DuplicateColumn(AggregateMRecords, \"TimeIntervals\", \"DateTime\"),",
        "                AddDateTime = fn_transformTimeIntervalsToDateTime(DuplicateTimeIntervalsColumn, \"DateTime\"),                           ",
        "                LatestDateTime = List.Max(AddDateTime[DateTime]),",
        "                HoursOffset = Table.AddColumn(AddDateTime, \"HoursOffset\", each Number.RoundDown(Duration.TotalHours( Duration.From([DateTime] - LatestDateTime)) ), Int64.Type),",
        "                TransformColumnTypes = Table.TransformColumnTypes(HoursOffset, {{\"Cube\", type text}, {\"Indicator\", type text}, {\"TimeIntervals\", type text}, {\"DateTime\", type datetime}, {\"Value\", Int64.Type}})",
        "            in",
        "                TransformColumnTypes",
        "    else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "    then",
        "        NullTable",
        "    else",
        "        NullTable",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[Cube = text, Indicator = text, TimeIntervals = text, DateTime = datetime, Value = Int64.Type, HoursOffset = Int64.Type], {}),\\n\\n    Source = \\n    if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\"\\n    then\\n        if (try not fn_isSuccessfulHttpRequest(#\\\"sREST_}StatsByCube\\\"[#\\\"@metadata\\\"]) otherwise true) \\n        then     \\n            NullTable\\n        else\\n            let\\n                Dim1 = \\\"}PerfCubes\\\",\\n                Dim2 = \\\"}StatsStatsByCube\\\",\\n                Dim3 = \\\"}TimeIntervals\\\",\\n\\n                TabulateCubeData = fn_tabulateCubeData(#\\\"sREST_}StatsByCube\\\"[Axes], #\\\"sREST_}StatsByCube\\\"[Cells]),\\n                CheckCubeData = if Table.IsEmpty(TabulateCubeData) then Table.FromRows({}, {Dim1, Dim2, Dim3, \\\"Value\\\"}) else TabulateCubeData,\\n                RenameCubeColumns = Table.RenameColumns(CheckCubeData, {{Dim1, \\\"Cube\\\"}, {Dim2, \\\"Indicator\\\"},  {Dim3, \\\"TimeIntervals\\\"}, {\\\"Value\\\", \\\"Value\\\"}}),\\n                NameSelection = Table.SelectRows(RenameCubeColumns, each \\n                                                                        let \\n                                                                            Name = [Cube], \\n                                                                            NameFilter = List.MatchesAny( KeyWords[SysMetaDataRef], each not Text.StartsWith( Name, _ ))\\n                                                                        in \\n                                                                            NameFilter\\n                ),\\n                CubeStats = Table.SelectColumns(NameSelection, {\\\"Cube\\\", \\\"Indicator\\\", \\\"TimeIntervals\\\", \\\"Value\\\"}),\\n                RemoveCubesTotal = Table.SelectRows(CubeStats, each Text.From([Cube]) <> \\\"Cubes Total\\\"), // Not needed for BI reports\\n                ReplaceNullValues = Table.ReplaceValue(RemoveCubesTotal, null, 0, Replacer.ReplaceValue, {\\\"Value\\\"}), \\n                AggregateMRecords = fn_aggregateMTimeIntervalsToCurrentHour(ReplaceNullValues,  {\\\"Cube\\\", \\\"Indicator\\\", \\\"TimeIntervals\\\"}, {{\\\"Value\\\", each List.Average([Value]), type nullable number}}, \\\"TimeIntervals\\\"),\\n                DuplicateTimeIntervalsColumn = Table.DuplicateColumn(AggregateMRecords, \\\"TimeIntervals\\\", \\\"DateTime\\\"),\\n                AddDateTime = fn_transformTimeIntervalsToDateTime(DuplicateTimeIntervalsColumn, \\\"DateTime\\\"),                           \\n                LatestDateTime = List.Max(AddDateTime[DateTime]),\\n                HoursOffset = Table.AddColumn(AddDateTime, \\\"HoursOffset\\\", each Number.RoundDown(Duration.TotalHours( Duration.From([DateTime] - LatestDateTime)) ), Int64.Type),\\n                TransformColumnTypes = Table.TransformColumnTypes(HoursOffset, {{\\\"Cube\\\", type text}, {\\\"Indicator\\\", type text}, {\\\"TimeIntervals\\\", type text}, {\\\"DateTime\\\", type datetime}, {\\\"Value\\\", Int64.Type}})\\n            in\\n                TransformColumnTypes\\n    else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n    then\\n        NullTable\\n    else\\n        NullTable\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "UserStats",
      "lineageTag": "e6f0d0ac-887c-4c20-9eca-110cbe5750ec",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[User = text, Indicator = text, TimeIntervals = text, DateTime = datetime, Value = Int64.Type, HoursOffset = Int64.Type], {}),",
        "",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(#\"sREST_}StatsByClient\"[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                let ",
        "                    Dim1 = \"}PerfClients\",",
        "                    Dim2 = \"}StatsStatsByClient\",",
        "                    Dim3 = \"}TimeIntervals\",",
        "",
        "                    TabulateCubeData = fn_tabulateCubeData(#\"sREST_}StatsByClient\"[Axes], #\"sREST_}StatsByClient\"[Cells]),",
        "                    CheckCubeData = if Table.IsEmpty(TabulateCubeData) then Table.FromRows({}, {Dim1, Dim2, Dim3, \"Value\"}) else TabulateCubeData,",
        "                    RenameCubeData = Table.RenameColumns(CheckCubeData, {{Dim1, \"User\"}, {Dim2, \"Indicator\"},  {Dim3, \"TimeIntervals\"}, {\"Value\", \"Value\"}}),",
        "                    UserStats = Table.SelectColumns(RenameCubeData, {\"User\", \"Indicator\", \"TimeIntervals\", \"Value\"}),",
        "                    RemoveUsersTotal = Table.SelectRows(UserStats, each Text.From([User]) <> \"Clients Total\"), // Not needed for BI reports",
        "                    ReplaceNullValues = Table.ReplaceValue(RemoveUsersTotal, null, 0, Replacer.ReplaceValue, {\"Value\"}), ",
        "                    AggregateMRecords = fn_aggregateMTimeIntervalsToCurrentHour(ReplaceNullValues,  {\"User\", \"Indicator\", \"TimeIntervals\"}, {{\"Value\", each List.Average([Value]), type nullable number}}, \"TimeIntervals\"),",
        "                    DuplicateTimeIntervalsColumn = Table.DuplicateColumn(AggregateMRecords, \"TimeIntervals\", \"DateTime\"),",
        "                    AddDateTime = fn_transformTimeIntervalsToDateTime(DuplicateTimeIntervalsColumn, \"DateTime\"),                           ",
        "                    LatestDateTime = List.Max(AddDateTime[DateTime]),",
        "                    HoursOffset = Table.AddColumn(AddDateTime, \"HoursOffset\", each Number.RoundDown(Duration.TotalHours( Duration.From([DateTime] - LatestDateTime)) ), Int64.Type),",
        "                    TransformColumnTypes = Table.TransformColumnTypes(HoursOffset, {{\"User\", type text}, {\"Indicator\", type text}, {\"TimeIntervals\", type text}, {\"DateTime\", type datetime}, {\"Value\", Int64.Type}})",
        "                in",
        "                    TransformColumnTypes",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            NullTable",
        "        else",
        "            NullTable",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[User = text, Indicator = text, TimeIntervals = text, DateTime = datetime, Value = Int64.Type, HoursOffset = Int64.Type], {}),\\n\\n    Source = \\n        if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\" \\n        then\\n            if (try not fn_isSuccessfulHttpRequest(#\\\"sREST_}StatsByClient\\\"[#\\\"@metadata\\\"]) otherwise true) \\n            then     \\n                NullTable\\n            else\\n                let \\n                    Dim1 = \\\"}PerfClients\\\",\\n                    Dim2 = \\\"}StatsStatsByClient\\\",\\n                    Dim3 = \\\"}TimeIntervals\\\",\\n\\n                    TabulateCubeData = fn_tabulateCubeData(#\\\"sREST_}StatsByClient\\\"[Axes], #\\\"sREST_}StatsByClient\\\"[Cells]),\\n                    CheckCubeData = if Table.IsEmpty(TabulateCubeData) then Table.FromRows({}, {Dim1, Dim2, Dim3, \\\"Value\\\"}) else TabulateCubeData,\\n                    RenameCubeData = Table.RenameColumns(CheckCubeData, {{Dim1, \\\"User\\\"}, {Dim2, \\\"Indicator\\\"},  {Dim3, \\\"TimeIntervals\\\"}, {\\\"Value\\\", \\\"Value\\\"}}),\\n                    UserStats = Table.SelectColumns(RenameCubeData, {\\\"User\\\", \\\"Indicator\\\", \\\"TimeIntervals\\\", \\\"Value\\\"}),\\n                    RemoveUsersTotal = Table.SelectRows(UserStats, each Text.From([User]) <> \\\"Clients Total\\\"), // Not needed for BI reports\\n                    ReplaceNullValues = Table.ReplaceValue(RemoveUsersTotal, null, 0, Replacer.ReplaceValue, {\\\"Value\\\"}), \\n                    AggregateMRecords = fn_aggregateMTimeIntervalsToCurrentHour(ReplaceNullValues,  {\\\"User\\\", \\\"Indicator\\\", \\\"TimeIntervals\\\"}, {{\\\"Value\\\", each List.Average([Value]), type nullable number}}, \\\"TimeIntervals\\\"),\\n                    DuplicateTimeIntervalsColumn = Table.DuplicateColumn(AggregateMRecords, \\\"TimeIntervals\\\", \\\"DateTime\\\"),\\n                    AddDateTime = fn_transformTimeIntervalsToDateTime(DuplicateTimeIntervalsColumn, \\\"DateTime\\\"),                           \\n                    LatestDateTime = List.Max(AddDateTime[DateTime]),\\n                    HoursOffset = Table.AddColumn(AddDateTime, \\\"HoursOffset\\\", each Number.RoundDown(Duration.TotalHours( Duration.From([DateTime] - LatestDateTime)) ), Int64.Type),\\n                    TransformColumnTypes = Table.TransformColumnTypes(HoursOffset, {{\\\"User\\\", type text}, {\\\"Indicator\\\", type text}, {\\\"TimeIntervals\\\", type text}, {\\\"DateTime\\\", type datetime}, {\\\"Value\\\", Int64.Type}})\\n                in\\n                    TransformColumnTypes\\n        else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n        then\\n            NullTable\\n        else\\n            NullTable\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "ServerStats",
      "lineageTag": "ffc58ac3-8160-497d-bdd8-f3b57f170337",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[Indicator = text, TimeIntervals = text, DateTime = datetime, Value = Int64.Type, HoursOffset = Int64.Type], {}),",
        "",
        "     Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "        then",
        "            if (try not fn_isSuccessfulHttpRequest(#\"sREST_}StatsForServer\"[#\"@metadata\"]) otherwise true) ",
        "            then     ",
        "                NullTable",
        "            else",
        "                let",
        "                    Dim1 = \"}StatsStatsForServer\",",
        "                    Dim2 = \"}TimeIntervals\",",
        "",
        "                    TabulateCubeData = fn_tabulateCubeData(#\"sREST_}StatsForServer\"[Axes], #\"sREST_}StatsForServer\"[Cells]),",
        "                    CheckCubeData = if Table.IsEmpty(TabulateCubeData) then Table.FromRows({}, {Dim1, Dim2, \"Value\"}) else TabulateCubeData,",
        "                    RenameCubeData = Table.RenameColumns(CheckCubeData, {{Dim1, \"Indicator\"},  {Dim2, \"TimeIntervals\"}, {\"Value\", \"Value\"}}),",
        "                    ServerStats = Table.SelectColumns(RenameCubeData, {\"Indicator\", \"TimeIntervals\", \"Value\"}),",
        "                    ReplaceNullValues = Table.ReplaceValue(ServerStats, null, 0, Replacer.ReplaceValue, {\"Value\"}), ",
        "                    AggregateMRecords = fn_aggregateMTimeIntervalsToCurrentHour(ReplaceNullValues,  {\"Indicator\", \"TimeIntervals\"}, {{\"Value\", each List.Average([Value]), type nullable number}}, \"TimeIntervals\"),",
        "                    DuplicateTimeIntervalsColumn = Table.DuplicateColumn(AggregateMRecords, \"TimeIntervals\", \"DateTime\"),",
        "                    AddDateTime = fn_transformTimeIntervalsToDateTime(DuplicateTimeIntervalsColumn, \"DateTime\"),                        ",
        "                    LatestDateTime = List.Max(AddDateTime[DateTime]),",
        "                    HoursOffset = Table.AddColumn(AddDateTime, \"HoursOffset\", each Number.RoundDown(Duration.TotalHours( Duration.From([DateTime] - LatestDateTime)) ), Int64.Type),",
        "                    TransformColumnTypes = Table.TransformColumnTypes(HoursOffset, {{\"Indicator\", type text}, {\"TimeIntervals\", type text}, {\"DateTime\", type datetime}, {\"Value\", Int64.Type}, {\"HoursOffset\", Int64.Type}})",
        "                in",
        "                    TransformColumnTypes",
        "        else if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"DataFiles\" ",
        "        then",
        "            NullTable",
        "        else",
        "            NullTable",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[Indicator = text, TimeIntervals = text, DateTime = datetime, Value = Int64.Type, HoursOffset = Int64.Type], {}),\\n\\n     Source = \\n        if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\"\\n        then\\n            if (try not fn_isSuccessfulHttpRequest(#\\\"sREST_}StatsForServer\\\"[#\\\"@metadata\\\"]) otherwise true) \\n            then     \\n                NullTable\\n            else\\n                let\\n                    Dim1 = \\\"}StatsStatsForServer\\\",\\n                    Dim2 = \\\"}TimeIntervals\\\",\\n\\n                    TabulateCubeData = fn_tabulateCubeData(#\\\"sREST_}StatsForServer\\\"[Axes], #\\\"sREST_}StatsForServer\\\"[Cells]),\\n                    CheckCubeData = if Table.IsEmpty(TabulateCubeData) then Table.FromRows({}, {Dim1, Dim2, \\\"Value\\\"}) else TabulateCubeData,\\n                    RenameCubeData = Table.RenameColumns(CheckCubeData, {{Dim1, \\\"Indicator\\\"},  {Dim2, \\\"TimeIntervals\\\"}, {\\\"Value\\\", \\\"Value\\\"}}),\\n                    ServerStats = Table.SelectColumns(RenameCubeData, {\\\"Indicator\\\", \\\"TimeIntervals\\\", \\\"Value\\\"}),\\n                    ReplaceNullValues = Table.ReplaceValue(ServerStats, null, 0, Replacer.ReplaceValue, {\\\"Value\\\"}), \\n                    AggregateMRecords = fn_aggregateMTimeIntervalsToCurrentHour(ReplaceNullValues,  {\\\"Indicator\\\", \\\"TimeIntervals\\\"}, {{\\\"Value\\\", each List.Average([Value]), type nullable number}}, \\\"TimeIntervals\\\"),\\n                    DuplicateTimeIntervalsColumn = Table.DuplicateColumn(AggregateMRecords, \\\"TimeIntervals\\\", \\\"DateTime\\\"),\\n                    AddDateTime = fn_transformTimeIntervalsToDateTime(DuplicateTimeIntervalsColumn, \\\"DateTime\\\"),                        \\n                    LatestDateTime = List.Max(AddDateTime[DateTime]),\\n                    HoursOffset = Table.AddColumn(AddDateTime, \\\"HoursOffset\\\", each Number.RoundDown(Duration.TotalHours( Duration.From([DateTime] - LatestDateTime)) ), Int64.Type),\\n                    TransformColumnTypes = Table.TransformColumnTypes(HoursOffset, {{\\\"Indicator\\\", type text}, {\\\"TimeIntervals\\\", type text}, {\\\"DateTime\\\", type datetime}, {\\\"Value\\\", Int64.Type}, {\\\"HoursOffset\\\", Int64.Type}})\\n                in\\n                    TransformColumnTypes\\n        else if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"DataFiles\\\" \\n        then\\n            NullTable\\n        else\\n            NullTable\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "PerformanceStats",
      "lineageTag": "cd227d28-7127-4576-8049-b85004b6fb13",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    NullTable = #table(type table[Name = text, SKIPCHECK = logical, FEEDERS = logical, Feeders = Int64.Type, IfCount = Int64.Type, NestedIfCount = Int64.Type, DirectionalFeedersCount = Int64.Type], {}),",
        "",
        "\tSource = Source_Rules,",
        "        RenameColumns = Table.RenameColumns(Source,{{\"Name\", \"Rule\"}}),",
        "\t",
        "\tSkipCheck = Table.AddColumn(RenameColumns, \"SKIPCHECK\", each Text.Contains([TextContent], Text.Upper(KeyWords[SkipcheckRef])), type logical),",
        "\tFeeders = Table.AddColumn(SkipCheck, \"FEEDERS\", each Text.Contains([TextContent], Text.Upper(KeyWords[FeederRef])), type logical),",
        "\tIfCount = Table.AddColumn(Feeders, \"IFs\", each List.Count(Splitter.SplitTextByDelimiter(\"IF(\", QuoteStyle.Csv)([TextContent])) - 1, Int64.Type),",
        "\tNestedIfCount = Table.AddColumn(IfCount, \"Nested IFs\", each fn_nestedExpressionsCount(Text.From([TextContent]), \"IF\", {\"IF\"}), Int64.Type),",
        "\tConditionalFeedersCount = Table.AddColumn(NestedIfCount, \"Сonditional Feeders\", each  List.Count(Splitter.SplitTextByDelimiter(\"IF(\", QuoteStyle.Csv)(Text.AfterDelimiter([TextContent], Text.Upper(KeyWords[FeederRef])))) - 1, Int64.Type),",
        "\tDirectionalFeedersCount = Table.AddColumn(ConditionalFeedersCount, \"Directional Feeders\", ",
        "\t\teach fn_nestedExpressionsCount(Text.AfterDelimiter([TextContent], Text.Upper(KeyWords[FeederRef])), KeyWords[RuleCubeRef]{0}, { KeyWords[RuleCubeRef]{0}, KeyWords[RuleAttrRef]{1} }), Int64.Type),",
        "    RemoveColumns = Table.RemoveColumns(DirectionalFeedersCount, {\"TextContent\", \"MetaData\"})",
        "in",
        "    RemoveColumns"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    NullTable = #table(type table[Name = text, SKIPCHECK = logical, FEEDERS = logical, Feeders = Int64.Type, IfCount = Int64.Type, NestedIfCount = Int64.Type, DirectionalFeedersCount = Int64.Type], {}),\\n\\n\\tSource = Source_Rules,\\n        RenameColumns = Table.RenameColumns(Source,{{\\\"Name\\\", \\\"Rule\\\"}}),\\n\\t\\n\\tSkipCheck = Table.AddColumn(RenameColumns, \\\"SKIPCHECK\\\", each Text.Contains([TextContent], Text.Upper(KeyWords[SkipcheckRef])), type logical),\\n\\tFeeders = Table.AddColumn(SkipCheck, \\\"FEEDERS\\\", each Text.Contains([TextContent], Text.Upper(KeyWords[FeederRef])), type logical),\\n\\tIfCount = Table.AddColumn(Feeders, \\\"IFs\\\", each List.Count(Splitter.SplitTextByDelimiter(\\\"IF(\\\", QuoteStyle.Csv)([TextContent])) - 1, Int64.Type),\\n\\tNestedIfCount = Table.AddColumn(IfCount, \\\"Nested IFs\\\", each fn_nestedExpressionsCount(Text.From([TextContent]), \\\"IF\\\", {\\\"IF\\\"}), Int64.Type),\\n\\tConditionalFeedersCount = Table.AddColumn(NestedIfCount, \\\"Сonditional Feeders\\\", each  List.Count(Splitter.SplitTextByDelimiter(\\\"IF(\\\", QuoteStyle.Csv)(Text.AfterDelimiter([TextContent], Text.Upper(KeyWords[FeederRef])))) - 1, Int64.Type),\\n\\tDirectionalFeedersCount = Table.AddColumn(ConditionalFeedersCount, \\\"Directional Feeders\\\", \\n\\t\\teach fn_nestedExpressionsCount(Text.AfterDelimiter([TextContent], Text.Upper(KeyWords[FeederRef])), KeyWords[RuleCubeRef]{0}, { KeyWords[RuleCubeRef]{0}, KeyWords[RuleAttrRef]{1} }), Int64.Type),\\n    RemoveColumns = Table.RemoveColumns(DirectionalFeedersCount, {\\\"TextContent\\\", \\\"MetaData\\\"})\\nin\\n    RemoveColumns\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "xDel_Tree:Rules:Target<Source",
      "lineageTag": "8eb89c45-e520-4d3e-9d1f-129145ee65fb",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "\tNullTable = Table.FromRows( {}, ",
        "\t\t\t\t\t\t\t\t{",
        "\t\t\t\t\t\t\t\t\t\"HierarchyPath\"",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(0)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(1)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(2)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(3)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(4)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(5)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(6)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(7)            ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(8)                                    ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(9)                                   ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(10)                                                                 ",
        "\t\t\t\t\t\t\t\t}",
        "\t),",
        "",
        "    ExtractRulesOnly = Table.TransformColumns(Source_Rules, { \"TextContent\", ( text ) => Text.BeforeDelimiter(text, Text.Upper(KeyWords[FeederRef])) }),",
        "    RelatedObjects = Table.AddColumn(",
        "                    ExtractRulesOnly",
        "                    , \"RelatedObjects\"",
        "                    , each fn_extractFunctionEntries(Text.From([TextContent]), KeyWords[RuleCubeRef], {0, 1, 1, 1, 1, 2})",
        "    ),",
        "    // remove a circular reference to the same object",
        "    /*RemoveCircularRefs = if Table.RowCount( RelatedObjects ) > 0",
        "                            then Table.FromRecords(Table.TransformRows(RelatedObjects",
        "                                                                        , (r) => Record.TransformFields(r, {\"RelatedObjects\", each List.RemoveItems( _ , { r[Name] } ) })",
        "                                                                        )",
        "                                )",
        "                            else RelatedObjects,                                   ",
        "     */                       ",
        "    // ToDo: Move Check to The Function",
        "    //RowsWithoutErrors = Table.SelectRows(RemoveCircularRefs, each try Text.Length(Text.Combine([RelatedObjects])) >= 0 otherwise false),",
        "\t",
        "    MaxTreeDepth = fn_calcMaxTreeDepth(RelatedObjects[RelatedObjects]),",
        "    ResultTable = xDel_fn_createHierarchyPath_ByList(RelatedObjects[[Name], [RelatedObjects]], \"Name\", \"RelatedObjects\", SysName[CubeTreeNodeName], MaxTreeDepth)",
        "in",
        "    ResultTable"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Tree:Rules:Target<Source",
      "lineageTag": "27957008-12d7-40b2-82ab-630ead75862f",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "\tNullTable = Table.FromRows( {}, ",
        "\t\t\t\t\t\t\t\t{",
        "\t\t\t\t\t\t\t\t\t\"HierarchyPath\"",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(0)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(1)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(2)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(3)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(4)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(5)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(6)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(7)            ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(8)                                    ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(9)                                   ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(10)                                                                 ",
        "\t\t\t\t\t\t\t\t}",
        "\t),",
        "",
        "    ExtractRulesOnly = Table.TransformColumns(Source_Rules, { \"TextContent\", ( text ) => Text.BeforeDelimiter(text, Text.Upper(KeyWords[FeederRef])) }),",
        "    ParseTextContent = Table.AddColumn(",
        "                    ExtractRulesOnly",
        "                    , \"Definitions\"",
        "                    , each ",
        "                            let",
        "                                TextToParse = _[TextContent] ,",
        "                                Rows = Text.Split(TextToParse, \";\"),",
        "                                HasRelation = List.Select(Rows, each Text_ContainsAnyOf( _ , KeyWords[RuleCubeRef])),",
        "                                // 0 - Area definition (left), 1 - Formula (right)",
        "                                LeftRight = List.Transform(HasRelation, each if Text.Contains( _ , \"=\" ) then { Text.BeforeDelimiter( _ , \"=\", { 0, RelativePosition.FromStart }) } & { Text.AfterDelimiter( _ , \"=\", { 0, RelativePosition.FromStart }) } else null ),                           ",
        "                                RemoveNulls = List.Select(LeftRight, each _ <> null )",
        "                            in",
        "                                RemoveNulls",
        "",
        "    ),",
        " ExtractRelatedObjects = ",
        "        Table.TransformColumns(",
        "                                ParseTextContent,",
        "                                { ",
        "                                    \"Definitions\"",
        "                                    , each",
        "                                        let ",
        "                                            RelatedObjects = List.Transform( _ , ( map ) => { map{0}} & { fn_extractFunctionEntries( map{1}, KeyWords[RuleCubeRef], {0, 1, 1, 1, 1, 2} )} ),",
        "                                            MappingTables = List.Transform( RelatedObjects , ( map ) => Table.FromColumns( { map{1}, { map{0} } }, { \"RelatedObjects\", \"AreaDefinition\" }) ),",
        "                                            RemoveEmptyRelatedObjects = List.Transform( MappingTables , ( table ) => Table.SelectRows( table, each [RelatedObjects] <> null and Text.Trim([RelatedObjects]) <> \"\")),",
        "                                            AreaDefinitionFillDown = List.Transform( RemoveEmptyRelatedObjects , ( table ) => Table.FillDown( table, { \"AreaDefinition\" } )),",
        "                                            RemoveDuplicates = List.Distinct(AreaDefinitionFillDown),",
        "                                            ExpandMappingTable = Table.ExpandTableColumn(Table.FromList(RemoveDuplicates, Splitter.SplitByNothing(), {\"Definitions\"}, null, ExtraValues.Error), \"Definitions\", { \"RelatedObjects\", \"AreaDefinition\" }),",
        "                                            MappingTablesGrouping = Table.Group(ExpandMappingTable, {\"RelatedObjects\"}, {{ SysName[CubeTreeAreaDefinition], each Text.Combine( [AreaDefinition] , \"#(lf)\") }})",
        "                                        in",
        "                                            MappingTablesGrouping",
        "                                }",
        "    ),                                        ",
        "",
        "    MaxTreeDepth = fn_calcMaxTreeDepth(ExtractRelatedObjects[Definitions]),",
        "    ResultTable = fn_createHierarchyPath(ExtractRelatedObjects[[Name], [Definitions]], \"Name\", \"Definitions\", SysName[CubeTreeNodeName], MaxTreeDepth, {\"RelatedObjects\", SysName[CubeTreeAreaDefinition]})",
        "in",
        "    ResultTable"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n\\tNullTable = Table.FromRows( {}, \\n\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"HierarchyPath\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(2)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(3)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(4)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(5)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(6)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(7)            \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(8)                                    \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(9)                                   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(10)                                                                 \\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t),\\n\\n    ExtractRulesOnly = Table.TransformColumns(Source_Rules, { \\\"TextContent\\\", ( text ) => Text.BeforeDelimiter(text, Text.Upper(KeyWords[FeederRef])) }),\\n    ParseTextContent = Table.AddColumn(\\n                    ExtractRulesOnly\\n                    , \\\"Definitions\\\"\\n                    , each \\n                            let\\n                                TextToParse = _[TextContent] ,\\n                                Rows = Text.Split(TextToParse, \\\";\\\"),\\n                                HasRelation = List.Select(Rows, each Text_ContainsAnyOf( _ , KeyWords[RuleCubeRef])),\\n                                // 0 - Area definition (left), 1 - Formula (right)\\n                                LeftRight = List.Transform(HasRelation, each if Text.Contains( _ , \\\"=\\\" ) then { Text.BeforeDelimiter( _ , \\\"=\\\", { 0, RelativePosition.FromStart }) } & { Text.AfterDelimiter( _ , \\\"=\\\", { 0, RelativePosition.FromStart }) } else null ),                           \\n                                RemoveNulls = List.Select(LeftRight, each _ <> null )\\n                            in\\n                                RemoveNulls\\n\\n    ),\\n ExtractRelatedObjects = \\n        Table.TransformColumns(\\n                                ParseTextContent,\\n                                { \\n                                    \\\"Definitions\\\"\\n                                    , each\\n                                        let \\n                                            RelatedObjects = List.Transform( _ , ( map ) => { map{0}} & { fn_extractFunctionEntries( map{1}, KeyWords[RuleCubeRef], {0, 1, 1, 1, 1, 2} )} ),\\n                                            MappingTables = List.Transform( RelatedObjects , ( map ) => Table.FromColumns( { map{1}, { map{0} } }, { \\\"RelatedObjects\\\", \\\"AreaDefinition\\\" }) ),\\n                                            RemoveEmptyRelatedObjects = List.Transform( MappingTables , ( table ) => Table.SelectRows( table, each [RelatedObjects] <> null and Text.Trim([RelatedObjects]) <> \\\"\\\")),\\n                                            AreaDefinitionFillDown = List.Transform( RemoveEmptyRelatedObjects , ( table ) => Table.FillDown( table, { \\\"AreaDefinition\\\" } )),\\n                                            RemoveDuplicates = List.Distinct(AreaDefinitionFillDown),\\n                                            ExpandMappingTable = Table.ExpandTableColumn(Table.FromList(RemoveDuplicates, Splitter.SplitByNothing(), {\\\"Definitions\\\"}, null, ExtraValues.Error), \\\"Definitions\\\", { \\\"RelatedObjects\\\", \\\"AreaDefinition\\\" }),\\n                                            MappingTablesGrouping = Table.Group(ExpandMappingTable, {\\\"RelatedObjects\\\"}, {{ SysName[CubeTreeAreaDefinition], each Text.Combine( [AreaDefinition] , \\\"#(lf)\\\") }})\\n                                        in\\n                                            MappingTablesGrouping\\n                                }\\n    ),                                        \\n\\n    MaxTreeDepth = fn_calcMaxTreeDepth(ExtractRelatedObjects[Definitions]),\\n    ResultTable = fn_createHierarchyPath(ExtractRelatedObjects[[Name], [Definitions]], \\\"Name\\\", \\\"Definitions\\\", SysName[CubeTreeNodeName], MaxTreeDepth, {\\\"RelatedObjects\\\", SysName[CubeTreeAreaDefinition]})\\nin\\n    ResultTable\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Tree:Rules:Source>Target",
      "lineageTag": "287c133a-d493-4e77-9696-e4465b12e33d",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "\tNullTable = Table.FromRows( {}, ",
        "\t\t\t\t\t\t\t\t{",
        "\t\t\t\t\t\t\t\t\t\"HierarchyPath\"",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(0)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(1)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(2)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(3)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(4)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(5)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(6)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(7)            ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(8)                                    ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(9)                                   ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(10)                                                                 ",
        "\t\t\t\t\t\t\t\t}",
        "\t),",
        "    ",
        "\tTreeNodeNames = List.Select(Table.ColumnNames(#\"Tree:Rules:Target<Source\"), each Text.StartsWith( _ , SysName[CubeTreeNodeName]) and not Text.Contains( _ , \":\")),",
        "\tReversedTreeNodeNames = fn_reverseHierarchy(#\"Tree:Rules:Target<Source\", TreeNodeNames, \"HierarchyPath\"),",
        "\tTreeAreaDefinitions =  List.Select(Table.ColumnNames(ReversedTreeNodeNames), each Text.StartsWith( _ , SysName[CubeTreeNodeName]) and Text.Contains( _ , SysName[CubeTreeAreaDefinition])),",
        "\tReversedAreaDefinitions = fn_reverseHierarchy(ReversedTreeNodeNames, TreeAreaDefinitions)",
        "in",
        "    ReversedAreaDefinitions"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n\\tNullTable = Table.FromRows( {}, \\n\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"HierarchyPath\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(2)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(3)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(4)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(5)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(6)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(7)            \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(8)                                    \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(9)                                   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(10)                                                                 \\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t),\\n    \\n\\tTreeNodeNames = List.Select(Table.ColumnNames(#\\\"Tree:Rules:Target<Source\\\"), each Text.StartsWith( _ , SysName[CubeTreeNodeName]) and not Text.Contains( _ , \\\":\\\")),\\n\\tReversedTreeNodeNames = fn_reverseHierarchy(#\\\"Tree:Rules:Target<Source\\\", TreeNodeNames, \\\"HierarchyPath\\\"),\\n\\tTreeAreaDefinitions =  List.Select(Table.ColumnNames(ReversedTreeNodeNames), each Text.StartsWith( _ , SysName[CubeTreeNodeName]) and Text.Contains( _ , SysName[CubeTreeAreaDefinition])),\\n\\tReversedAreaDefinitions = fn_reverseHierarchy(ReversedTreeNodeNames, TreeAreaDefinitions)\\nin\\n    ReversedAreaDefinitions\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Tree:Rules:Details",
      "lineageTag": "e9263e07-57f7-4316-8140-299e65a1690b",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    Source = Table.FromList(List.Generate( () => 0, each _ < SettingsConfig[InterfaceMaxTreeDepth], each _ +1 ), Splitter.SplitByNothing(), { SysName[CubeTreeNodeName] }, null, ExtraValues.Ignore),",
        "    ChangeType = Table.TransformColumnTypes(Source,{{\"CubeLevel_\", Int64.Type}})",
        "in",
        "    ChangeType"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    Source = Table.FromList(List.Generate( () => 0, each _ < SettingsConfig[InterfaceMaxTreeDepth], each _ +1 ), Splitter.SplitByNothing(), { SysName[CubeTreeNodeName] }, null, ExtraValues.Ignore),\\n    ChangeType = Table.TransformColumnTypes(Source,{{\\\"CubeLevel_\\\", Int64.Type}})\\nin\\n    ChangeType\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Tree:Feeders:Source>Target",
      "lineageTag": "30b34c68-5d23-4088-bf7c-414d5f81a4c2",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "\tNullTable = Table.FromRows( {}, ",
        "\t\t\t\t\t\t\t\t{",
        "\t\t\t\t\t\t\t\t\t\"HierarchyPath\"",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(0)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(1)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(2)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(3)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(4)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(5)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(6)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(7)            ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(8)                                    ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(9)                                   ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(10)                                                                 ",
        "\t\t\t\t\t\t\t\t}",
        "\t),",
        "",
        "    ExtractFeedersOnly = Table.TransformColumns(Source_Rules, { \"TextContent\", ( text ) => Text.AfterDelimiter(text, Text.Upper(KeyWords[FeederRef])) }),",
        "    RelatedObjects = Table.AddColumn(",
        "                    ExtractFeedersOnly",
        "                    , \"RelatedObjects\"",
        "                    , each fn_extractFunctionEntries(Text.From([TextContent]), KeyWords[RuleCubeRef], {0})",
        "    ),",
        "    // remove a circular reference to the same object",
        "    RemoveCircularRefs = if Table.RowCount( RelatedObjects ) > 0",
        "                            then Table.FromRecords(Table.TransformRows(RelatedObjects",
        "                                                                        , (r) => Record.TransformFields(r, {\"RelatedObjects\", each List.RemoveItems( _ , { r[Name] } ) })",
        "                                                                        )",
        "                                )",
        "                            else RelatedObjects,                                   ",
        "                            ",
        "   // ToDo: Move Check to The Function",
        "   // RowsWithoutErrors = Table.SelectRows(RemoveCircularRefs, each try Text.Length(Text.Combine([RelatedObjects])) >= 0 otherwise false),",
        "\t",
        "    MaxTreeDepth = fn_calcMaxTreeDepth(RemoveCircularRefs[RelatedObjects]),",
        "    //ResultTable = fn_createHierarchyPath_ByList(RemoveCircularRefs[[Name], [RelatedObjects]], \"Name\", \"RelatedObjects\", SysName[CubeTreeNodeName], MaxTreeDepth)",
        "    ResultTable = fn_createHierarchyPath(RemoveCircularRefs[[Name], [RelatedObjects]], \"Name\", \"RelatedObjects\", SysName[CubeTreeNodeName], MaxTreeDepth)",
        "in",
        "    ResultTable"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Tree:Feeders:Target<Source",
      "lineageTag": "d7b453a6-1dd3-4d39-bd9e-35e7daa1f8e3",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "\tNullTable = Table.FromRows( {}, ",
        "\t\t\t\t\t\t\t\t{",
        "\t\t\t\t\t\t\t\t\t\"HierarchyPath\"",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(0)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(1)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(2)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(3)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(4)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(5)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(6)",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(7)            ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(8)                                    ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(9)                                   ",
        "\t\t\t\t\t\t\t\t\t, SysName[CubeTreeNodeName] & Text.From(10)                                                                 ",
        "\t\t\t\t\t\t\t\t}",
        "\t),",
        "    ",
        "\tTreeNodeNames = List.Select(Table.ColumnNames(#\"Tree:Feeders:Source>Target\"), each Text.StartsWith( _ , SysName[CubeTreeNodeName])),",
        "\tReversedTable = fn_reverseHierarchy(#\"Tree:Feeders:Source>Target\", TreeNodeNames, \"HierarchyPath\")",
        "in",
        "    ReversedTable"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n\\tNullTable = Table.FromRows( {}, \\n\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"HierarchyPath\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(2)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(3)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(4)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(5)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(6)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(7)            \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(8)                                    \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(9)                                   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[CubeTreeNodeName] & Text.From(10)                                                                 \\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t),\\n    \\n\\tTreeNodeNames = List.Select(Table.ColumnNames(#\\\"Tree:Feeders:Source>Target\\\"), each Text.StartsWith( _ , SysName[CubeTreeNodeName])),\\n\\tReversedTable = fn_reverseHierarchy(#\\\"Tree:Feeders:Source>Target\\\", TreeNodeNames, \\\"HierarchyPath\\\")\\nin\\n    ReversedTable\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Tree:Processes:Source>Target",
      "lineageTag": "7e36231c-3fa6-43ae-839a-ca9ad1a1a997",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "\tNullTable = Table.FromRows( {}, ",
        "\t\t\t\t\t\t\t\t{",
        "\t\t\t\t\t\t\t\t\t\"HierarchyPath\"",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(0)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(1)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(2)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(3)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(4)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(5)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(6)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(7)            ",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(8)                                    ",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(9)                                   ",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(10)                                                                 ",
        "\t\t\t\t\t\t\t\t}",
        "\t),",
        "",
        "\tExtractCodeOnly = Source_Processes,",
        "\tRelatedObjects = Table.AddColumn(",
        "                    ExtractCodeOnly",
        "                    , \"RelatedObjects\"",
        "                    , each fn_extractFunctionEntries( Text.From([TextContent]), KeyWords[ProcessProcessRef], {0}, fn_getProcessVariablesDict(Text.From([TextContent]), \"'\") )",
        "        ),",
        "\t// remove a circular reference to the same object and non-evaluated expressions",
        "\tRemoveCircularRefs = if Table.RowCount( RelatedObjects ) > 0",
        "\t\t\t\t\t\tthen Table.FromRecords(Table.TransformRows(RelatedObjects",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t, (r) => Record.TransformFields(r, {\"RelatedObjects\", each List.Select( _ , each _ <> r[Name] and not Text.Contains( _ , \"|\") ) })",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)",
        "\t\t\t\t\t\t\t)",
        "\t\t\t\t\t\telse RelatedObjects,                                   ",
        "\t\t\t\t\t\t",
        "\t// ToDo: Move Check to The Function",
        "\t//RowsWithoutErrors = Table.SelectRows(RemoveCircularRefs, each try Text.Length(Text.Combine([RelatedObjects])) >= 0 otherwise false),",
        "",
        "\tMaxTreeDepth = fn_calcMaxTreeDepth(RemoveCircularRefs[RelatedObjects]),",
        "\tResultTable = xDel_fn_createHierarchyPath_ByList(RemoveCircularRefs[[Name], [RelatedObjects]], \"Name\", \"RelatedObjects\", SysName[ProcTreeNodeName], MaxTreeDepth)",
        "in",
        "\tResultTable"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Tree:Processes:Target<Source",
      "lineageTag": "48f0a27a-67b9-4030-9bf6-18d1447367a6",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let ",
        "\tNullTable = Table.FromRows( {}, ",
        "\t\t\t\t\t\t\t\t{",
        "\t\t\t\t\t\t\t\t\t\"HierarchyPath\"",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(0)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(1)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(2)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(3)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(4)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(5)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(6)",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(7)            ",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(8)                                    ",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(9)                                   ",
        "\t\t\t\t\t\t\t\t\t, SysName[ProcTreeNodeName] & Text.From(10)                                                                 ",
        "\t\t\t\t\t\t\t\t}",
        "\t),",
        "    ",
        "\tTreeNodeNames = List.Select(Table.ColumnNames(#\"Tree:Processes:Source>Target\"), each Text.StartsWith( _ , SysName[ProcTreeNodeName])),",
        "\tReversedTable = fn_reverseHierarchy(#\"Tree:Processes:Source>Target\", TreeNodeNames, \"HierarchyPath\")",
        "in",
        "    ReversedTable"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let \\n\\tNullTable = Table.FromRows( {}, \\n\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"HierarchyPath\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[ProcTreeNodeName] & Text.From(0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[ProcTreeNodeName] & Text.From(1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[ProcTreeNodeName] & Text.From(2)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[ProcTreeNodeName] & Text.From(3)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[ProcTreeNodeName] & Text.From(4)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[ProcTreeNodeName] & Text.From(5)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[ProcTreeNodeName] & Text.From(6)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[ProcTreeNodeName] & Text.From(7)            \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[ProcTreeNodeName] & Text.From(8)                                    \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[ProcTreeNodeName] & Text.From(9)                                   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t, SysName[ProcTreeNodeName] & Text.From(10)                                                                 \\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t),\\n    \\n\\tTreeNodeNames = List.Select(Table.ColumnNames(#\\\"Tree:Processes:Source>Target\\\"), each Text.StartsWith( _ , SysName[ProcTreeNodeName])),\\n\\tReversedTable = fn_reverseHierarchy(#\\\"Tree:Processes:Source>Target\\\", TreeNodeNames, \\\"HierarchyPath\\\")\\nin\\n    ReversedTable\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "CubeProcessesRelation",
      "lineageTag": "188f27a2-bfd0-4fed-a3d9-a8de53497bfd",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let ",
        "   NullTable = #table(type table[Cube = text, Process = text], {}),",
        "",
        "   Source = Source_Processes[[Name], [TextContent], [MetaData]],",
        "   ProcessRelatedObjects = Table.AddColumn(",
        "                                            Source",
        "                                        , \"ProcessRelatedObjects\"",
        "                                        , each fn_extractFunctionEntries(Text.From([TextContent]), KeyWords[ProcessCubeRef], {1, 1, 1, 1}, fn_getProcessVariablesDict(Text.From([TextContent]), \"'\") )",
        "                        ),",
        "   // ToDo: Move Check to The Function",
        "   //RowsWithoutErrors = Table.SelectRows(ProcessRelatedObjects, each try Text.Length(Text.Combine([ProcessRelatedObjects])) >= 0 otherwise false),",
        "   ",
        "   ExpandedProcessRelatedObjects = Table.ExpandListColumn(ProcessRelatedObjects, \"ProcessRelatedObjects\"),",
        "   RemoveNonEvaluatedExpressions = Table.SelectRows(ExpandedProcessRelatedObjects, each not Text_ContainsAnyOf([ProcessRelatedObjects], {\"|\", \",\", \";\"}) and [ProcessRelatedObjects] <> null),",
        "   ResultTable = Table.RenameColumns(RemoveNonEvaluatedExpressions, {{\"ProcessRelatedObjects\", \"Cube\"}, {\"Name\", \"Process\"}})[[Cube], [Process]]",
        "in",
        "   ResultTable"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let \\n   NullTable = #table(type table[Cube = text, Process = text], {}),\\n\\n   Source = Source_Processes[[Name], [TextContent], [MetaData]],\\n   ProcessRelatedObjects = Table.AddColumn(\\n                                            Source\\n                                        , \\\"ProcessRelatedObjects\\\"\\n                                        , each fn_extractFunctionEntries(Text.From([TextContent]), KeyWords[ProcessCubeRef], {1, 1, 1, 1}, fn_getProcessVariablesDict(Text.From([TextContent]), \\\"'\\\") )\\n                        ),\\n   // ToDo: Move Check to The Function\\n   //RowsWithoutErrors = Table.SelectRows(ProcessRelatedObjects, each try Text.Length(Text.Combine([ProcessRelatedObjects])) >= 0 otherwise false),\\n   \\n   ExpandedProcessRelatedObjects = Table.ExpandListColumn(ProcessRelatedObjects, \\\"ProcessRelatedObjects\\\"),\\n   RemoveNonEvaluatedExpressions = Table.SelectRows(ExpandedProcessRelatedObjects, each not Text_ContainsAnyOf([ProcessRelatedObjects], {\\\"|\\\", \\\",\\\", \\\";\\\"}) and [ProcessRelatedObjects] <> null),\\n   ResultTable = Table.RenameColumns(RemoveNonEvaluatedExpressions, {{\\\"ProcessRelatedObjects\\\", \\\"Cube\\\"}, {\\\"Name\\\", \\\"Process\\\"}})[[Cube], [Process]]\\nin\\n   ResultTable\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "xDel_TabulateCube",
      "lineageTag": "950a5308-18e2-44b0-83e6-7c811f417859",
      "text": [
        "let",
        "",
        "/*        Axes  = #\"sREST_}StatsByCube\"[Axes], //Source_ElementAliases{1}[DataSource][Axes],",
        "        Cells = #\"sREST_}StatsByCube\"[Cells], //Source_ElementAliases{1}[DataSource][Cells],",
        "        Dim1 = \"}PerfCubes\",",
        "        Dim2 = \"}StatsStatsByCube\",",
        "        Dim3 = \"}TimeIntervals\", */",
        "        Axes  = #\"sREST_}CubeSecurity\"[Axes], ",
        "        Cells = #\"sREST_}CubeSecurity\"[Cells], ",
        "",
        "        Dim1 = \"}Cubes\",",
        "        Dim2 = \"}Groups\",",
        "        DimensionNames = {},//{ Dim1, Dim2 }",
        "",
        "",
        "",
        "",
        "        //1. Axes members",
        "        AxesNullCheck = if Axes = null then {} else Axes,",
        "        ConvertAxesToTable = Table.FromList(AxesNullCheck, Splitter.SplitByNothing(), {\"AxesRecordSet\"}, null, ExtraValues.Ignore),",
        "        ExpandAxesRecordSet = Table.ExpandRecordColumn(ConvertAxesToTable, \"AxesRecordSet\", {\"Tuples\"}),",
        "        ExpandTuplesList = Table.ExpandListColumn(ExpandAxesRecordSet, \"Tuples\"),",
        "        ExpandTuplesRecordSet = Table.ExpandRecordColumn(ExpandTuplesList, \"Tuples\", {\"Ordinal\", \"Members\"}, {\"Tuples.Ordinal\", \"Tuples.Members\"}),",
        "        GetTargetTable =  Table.TransformColumns(ExpandTuplesRecordSet, ",
        "                                        { \"Tuples.Members\", ( value ) => ",
        "                                                let",
        "                                                    CreateTableFromListOfRecords = try Table.FromRecords(value, {\"Name\", \"UniqueName\"}) otherwise Table.FromRows({}, {\"Name\", \"UniqueName\"}),",
        "                                                    GetDimensionNames = Table.TransformColumns(CreateTableFromListOfRecords, ",
        "                                                                        { \"UniqueName\", ( value ) => Text.BetweenDelimiters(value, \"[\", \"].\", {0, RelativePosition.FromStart}, {0, RelativePosition.FromStart}) }",
        "                                                    ),",
        "                                                    PivotTable = Table.Pivot(GetDimensionNames, List.Distinct(GetDimensionNames[UniqueName]), \"UniqueName\", \"Name\")",
        "                                                in",
        "                                                   PivotTable ",
        "                                        }",
        "        ),",
        "        ColumnSource = try Table.ColumnNames(GetTargetTable[Tuples.Members]{0}) otherwise {},",
        "        ColumnTarget = if (DimensionNames = null or List.IsEmpty(DimensionNames))",
        "                then ColumnSource",
        "                else DimensionNames,",
        "        ExpandTargetTable = Table.ExpandTableColumn(GetTargetTable, \"Tuples.Members\", ColumnSource, ColumnTarget),",
        "        ExpandMembersList = Table.ExpandListColumn(ExpandTuplesRecordSet, \"Tuples.Members\"),",
        "        ExpandMembersRecordSet = Table.ExpandRecordColumn(ExpandMembersList, \"Tuples.Members\", {\"Name\", \"UniqueName\"}, {\"Members.Name\", \"Members.Path\"}),",
        "        GetDimensionNames = Table.ReplaceValue(",
        "                                        ExpandMembersRecordSet",
        "                                        , each [Members.Path]",
        "                                        , each if [Members.Path] = null then null else Text.BetweenDelimiters([Members.Path], \"[\", \"]\", 0)",
        "                                        , Replacer.ReplaceValue",
        "                                        , {\"Members.Path\"}",
        "        ),",
        "        GroupMembers = Table.Group(GetDimensionNames, {\"Tuples.Ordinal\"}, { {\"Members.Name\", each List.Combine( {[Members.Name]} ) }, {\"Members.Path\", each List.Combine( {[Members.Path]} ) } }),",
        "        AddTuplesOrdinal = Table.ReplaceValue(",
        "                                        GroupMembers",
        "                                        , each [Members.Name]",
        "                                        , each if [Tuples.Ordinal] = null then [Members.Name] else List.Combine( {{[Tuples.Ordinal]}, [Members.Name]} )",
        "                                        , Replacer.ReplaceValue",
        "                                        , {\"Members.Name\"}",
        "        ), ",
        "        TableColumns = if (DimensionNames = null or List.IsEmpty(DimensionNames))",
        "                        then ",
        "                            if try ( List.IsEmpty( AddTuplesOrdinal[Members.Path]{0} ) or List.NonNullCount( AddTuplesOrdinal[Members.Path]{0} ) = 0 ) otherwise true",
        "                            then {\"Tuples.Ordinal\"}",
        "                            else {\"Tuples.Ordinal\"} & AddTuplesOrdinal[Members.Path]{0}",
        "                        else ",
        "                            {\"Tuples.Ordinal\"} & DimensionNames,",
        "        TuplesTable = Table.FromRows(AddTuplesOrdinal[Members.Name], TableColumns),",
        "",
        "",
        "        //2. Cells",
        "        CellsNullCheck = if Cells = null then {} else Cells,",
        "        ConvertCellsToTable = Table.FromList(CellsNullCheck, Splitter.SplitByNothing(), {\"CellsRecordSet\"}, null, ExtraValues.Ignore),",
        "        ExpandCellsRecordSet = Table.ExpandRecordColumn(ConvertCellsToTable, \"CellsRecordSet\", {\"Ordinal\", \"Value\"}, {\"Cells.Ordinal\", \"Cells.Value\"}),",
        "",
        "        //3. Cells next to the Members ",
        "        CellsAlongMembers = Table.NestedJoin(",
        "                                TuplesTable,",
        "                                \"Tuples.Ordinal\",   ",
        "                                ExpandCellsRecordSet,",
        "                                \"Cells.Ordinal\",",
        "                                \"Cells\",",
        "                                JoinKind.Inner",
        "        ),",
        "        ExpandCells = Table.ExpandTableColumn(CellsAlongMembers, \"Cells\", {\"Cells.Value\"}, {\"Value\"})",
        "    in",
        "        ExpandCells"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "xDel_REST_TMV",
      "lineageTag": "05a148ba-2bb1-4445-b523-199fcab2d031",
      "text": [
        "let",
        "    MDX = \"{ \"\"MDX\"\":\"\"SELECT  {[}Clients].MEMBERS} on ROWS, {[}Groups].MEMBERS} on COLUMNS FROM [}ClientGroups]  \"\"}\",",
        "    URL = \"http://localhost:50235/api/mdx?APIKey=f0tgXEdxaEV%2FSF5Ff35eTnxhF1ZEQRsbAFZVG39%2BZFFEYXMbAFZVG2Bkf3FgTn9xY3Rzam5ef3FgTn9xYE5%2FcWBBGxs%3D&pFormat=JSON&pSuppressZeros=true&pAlias=\",",
        "    Options = [",
        "                Headers = [",
        "                            #\"Authorization\" = \"Basic \" & Binary.ToText(Text.ToBinary(\"admin\" & \":\" & \"apple\"), BinaryEncoding.Base64), ",
        "                            #\"Content-Type\" = \"application/json;charset=utf-8\",",
        "                            #\"Cache-Contol\" = \"private, no-store, no-cache, must-revalidate\"",
        "                ],",
        "                Content = Text.ToBinary(MDX)",
        "    ],",
        "    Content = Options[Content],",
        "    #\"Imported CSV\" = Csv.Document(Content,[Delimiter=\",\", Columns=2, Encoding=1251, QuoteStyle=QuoteStyle.None]),",
        "    #\"Changed Type\" = Table.TransformColumnTypes(#\"Imported CSV\",{{\"Column1\", type text}, {\"Column2\", type text}})",
        "    ",
        "    //SendRequest = Web.Contents(URL, Options),",
        "in",
        "    #\"Changed Type\""
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "xDel_RESTs",
      "lineageTag": "f0b6b459-d328-476a-8935-7af442b3e559",
      "text": [
        "let",
        "    // MDX = \"{ \"\"MDX\"\":\"\"SELECT { [}Clients].MEMBERS * [}Groups].MEMBERS } ON COLUMNS FROM [}ClientGroups]  \"\"}\",",
        "   //MDX = \"{ \"\"MDX\"\":\"\"SELECT { [Номенклатура].MEMBERS * [П_Параметры_номенклатуры].MEMBERS } ON COLUMNS FROM [Параметры_номенклатуры]  \"\"}\",",
        "   //  MDX = \"{ \"\"MDX\"\":\"\"SELECT { [Products].MEMBERS } * { [P_Products].MEMBERS } ON COLUMNS FROM [Products]  \"\"}\",",
        "    MDX = null,",
        "   // URL = \"https://localhost:8881/api/v1/Dimensions?$select=Name&$expand=Hierarchies($select=Name,ElementAttributes;$expand=ElementAttributes($select=*))\",",
        "// Request = \"https://localhost:8886/api/v1/Users\",",
        "   // URL = \"https://localhost:8881/api/v1/ExecuteMDX?$expand=Axes($expand=Hierarchies/$ref,Tuples($expand=Members/$ref)),Cells\",",
        "   // URL = \"https://localhost:7005/api/v1/ExecuteMDX?ExecuteMDX?$expand=Axes($expand=Hierarchies($select=UniqueName),Tuples($expand=Members($select=Name,Attributes/Description))),Cells($select=Ordinal,Value,FormattedValue,RuleDerived,Consolidated,Updateable)\",",
        "   //URL = \"https://localhost:8881/api/v1/Dimensions?$select=Name&$expand=Hierarchies($select=Name,Elements;$expand=Elements($select=*;$expand=Edges($select=*)))\",",
        "   // URL = \"http://localhost:8881/api/v1/Dimensions?$select=Name&$expand=Hierarchies($select=Name,Elements;$expand=Elements($select=Name,Type,Level,Index,Attributes/Caption,Attributes/BusinessUnit_English,Attributes/BusinessUnit_Russian))\",",
        "   // URL = \"https://localhost:8881/api/v1/Dimensions?$select=Name&$expand=Hierarchies($select=Name,Elements;$expand=Elements($select=Name,Type,Level,Index,Attributes))\",",
        "    //URL = \"https://localhost:8881/api/v1/Dimensions?$select=Name&$expand=Hierarchies($select=Name,Elements;$expand=Elements($select=*))\",",
        "    Request = \"https://localhost:8886/api/v1/\",",
        "   // RequestTail = \"Dimensions?$select=Name&$expand=Hierarchies($select=Name,Elements;$expand=Elements($select=Name,Type,Level,Index,Attributes,Parents;$expand=Parents($select=Name,Parents;$expand=Parents($select=Name,Parents;$expand=Parents($select=Name,Parents;$expand=Parents($select=Name,Parents;$expand=Parents($select=Name,Parents;$expand=Parents($select=Name,Parents;$expand=Parents($select=Name,Parents;$expand=Parents($select=Name,Parents;$expand=Parents($select=Name,Parents;$expand=Parents($select=Name))))))))))))\",",
        "    RequestTail = \"Users\",",
        "    Options = [",
        "                Headers = [",
        "                            #\"Authorization\" = \"Basic \" & Binary.ToText(Text.ToBinary(\"admin\" & \":\" & \"apple\"), BinaryEncoding.Base64), ",
        "                            #\"Content-Type\" = \"application/json;charset=utf-8\",",
        "                            #\"Cache-Contol\" = \"private, no-store, no-cache, must-revalidate\"",
        "                ],",
        "                ManualStatusHandling = {400, 401, 403, 404}, ",
        "                RelativePath = RequestTail,",
        "                Content = Text.ToBinary(MDX)",
        "    ],",
        "    ",
        "    SendRequest = Web.Contents(Request, Options),",
        "    MetaData = Value.Metadata(SendRequest),",
        "    SendRequestBinary = Binary.Buffer(SendRequest),",
        "    #\"Imported JSON\" = Json.Document(SendRequestBinary,65001),",
        "    value = #\"Imported JSON\"[value]",
        "in",
        "    value"
      ],
      "loadAsTableDisabled": true,
      "resultType": "List",
      "isHidden": false
    },
    {
      "name": "xDel_HttpRequest",
      "lineageTag": "ba47fb73-9cb9-4b61-a5af-ca6b3926eec5",
      "text": [
        "let",
        "                // Request parameteres",
        "                RequstNo = 1, ",
        "                AttemptNo = 1, ",
        "                RequestContent = \"ModelCubes()?$select=Name,Rules\",",
        "                RawBody = null,",
        "                HttpRequestPool = 120, ",
        "                HttpRequestLatencySec = 0,",
        "                HttpRequestRecurringLatencySec = 60,",
        "                HttpRequestMaxAttempts = 3,",
        "                HttpRequestTimeoutSec = 1200,",
        "                ResponseMetaData =  #table(type table[",
        "                                                            RequstNo = number",
        "                                                            , RequestContent = text",
        "                                                            , RequestBody = text",
        "                                                            , AttemptNo = number",
        "                                                            , RequestDelay = number",
        "                                                            , RequestResponseTime = datetime",
        "                                                            , HasError = logical",
        "                                                            , ErrorReason = text",
        "                                                            , ErrorMessage = text",
        "                                                            , ErrorDetails = text",
        "                                                            , HttpResponseStatus = number",
        "                                                        ], {})",
        "            ,",
        "",
        "                AuthType = \"Basic\" ,",
        "                Auth = Binary.ToText(Text.ToBinary(\"admin\" & \":\" & \"apple\"), BinaryEncoding.Base64), ",
        "            ",
        "                NumberInPool = if (RequstNo = null) then 0 else RequstNo,  ",
        "                RequestDelay = if (AttemptNo <= 1)",
        "                                then ",
        "                                    if (Number.Mod(NumberInPool, HttpRequestPool) = 0) //Pooling",
        "                                    then HttpRequestLatencySec",
        "                                    else 0",
        "                                else (AttemptNo - 1) * HttpRequestRecurringLatencySec",
        "                ,",
        "                                    ",
        "                //Request URL, headers, options",
        "                Request = \"https://localhost:8886\" & \"/api/v1/\",",
        "                Options = [",
        "                        Headers = [",
        "                                    #\"Authorization\" = AuthType & \" \" & Auth, ",
        "                                    #\"Content-Type\" = \"application/json;charset=utf-8\",",
        "                                    #\"Cache-Control\" = \"no-cache, must-revalidate\"",
        "                        ],",
        "                        RelativePath = RequestContent,",
        "                        Content = Text.ToBinary(RawBody),",
        "                        Timeout = #duration(0, 0, 0, HttpRequestTimeoutSec),",
        "                        IsRetry = true,",
        "                        ManualStatusHandling = ",
        "                            {",
        "                                200, 201, 202,                  // Success, record the request result  ",
        "                                408, 429, 503, 504, 509,        // Handled error, repeat the request, if failure again - record the request result",
        "                                401, 403, 404                   // Handled error, record the request result  ",
        "                            }",
        "                ], ",
        "",
        "                //Send Request & BufferData",
        "                SendRequest = Function.InvokeAfter( () => try Web.Contents(Request, Options), #duration(0, 0, 0, RequestDelay) ),",
        "                BufferedData = SendRequest[[HasError]] & [Value = Binary.Buffer(SendRequest[Value])],  //avoid a risk of multple PQ calls      ",
        "",
        "                //fn_checkRequestError Start",
        "                fn_checkRequestError = (Response as any) as record =>",
        "                    if Response[HasError]?",
        "                        then [HasError = Response[HasError]?, ErrorReason = Response[Error]?[Reason]?, ErrorMessage = Response[Error]?[Message]?, ErrorDetails = Response[Error]?[Details]?]",
        "                        else ",
        "                          let",
        "                              ServerResponse = try Value.Metadata(SendRequest[Value]?)[Response.Status]?,",
        "                              ServerError = ",
        "\t\t\t\t\t    if ServerResponse[HasError]? ",
        "\t\t\t\t\t    then",
        "\t\t\t\t\t        [ HasError = ServerResponse[HasError]?, ErrorReason = ServerResponse[Error]?[Reason]?, ErrorMessage = ServerResponse[Error]?[Message]?, ErrorDetails = ServerResponse[Error]?[Details]? ]",
        "\t\t\t\t\t    else if not ServerResponse[HasError] and ServerResponse[Value] = null",
        "\t\t\t\t\t    then ",
        "\t\t\t\t\t        [ HasError = true, ErrorReason = \"Unknown\", ErrorMessage = \"Incorrect connection or authorization parameters may have been specified\", ErrorDetails = null ]",
        "\t\t\t\t\t    else",
        "\t\t\t\t\t\t[ HasError = false, ErrorReason = null, ErrorMessage = null, ErrorDetails = null ]",
        "                          in",
        "                            ServerError",
        "                ,",
        "                //fn_checkRequestError End",
        "",
        "                Error = fn_checkRequestError(BufferedData),",
        "                xDel_HttpResponse = Value.Metadata(SendRequest[Value]?), ",
        "                HttpResponseStatus = try Value.Metadata(SendRequest[Value]?)[Response.Status]? otherwise null, ",
        "                RequestResponseTime = if HttpResponseStatus <> null then DateTime.LocalNow() else null, // making sure the RequestStartTime and RequestResponseTime queries are executed in the correct order (the lazy evaluation effect)",
        "                AppendResponseMetaData = Table.InsertRows(    ResponseMetaData",
        "                                                            , Table.RowCount(ResponseMetaData)",
        "                                                            , {[  RequstNo = RequstNo",
        "                                                                , RequestContent = RequestContent",
        "                                                                , RequestBody = RawBody",
        "                                                                , AttemptNo = AttemptNo",
        "                                                                , RequestDelay = RequestDelay",
        "                                                                , RequestResponseTime = RequestResponseTime",
        "                                                                , HasError = Error[HasError]",
        "                                                                , ErrorReason = Error[ErrorReason]",
        "                                                                , ErrorMessage = Error[ErrorMessage]",
        "                                                                , ErrorDetails = Error[ErrorDetails]",
        "                                                                , HttpResponseStatus = HttpResponseStatus",
        "                                                            ]}",
        "                                                        ), ",
        "                RequestResult = if (Error[HasError]) ",
        "                then ",
        "                    Record.AddField([], \"@metadata\", AppendResponseMetaData)",
        "                else",
        "                    let                                ",
        "                        HttpRequestResult = if (List.MatchesAny({null, 408, 429, 503, 504, 509}, each _ = Value.Metadata(BufferedData)[Response.Status]?) and AttemptNo < HttpRequestMaxAttempts)",
        "                                        then",
        "                                            \"OK\"//@fn_trySendRequest(AttemptNo + 1, AppendResponseMetaData)                                                       // Repeat the request",
        "                                        else ",
        "                                            Record.AddField(try Json.Document(BufferedData[Value]) otherwise [], \"@metadata\", AppendResponseMetaData)       // Add @metadata field to the request result",
        "                    in",
        "                        HttpRequestResult",
        "",
        "        //fn_trySendReques End",
        "                ",
        "                ",
        "",
        "in",
        "    RequestResult"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Text",
      "isHidden": false
    },
    {
      "name": "xDel_createHierarchyPath_ByList",
      "lineageTag": "cd883e22-9c31-4cb7-aacb-86bec84c65cb",
      "text": [
        "let   ",
        "    ExtractRulesOnly = Table.TransformColumns(Source_Rules, { \"TextContent\", ( text ) => Text.BeforeDelimiter(text, Text.Upper(KeyWords[FeederRef])) }),",
        "    RelatedObjects = Table.AddColumn(",
        "                    ExtractRulesOnly",
        "                    , \"RelatedObjects\"",
        "                    , each xDel_fn_getRelatedObjects(Text.From([TextContent]), KeyWords[RuleCubeRef], {0, 1, 1, 1, 1, 2})",
        "    ),",
        "    // remove a circular reference to the same object",
        "    RemoveCircularRefs = if Table.RowCount( RelatedObjects ) > 0",
        "                            then Table.FromRecords(Table.TransformRows(RelatedObjects",
        "                                                                        , (r) => Record.TransformFields(r, {\"RelatedObjects\", each List.RemoveItems( _ , { r[Name] } ) })",
        "                                                                        )",
        "                                )",
        "                            else RelatedObjects,                                   ",
        "                            ",
        "    RowsWithoutErrors = Table.SelectRows(RemoveCircularRefs, each try Text.Length(Text.Combine([RelatedObjects])) >= 0 otherwise false),",
        "\t",
        "     MaxTreeDepth = fn_calcMaxTreeDepth(RowsWithoutErrors[RelatedObjects]),",
        "   ",
        "",
        "    //ResultTable = fn_createHierarchyPath(RowsWithoutErrors[[Name], [RelatedObjects]], \"Name\", \"RelatedObjects\", SysName[CubeTreeNodeName], MaxTreeDepth)",
        "",
        "    KeyField = \"Name\",",
        "    ChildrenObjectsField = \"RelatedObjects\",",
        "    TreeNodeName = SysName[CubeTreeNodeName],",
        "    HierarchyDepth = 1,",
        "",
        "    SourceTable = RowsWithoutErrors,",
        "    NodeNo = 1,",
        "",
        "",
        "      InterfaceMaxTreeDepth = SettingsConfig[InterfaceMaxTreeDepth],",
        "      RootNodeTable = Table.AddColumn(Table.RenameColumns(SourceTable, {{ KeyField, TreeNodeName & Text.From(0) }, { ChildrenObjectsField, TreeNodeName & Text.From(1) }}), \"HierarchyPath\", each Record.Field( _ , TreeNodeName & Text.From(0))),",
        "      LastNodeTable = Table.AddColumn(Table.SelectColumns(SourceTable, KeyField), ChildrenObjectsField, each \"[ ... ]\"),",
        "      NullNodeTable = Table.AddColumn(Table.SelectColumns(SourceTable, KeyField), ChildrenObjectsField, each null),   ",
        "   TableToReturn = RootNodeTable,",
        "   //---------------------------------------------------------",
        "            Splitter = \"|\",",
        "            ExpandLevel_N = Table.ExpandListColumn(TableToReturn, TreeNodeName & Text.From(NodeNo)),",
        "            RemoveCircularRefLevel_N = Table.ReplaceValue(",
        "                                          ExpandLevel_N",
        "                                          , each Text.EndsWith(Splitter & Record.Field( _ ,  \"HierarchyPath\"), Splitter & Record.Field( _ , TreeNodeName & Text.From(NodeNo))) //Record.Field( _ , TreeNodeName & Text.From(NodeNo))",
        "                                          , each null//if Text.EndsWith(Splitter & Record.Field( _ ,  \"HierarchyPath\"), Splitter & Record.Field( _ , TreeNodeName & Text.From(NodeNo)))",
        "                                                   //  then null",
        "                                                   //  else Record.Field( _ , TreeNodeName & Text.From(NodeNo))",
        "                                          , (currentValue, isCircular, replacementValue) =>",
        "                                             if isCircular then replacementValue",
        "                                             else currentValue                                                     ",
        "                                          //Replacer.ReplaceValue",
        "                                          , {TreeNodeName & Text.From(NodeNo)}",
        "                                       ),",
        "            //Update hierarchy path with new meaningful values",
        "            AppendHierarchyPath = Table.ReplaceValue(",
        "                                                         RemoveCircularRefLevel_N ",
        "                                                         , each Record.Field( _ ,  \"HierarchyPath\")",
        "                                                         , each if Record.Field( _ , TreeNodeName & Text.From(NodeNo)) = null",
        "                                                                     then Record.Field( _ ,  \"HierarchyPath\")",
        "                                                                     else Text.Combine({Record.Field( _ ,  \"HierarchyPath\"), Splitter, Record.Field( _ , TreeNodeName & Text.From(NodeNo))} )",
        "                                                         , Replacer.ReplaceValue",
        "                                                         , {\"HierarchyPath\"}                                                       ",
        "                                                      ),",
        "            ",
        "            NextNodeTable = ",
        "               if (NodeNo = InterfaceMaxTreeDepth - 2) then LastNodeTable ",
        "               else if (NodeNo = HierarchyDepth) then LastNodeTable ",
        "               else if (NodeNo <= HierarchyDepth - 1) then SourceTable ",
        "               else NullNodeTable, ",
        "   //---------------------------------------------------------",
        "                       ",
        "   AddNextNodeTable = Table.NestedJoin(",
        "                                                  AppendHierarchyPath",
        "                                                , TreeNodeName & Text.From(NodeNo)",
        "                                                , NextNodeTable",
        "                                                , KeyField",
        "                                                , \"TableColumn\"",
        "                                                , JoinKind.LeftOuter ",
        "                                             ),",
        "   ExpandNextNodeTable = Table.ExpandTableColumn(AddNextNodeTable, \"TableColumn\", { ChildrenObjectsField }, { TreeNodeName & Text.From(NodeNo + 1) })",
        "in",
        "    ExpandNextNodeTable"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "xDel_createHierarchyPath_ByMap",
      "lineageTag": "65588b96-0fde-43d9-9347-c70242a7a280",
      "text": [
        "let   ",
        "    ExtractRulesOnly = Table.TransformColumns(Source_Rules, { \"TextContent\", ( text ) => Text.BeforeDelimiter(text, Text.Upper(KeyWords[FeederRef])) }),",
        "   ",
        "    ParseTextContent = Table.AddColumn(",
        "                    ExtractRulesOnly",
        "                    , \"Definitions\"",
        "                    , each ",
        "                            let",
        "                                TextToParse = _[TextContent] ,",
        "                                Rows = Text.Split(TextToParse, \";\"),",
        "                                HasRelation = List.Select(Rows, each Text_ContainsAnyOf( _ , KeyWords[RuleCubeRef])),",
        "                                // 0 - Area definition (left), 1 - Formula (right)",
        "                                LeftRight = List.Transform(HasRelation, each if Text.Contains( _ , \"=\" ) then { Text.BeforeDelimiter( _ , \"=\", { 0, RelativePosition.FromStart }) } & { Text.AfterDelimiter( _ , \"=\", { 0, RelativePosition.FromStart }) } else null ),                           ",
        "                                RemoveNulls = List.Select(LeftRight, each _ <> null )",
        "                            in",
        "                                RemoveNulls",
        "",
        "    ),",
        "    ExtractRelatedObjects = ",
        "        Table.TransformColumns(",
        "                                ParseTextContent,",
        "                                { ",
        "                                    \"Definitions\"",
        "                                    , each",
        "                                        let ",
        "                                            RelatedObjects = List.Transform( _ , ( map ) => { map{0}} & { fn_extractFunctionEntries( map{1}, KeyWords[RuleCubeRef], {0, 1, 1, 1, 1, 2} )} ),",
        "                                            MappingTables = List.Transform( RelatedObjects , ( map ) => Table.FromColumns( { map{1}, { map{0} } }, { \"RelatedObjects\", \"Area definition\" }) ),",
        "                                            AreaDefinitionFillDown = List.Transform( MappingTables , ( table ) => Table.FillDown( table, { \"Area definition\" } )),",
        "                                            RemoveDuplicates = List.Distinct(AreaDefinitionFillDown),",
        "                                            ExpandMappingTable = Table.ExpandTableColumn(Table.FromList(RemoveDuplicates, Splitter.SplitByNothing(), {\"Definitions\"}, null, ExtraValues.Error), \"Definitions\", { \"RelatedObjects\", \"Area definition\" }),",
        "                                            MappingTablesGrouping = Table.Group(ExpandMappingTable, {\"RelatedObjects\"}, {{\"Area definition\", each Text.Combine([Area definition], \"#(cr)#(lf)\") }})",
        "                                        in",
        "                                            MappingTablesGrouping",
        "                                }",
        "    ),                             ",
        "    MaxTreeDepth = fn_calcMaxTreeDepth(ExtractRelatedObjects[Definitions]),",
        "   ",
        "   ",
        "    // 1. Definition area",
        "    SourceTable = ExtractRelatedObjects,",
        "",
        "    KeyField = \"Name\",",
        "    ChildrenObjectsField = \"Definitions\",",
        "    DefinitionMap = {\"RelatedObjects\", \"Area definition\"},",
        "    TreeNodeName = SysName[CubeTreeNodeName],",
        "    HierarchyDepth = 3,",
        "    NodeNo = 1,",
        "",
        "    InterfaceMaxTreeDepth = SettingsConfig[InterfaceMaxTreeDepth],",
        "    RootNodeTable = Table.AddColumn(Table.RenameColumns(SourceTable, {{ KeyField, TreeNodeName & Text.From(0) }, { ChildrenObjectsField, TreeNodeName & Text.From(1) }}), \"HierarchyPath\", each Record.Field( _ , TreeNodeName & Text.From(0))),",
        "    LastNodeTable = Table.AddColumn(Table.SelectColumns(SourceTable, KeyField), ChildrenObjectsField, each \"[ ... ]\"),",
        "    NullNodeTable = Table.AddColumn(Table.SelectColumns(SourceTable, KeyField), ChildrenObjectsField, each null),",
        "    Splitter = \"|\",",
        "",
        "    ",
        "    // +++ Node 01",
        "    //ExpandLevel_N_1 = Table.ExpandTableColumn(RootNodeTable, TreeNodeName & Text.From(NodeNo), DefinitionMap, { TreeNodeName & Text.From(NodeNo), TreeNodeName & Text.From(NodeNo) & \": Area definition\" }),",
        "    ExpandLevel_N_1 = Table_ExpandAnyColumn(RootNodeTable, TreeNodeName & Text.From(NodeNo), null,  { TreeNodeName & Text.From(NodeNo), TreeNodeName & Text.From(NodeNo) & \": \" & SysName[CubeTreeAreaDefinition] }),",
        "    RemoveCircularRefLevel_N_1 = Table.ReplaceValue(",
        "                                        ExpandLevel_N_1",
        "                                        , each Text.EndsWith(Splitter & Record.Field( _ ,  \"HierarchyPath\"), Splitter & Record.Field( _ , TreeNodeName & Text.From(NodeNo)))",
        "                                        , each null",
        "                                        , (currentValue, isTrue, replacementValue) => if isTrue then replacementValue else currentValue                                                     ",
        "                                        , List.Select(Table.ColumnNames(ExpandLevel_N_1), each Text.StartsWith( _ , TreeNodeName & Text.From(NodeNo) ))",
        "                                        ),",
        "    //Update hierarchy path with new meaningful values",
        "   /* AppendHierarchyPath_1 = Table.ReplaceValue(",
        "                                                    RemoveCircularRefLevel_N_1",
        "                                                    , each Record.Field( _ ,  \"HierarchyPath\")",
        "                                                    , each if Record.Field( _ , TreeNodeName & Text.From(NodeNo)) = null",
        "                                                                then Record.Field( _ ,  \"HierarchyPath\")",
        "                                                                else Text.Combine({Record.Field( _ ,  \"HierarchyPath\"), Splitter, Record.Field( _ , TreeNodeName & Text.From(NodeNo))} )",
        "                                                    , Replacer.ReplaceValue",
        "                                                    , {\"HierarchyPath\"}                                                       ",
        "                                                ),",
        "    */",
        "    AppendHierarchyPath_1 = Table.ReplaceValue(",
        "                                                RemoveCircularRefLevel_N_1 ",
        "                                                , each Record.Field( _ , TreeNodeName & Text.From(NodeNo)) = null",
        "                                                , each Record.Field( _ , TreeNodeName & Text.From(NodeNo)) ",
        "                                                , (currentValue, isTrue, replacementValue) => if isTrue then currentValue else Text.Combine({ currentValue, Splitter, replacementValue })  ",
        "                                                , {\"HierarchyPath\"}                                                       ",
        "                                            ),",
        "",
        "",
        "    NextNodeTable_1 = ",
        "               if (NodeNo = InterfaceMaxTreeDepth - 2) then LastNodeTable ",
        "               else if (NodeNo = HierarchyDepth - 1) then LastNodeTable ",
        "               else if (NodeNo < HierarchyDepth - 1) then SourceTable ",
        "               else NullNodeTable,  ",
        "",
        "   ",
        "   // +++ Add Node 02                   ",
        "    AddNextNodeTable_1 = Table.NestedJoin(",
        "                                                    AppendHierarchyPath_1",
        "                                                    , TreeNodeName & Text.From(NodeNo)",
        "                                                    , NextNodeTable_1",
        "                                                    , KeyField",
        "                                                    , \"TableColumn\"",
        "                                                    , JoinKind.LeftOuter ",
        "                                                ),",
        "    ExpandNextNodeTable_1 = Table.ExpandTableColumn(AddNextNodeTable_1, \"TableColumn\", { ChildrenObjectsField }, { TreeNodeName & Text.From(NodeNo + 1) }),",
        "",
        "",
        "// +++ Node 02",
        "    // ExpandLevel_N_2 = Table.ExpandTableColumn(ExpandNextNodeTable_1, TreeNodeName & Text.From(NodeNo + 1), DefinitionMap, { TreeNodeName & Text.From(NodeNo + 1), TreeNodeName & Text.From(NodeNo + 1) & \": Area definition\" }),",
        "    ExpandLevel_N_2 = Table_ExpandAnyColumn(ExpandNextNodeTable_1, TreeNodeName & Text.From(NodeNo + 1), null,  { TreeNodeName & Text.From(NodeNo + 1), TreeNodeName & Text.From(NodeNo + 1) & \": Area definition\" }),",
        "    RemoveCircularRefLevel_N_2 = Table.ReplaceValue(",
        "                                        ExpandLevel_N_2",
        "                                        , each Text.EndsWith(Splitter & Record.Field( _ ,  \"HierarchyPath\"), Splitter & Record.Field( _ , TreeNodeName & Text.From(NodeNo + 1))) //Record.Field( _ , TreeNodeName & Text.From(NodeNo))",
        "                                        , each null//if Text.EndsWith(Splitter & Record.Field( _ ,  \"HierarchyPath\"), Splitter & Record.Field( _ , TreeNodeName & Text.From(NodeNo)))",
        "                                                //  then null",
        "                                                //  else Record.Field( _ , TreeNodeName & Text.From(NodeNo))",
        "                                        , (currentValue, isCircular, replacementValue) =>",
        "                                            if isCircular then replacementValue",
        "                                            else currentValue                                                     ",
        "                                        //Replacer.ReplaceValue",
        "                                        , List.Select(Table.ColumnNames(ExpandLevel_N_2), each Text.StartsWith( _ , TreeNodeName & Text.From(NodeNo + 1) ))",
        "                                    ),",
        "    //Update hierarchy path with new meaningful values",
        "    AppendHierarchyPath_2 = Table.ReplaceValue(",
        "                                                    RemoveCircularRefLevel_N_2",
        "                                                    , each Record.Field( _ ,  \"HierarchyPath\")",
        "                                                    , each if Record.Field( _ , TreeNodeName & Text.From(NodeNo + 1)) = null",
        "                                                                then Record.Field( _ ,  \"HierarchyPath\")",
        "                                                                else Text.Combine({Record.Field( _ ,  \"HierarchyPath\"), Splitter, Record.Field( _ , TreeNodeName & Text.From(NodeNo + 1))} )",
        "                                                    , Replacer.ReplaceValue",
        "                                                    , {\"HierarchyPath\"}                                                       ",
        "                                                ),",
        "    ",
        "    NextNodeTable_2 = ",
        "               if (NodeNo = InterfaceMaxTreeDepth - 2) then LastNodeTable ",
        "               else if (NodeNo = HierarchyDepth - 1) then LastNodeTable ",
        "               else if (NodeNo < HierarchyDepth - 1) then SourceTable ",
        "               else NullNodeTable,  ",
        "",
        "   // +++ Add Node 03     ",
        "    AddNextNodeTable = Table.NestedJoin(",
        "                                                    AppendHierarchyPath_2",
        "                                                    , TreeNodeName & Text.From(NodeNo + 1)",
        "                                                    , NextNodeTable_2",
        "                                                    , KeyField",
        "                                                    , \"TableColumn\"",
        "                                                    , JoinKind.LeftOuter ",
        "                                                ),",
        "    ExpandNextNodeTable_2 = Table.ExpandTableColumn(AddNextNodeTable, \"TableColumn\", { ChildrenObjectsField }, { TreeNodeName & Text.From(NodeNo + 2) })",
        "in",
        "    ExpandNextNodeTable_2"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "xDel_RuleProcessText",
      "lineageTag": "6612a299-a478-49ed-ab19-2b8ea83659ce",
      "text": [
        "let",
        "    Source = ",
        "\"FORMAT==100",
        "SKIPCHECK;",
        "",
        "#Region FeedersCheck ++++++++++++++++#",
        "['Base Salary Measures':'FeederFlag'] = N: 1;['Base Salary Measures':'Underfed'] = N: If (['Base Salary Measures':'IsFed'] = 0 & ['Base Salary Measures':'Base Salary'] <> 0, 1, 0);['Base Salary Measures':'Underfed'] = C: ConsolidateChildren('Versions', 'Subsidiaries', 'Grades', 'Bands', 'Base Salary Measures');['Base Salary Measures':'Overfed'] = N: If (['Base Salary Measures':'IsFed'] > 0 & ['Base Salary Measures':'Base Salary'] = 0, 1, 0);['Base Salary Measures':'Overfed'] = C: ConsolidatedCount(2, '', !Versions, !Subsidiaries, !Grades, !Bands, !Base Salary Measures);['Base Salary Measures':'OverfedRatio'] = C: ['Base Salary Measures':'Overfed'] \\ ['Base Salary Measures':'IsFed'];['Base Salary Measures':'FeederCheck'] = C: If (['Base Salary Measures':'Underfed'] <> 0, -1 * ABS(['Base Salary Measures':'Underfed']), If (['Base Salary Measures':'Overfed'] <> 0, 1 * ['Base Salary Measures':'Overfed'], 0));",
        "#EndRegion +++++++++++++++++++++++++++#",
        "FEEDERS;",
        "#['Base Salary' ]  => DB('Salary Plan', !Versions, !Subsidiaries, !Grades, !Bands,'TOTAL EMPLOYEES' , 'Base Salary');",
        "#Region FeedersCheck ++++++++++++++++#",
        "['Base Salary Measures':'Base Salary'] => ['Base Salary Measures':'FeederFlag'], ['Base Salary Measures':'Overfed'];",
        "#EndRegion +++++++++++++++++++++++++++#",
        "\"",
        " in Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Text",
      "isHidden": false
    },
    {
      "name": "xDel_prepareCodeContent",
      "lineageTag": "8246af5d-8bc0-442d-977c-e3612b60f739",
      "text": [
        "let",
        "        RawText = xDel_RuleProcessText,",
        "        KeyWords = List.Combine({ KeyWords[RuleCubeRef], KeyWords[ProcessCubeRef], KeyWords[ProcessProcessRef], { KeyWords[SkipcheckRef] }, { KeyWords[FeederRef] } }),",
        "        Counter = List.Count(KeyWords),",
        "",
        "        // Remove commented blocks: #, line feeds: #(lf).",
        "\t\t// Commented blocks should be removed before the quote-dependent splitting since non-closed quotes may occur in commented rows",
        "        SplitTextByCarriageReturn = Splitter.SplitTextByAnyDelimiter({\"#(cr)\", \"#(lf)\"}, QuoteStyle.None)(RawText), ",
        "        RemoveCommentedRows = List.Select(SplitTextByCarriageReturn, each not Text.StartsWith( Text.Trim ( _ ) ,\"#\" )), ",
        "        TextWithoutComments = Text.Combine(RemoveCommentedRows),",
        "\t\t",
        "\t\t// Escaping single quotes ",
        "\t\t//EscapedSingleQuotes = Text.Replace(TextWithoutComments, \"'\", \"\"\"'\"),",
        "",
        "        // Remove control characters",
        "        CleanedText = Text.Clean(TextWithoutComments),",
        "        //SplitText = Splitter.SplitTextByWhitespace(QuoteStyle.Csv)(EscapedSingleQuotes), ",
        "        //CleanedText = Text.Combine(SplitText),",
        "\t\t",
        "        // Upper KeyWords ",
        "        fn_upperKeyWords = (text as text, i as number) =>",
        "            let",
        "                ReplaceTextCase = Text_ReplaceSubstring(text, KeyWords{i}, KeyWords{i}, true)",
        "            in",
        "                if i = Counter",
        "                then text",
        "                else @fn_upperKeyWords(ReplaceTextCase, i + 1)",
        "        ,  ",
        "",
        "        PreparedText = fn_upperKeyWords(CleanedText, 0)",
        "                   ",
        "    in ",
        "        PreparedText"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Text",
      "isHidden": false
    },
    {
      "name": "xDel_extractFunctionEntries",
      "lineageTag": "724c05a6-7630-43b7-8744-ae06098af857",
      "text": [
        "let    ",
        "",
        "// Function: Prepare Variables Dictionary",
        "// ++++++++++++++++++++++++++++++++++++++",
        "fn_getVariablesDict = (TextToParse as text, VariableQuote as text) as list =>  ",
        "let",
        "// Select variables: keys cannot contain special symbols, values are not functions",
        "    Rows = Text.Split(TextToParse, \";\"),",
        "    RawsKeyValue = List.Transform(Rows, each if Text.Contains( _ , \"=\" ) then Splitter.SplitTextByAnyDelimiter({ \"@=\", \"=\" })( _ ) else { null, _ } ),",
        "    // 0 - Key, 1 - Value",
        "    VariableDict = List.Select(RawsKeyValue, each _{0} <> null and not Text_ContainsAnyOf( _{0} , { \"(\", \"[\" } ) and not Text_ContainsAnyOf( _{1} , { \"(\", \"[\" } )),",
        "    ",
        "    Counter = List.Count(VariableDict),",
        "    // Private function replaces variable references with real values   ",
        "    fn_getRealVairableValue = (i as number, optional DictToSearchIn as list) as list =>",
        "        let",
        "            ReferredVariableKey = VariableDict{i}{1},",
        "            VariableNewValue = if Text.Contains( ReferredVariableKey, VariableQuote ) then ReferredVariableKey else try List.Last(List.Select(DictToSearchIn, each _{0} = ReferredVariableKey)){1} otherwise VariableQuote & VariableQuote,",
        "            TransformedVariableDict = if DictToSearchIn = null then {{ VariableDict{i}{0}, VariableNewValue }} else DictToSearchIn & {{ VariableDict{i}{0}, VariableNewValue }}",
        "        in",
        "            if i >= Counter - 1",
        "                then TransformedVariableDict",
        "                else @fn_getRealVairableValue(i + 1, TransformedVariableDict),",
        "    ",
        "    ReplaceVariableReferenceWithValue = fn_getRealVairableValue(0)",
        "in",
        "    ReplaceVariableReferenceWithValue",
        ",",
        "// ++++++++++++++++++++++++++++++++++++++",
        "",
        "// Extract Entries:",
        "// ++++++++++++++++",
        " fn_appendObjectToList_EntryNo = (EntriesList as list, KeyWord as text, EntryNo as number) as list =>  ",
        "                let",
        "                    NextFunction = Text_BetweenOuterDelimiters(Text.AfterDelimiter(TextToParse, KeyWord & \"(\", EntryNo), \"(\", \")\"),",
        "                    AppendedList = if NextFunction = \"\"",
        "                        then EntriesList",
        "                        else ",
        "                            let ",
        "                                // Escaping any inner commas for subsequent splitting",
        "                                TransformNestedOpeningParenthesis = Text.Replace(NextFunction, \"(\", \"\"\"(\"),",
        "                                TransformNestedClosingParenthesis = Text.Replace(TransformNestedOpeningParenthesis, \")\", \")\"\"\"),",
        "                                TransformSingleQuotes = Text.Replace(TransformNestedClosingParenthesis, \"'\", \"\"\"'\"),",
        "",
        "                                // Extracting parametres",
        "                                ParameterList = Splitter.SplitTextByDelimiter(\",\", QuoteStyle.Csv)(TransformSingleQuotes),",
        "                                ReplaceVariablesWithValue = ",
        "                                    if VariablesDict = null or List.IsEmpty(VariablesDict) // Only for Processes ",
        "                                    then ParameterList ",
        "                                    else List.Transform(ParameterList, ( val ) => if Text.StartsWith ( val , \"'\") then val else try List.Last(List.Select(VariablesDict, each _{0} = val)){1} otherwise \"''\")",
        "                                ,",
        "                                RemovedQuotationsParameterList = List.Transform(ReplaceVariablesWithValue, each Text.Remove( _ , {\"'\"} )),",
        "                                Object = RemovedQuotationsParameterList{ParamNos{KeyWordNo}},",
        "                                EntriesList = ",
        "                                    if Object <> null and Object <> \"\" and not List.Contains(EntriesList, Object)",
        "                                    then EntriesList & { Object }",
        "                                    else EntriesList",
        "                                ,",
        "                                Recursion = @fn_appendObjectToList_EntryNo(EntriesList, KeyWords{KeyWordNo}, EntryNo + 1)",
        "                            in ",
        "                                Recursion               ",
        "                in ",
        "                    AppendedList,",
        "",
        "EntriesListByKeyWords = {} & fn_appendObjectToList_EntryNo({}, KeyWords{KeyWordNo}, 0 ),",
        "// ++++++++++++++++",
        "",
        "",
        "",
        "    // +++ PARAMS",
        "    // +++ Test Rules",
        "    KeyWords = KeyWords[RuleCubeRef], ",
        "    ParamNos = {0, 1, 1, 1, 1, 2},",
        "",
        "    // +++ Test Processes",
        "    //KeyWords = KeyWords[ProcessProcessRef],",
        "    //ParamNos = {0},",
        "",
        "    // +++ Test Cubes-Processes",
        "    //KeyWords = KeyWords[ProcessCubeRef],",
        "    //ParamNos = {1, 1, 1, 1},",
        "",
        "    TextToParse = xDel_RuleProcessText,",
        "    ",
        "    // 1. Prepare Text for Parsing",
        "    PreparedText =  fn_prepareCodeContent(TextToParse),",
        "    ",
        "    // 2. Prepare Variables Dictionary",
        "    VariablesDict = fn_getVariablesDict(PreparedText, \"'\"),",
        "",
        "    // 3. Prepare Key Words",
        "",
        "    Counter = List.Count(KeyWords),",
        "    ",
        "    KeyWordNo = 0,",
        "    KeyWord = KeyWords{KeyWordNo},",
        "    EntryNo = 0,",
        "",
        "    // 5. Main",
        "    NextFunction = Text_BetweenOuterDelimiters(Text.AfterDelimiter(PreparedText, KeyWord & \"(\", EntryNo), \"(\", \")\"),",
        "",
        "    // Escaping any inner commas for subsequent splitting",
        "    TransformNestedOpeningParenthesis = Text.Replace(NextFunction, \"(\", \"\"\"(\"),",
        "    TransformNestedClosingParenthesis = Text.Replace(TransformNestedOpeningParenthesis, \")\", \")\"\"\"),",
        "    TransformSingleQuotes = Text.Replace(TransformNestedClosingParenthesis, \"'\", \"\"\"'\"),",
        "",
        "    // Extracting parametres",
        "    ParameterList = Splitter.SplitTextByDelimiter(\",\", QuoteStyle.Csv)(TransformSingleQuotes),",
        "    ReplaceVariablesWithValue = ",
        "        if VariablesDict = null or List.IsEmpty(VariablesDict) // Only for Processes ",
        "        then ParameterList ",
        "        else List.Transform(ParameterList, ( val ) => if Text.StartsWith ( val , \"'\") then val else try List.Last(List.Select(VariablesDict, each _{0} = val)){1} otherwise \"''\")",
        "    ,",
        "    RemovedQuotationsParameterList = List.Transform(ReplaceVariablesWithValue, each Text.Remove( _ , {\"'\"} )),",
        "    Object = RemovedQuotationsParameterList{ParamNos{KeyWordNo}},",
        "",
        "    // 6. Final  ",
        "    // DistinctList = Object",
        "    // DistinctList =  EntriesListByKeyWords",
        "    DistinctList = fn_extractFunctionEntries(PreparedText, KeyWords, ParamNos, fn_getVariablesDict(PreparedText, \"'\"))",
        "in",
        "    DistinctList"
      ],
      "loadAsTableDisabled": true,
      "resultType": "List",
      "isHidden": false
    },
    {
      "name": "xDel_Text_BetweenOuterDelimiters",
      "lineageTag": "6fd48b7a-6be8-4e7e-a6d8-093b1526b7a3",
      "text": [
        "let",
        "    //Text.BetweenDelimiters(text as nullable text, startDelimiter as text, endDelimiter as text, optional startIndex as any, optional endIndex as any) as any",
        "   ",
        "   //Main",
        "    EntryNo = 0,",
        "    //Text = \"CellPutN( Numbr ( v28 ) , pTargetCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,v23, v24, v25, v26, v27 );\",",
        "    //Text = \"CellPutN( CellPutN( CellPutN('str', pTargetCube12, b, b1, b2) , pTargetCube1, vv1, vv2, vv3) , pTargetCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,v23, v24, v25, v26, v27 );\",",
        "    //Text = \"CellPutN(CellGetS('str', pSourceCube, sv1, sv2, sv3), pTargetCube, tv1, tv2, tv3)\",",
        "    //Text = \"CellPutN( 'str'; pTargetCube, v1, v2, v3  );\",",
        "    //Text = \"CellPutN( 'str', pTargetCube, v1, v2, v3  ); CellPutN( 'str1', pTargetCube, v11, v12, v13  )\",",
        "    //Text = DEL_RuleProcess_Text,",
        "   //Text = \"['Потребность на период (ед. изм.)'] = N:DB('Материалы_потребность_по_виду',!Год,!Месяц,!Версии,!Зоны_ответственности,'Итого проекты',!Виды_материала,ATTRS('Номенклатура', !Номенклатура, 'Бренд'),'Потребность');\",",
        "   Text = \"FORMAT==100",
        "#Region System",
        "FEEDSTRINGS;",
        "SKIPCHECK;",
        "#EndRegion",
        "",
        "#DB('Бюджет_продаж_номенклатура',!Год,!Месяц,!Версии,!Зоны_ответственности,!Проекты,!Номенклатура,!П_Бюджет_продаж_номенклатура)",
        "",
        "",
        "[] = N: IF(DB('Матрица_зоны_отв_кубы',!Зоны_ответственности,'Бюджет_продаж_номенклатура','Итого кубы','Фильтр')= 1, continue, stet);",
        "[] = N: IF(attrs('Версии',!Версии, 'Тип_версии') @='Сценарий', continue, stet);",
        "[] = N: IF(!Год @= ATTRS('Год', !Год, 'Текущий'), CONTINUE, STET);",
        "[] = S: IF(!Год @= ATTRS('Год', !Год, 'Текущий'), CONTINUE, STET);",
        "",
        "['-'] = 0;",
        "",
        "[] = N: IF ( !Проекты @= DB('Параметры_номенклатуры',!Номенклатура,'Проект'), continue, stet);",
        "[] = S: IF ( !Проекты @= DB('Параметры_номенклатуры',!Номенклатура,'Проект'), continue, stet);",
        "",
        "[{'Свойства1', 'Свойства2', 'Свойства3', 'Свойства4', 'Свойства5', 'Свойства6', 'Свойства7', 'Свойства8', 'Свойства9', 'Свойства10', 'Свойства11','Свойства12', 'Свойства13'}] = S:",
        "\tDB('Параметры_номенклатуры',!Номенклатура,attrs('П_Бюджет_продаж_номенклатура', !П_Бюджет_продаж_номенклатура, 'Наименование'));",
        "",
        "#расчет сценариев",
        "#[{'План оптим', 'План пессим'}, {'Отгрузки ЭКСПЕРТ , экз.', 'Сумма отгрузки с НДС ЭКСПЕРТ , руб.', 'ИТОГО Расчет, экз'}] = N: ['План'] * (1+ DB('Параметры_год',!Год,!Версии,'Отклонение от базовой версии'));",
        "",
        "['План','Отгрузки ЭКСПЕРТ , экз.']\t= N: ['Отгрузки ЭКСПЕРТ (загр)']",
        "\t+ DB('Продукция_ЭП_движение',!Год,!Месяц,!Версии,DB('Матрица_зоны_отв_кубы',!Зоны_ответственности,'Бюджет_продаж_номенклатура','Продукция_ЭП_движение','Расчет'),!Проекты,!Номенклатура,'Продажи');",
        "",
        "['План','Сумма отгрузки с НДС ЭКСПЕРТ , руб.'] = N: ['Сумма отгрузки с НДС ЭКСПЕРТ (загр)']",
        "\t+ DB('Продукция_ЭП_продажи',!Год,!Месяц,!Версии,DB('Матрица_зоны_отв_кубы',!Зоны_ответственности,'Бюджет_продаж_номенклатура','Продукция_ЭП_движение','Расчет'),!Проекты,!Номенклатура,'Продажи с НДС, руб');",
        "",
        "#['Отгрузки Расчет, экз.'] - загружаются процессом с учетом сезонности",
        "['План','ИТОГО Расчет, экз'] = N: ['Отгрузки Расчет, экз.']",
        "\t+  DB('Продукция_ЭП_движение',!Год,!Месяц,!Версии,DB('Матрица_зоны_отв_кубы',!Зоны_ответственности,'Бюджет_продаж_номенклатура','Продукция_ЭП_движение','Расчет'),!Проекты,!Номенклатура,'Продажи, экз.');",
        "",
        "['Расчетная цена с НДС'] =   ['Сумма отгрузки с НДС ЭКСПЕРТ , руб.'] \\ ['Отгрузки ЭКСПЕРТ , экз.'];",
        "",
        "['План','Сезонность продаж, %'] = N: DB('Параметры_сезонности',!Год,!Месяц,!Версии,attrs('Номенклатура',!Номенклатура, 'Учебник/Шлейф'),'% сезонности продаж');",
        "['План','Сезонность продаж, %', 'Учебник']= C: DB('Параметры_сезонности',!Год,!Месяц,!Версии,'Учебник','% сезонности продаж');",
        "['План','Сезонность продаж, %', 'Шлейф'] = C: DB('Параметры_сезонности',!Год,!Месяц,!Версии,'Шлейф','% сезонности продаж');",
        "['План','Итого номенклатура','Сезонность продаж, %']  = C:  (['Учебник'] + ['Шлейф'])\\2;",
        "",
        "",
        "['План','Прайсовая цена Просвещения с НДС, руб.'] = C: ConsolidatedAvg (2, 'Бюджет_продаж_номенклатура',!Год,!Месяц,!Версии,!Зоны_ответственности,!Проекты,!Номенклатура,'Прайсовая цена Просвещения с НДС, руб.');",
        "['План','Прайсовая цена Просвещения с НДС, руб.'] = N: IF ( attrs('Номенклатура', !Номенклатура, 'ЭП') @= '1',",
        "\tDB('Продукция_ЭП_продажи',!Год,'Годовое значение',!Версии,'Ответственный по ЭП',!Проекты,!Номенклатура,'Цена продажи с НДС'),",
        "\tDB('Параметры_номенклатуры_месяцы',!Год,!Месяц,!Версии,!Номенклатура,'Прайс с НДС'));",
        "",
        "['План','% скидки'] = C: ConsolidatedAvg (2, 'Бюджет_продаж_номенклатура',!Год,!Месяц,!Версии,!Зоны_ответственности,!Проекты,!Номенклатура,'% скидки');",
        "['План','% скидки'] = N: DB('Параметры_номенклатуры',!Номенклатура,'% скидки');",
        "",
        "['Сумма отгрузки Расчет с НДС, руб.'] = N: ['ИТОГО Расчет, экз'] * (['Прайсовая цена Просвещения с НДС, руб.'] \t-  ['Прайсовая цена Просвещения с НДС, руб.'] * DB('Параметры_номенклатуры',!Номенклатура,'% скидки'));",
        "",
        "['Сумма отгрузки Расчет без НДС, руб.'] = N: ['Сумма отгрузки Расчет с НДС, руб.'] \\ ( 1 + DB('Параметры_номенклатуры',!Номенклатура,'НДС ставка'));",
        "",
        "['Поступления с учетом отсрочки, руб.'] = N: \tDB('Бюджет_продаж_номенклатура',!Год, str(numbr(attrs('Месяц',!Месяц, 'Номер')) - DB('Параметры_год',!Год,!Версии,'Отсрочка продажи, мес'), 2, 0)",
        "\t,!Версии,!Зоны_ответственности,!Проекты,!Номенклатура,'Сумма отгрузки Расчет с НДС, руб.');",
        "",
        "['План','янв', 'ДЗ/КЗ'] = N:  ['Сумма отгрузки Расчет с НДС, руб.'] - ['Поступления с учетом отсрочки, руб.'];",
        "['План','ДЗ/КЗ'] = N: DB('Бюджет_продаж_номенклатура',!Год,attrs('Месяц',!Месяц,'Предыдущий'),!Версии,!Зоны_ответственности,!Проекты,!Номенклатура,'ДЗ/КЗ')",
        "\t+ ['Сумма отгрузки Расчет с НДС, руб.'] - ['Поступления с учетом отсрочки, руб.'];",
        "['План','ДЗ/КЗ'] = C: IF ( ellev('Месяц',!Месяц) <> 0",
        "\t, DB('Бюджет_продаж_номенклатура',!Год,elcomp('Месяц',!Месяц,elcompn('Месяц',!Месяц)),!Версии,!Зоны_ответственности,!Проекты,!Номенклатура,'ДЗ/КЗ')",
        "\t, continue);",
        "",
        "#средневсзвешенный НДС для расчета начислений по регионам",
        "['План','НДС, %'] = N: IF ( ['Отгрузки ЭКСПЕРТ , экз.'] <> 0, DB('Параметры_номенклатуры_год',!Год,!Версии,!Номенклатура,'НДС ставка'), 0)\\100;",
        "['План','НДС, %'] = C: ConsolidatedAvg (2, 'Бюджет_продаж_номенклатура',!Год,!Месяц,!Версии,!Зоны_ответственности,!Проекты,!Номенклатура,'НДС, %');",
        "",
        "",
        "FEEDERS;",
        "#['План',{'Отгрузки ЭКСПЕРТ , экз.', 'Сумма отгрузки с НДС ЭКСПЕРТ , руб.', 'ИТОГО Расчет, экз'}] => ['План оптим'], ['План пессим'];",
        "#['План','ИТОГО Расчет, экз']  => ['План оптим','Сумма отгрузки Расчет с НДС, руб.'], ['План оптим','Сумма отгрузки Расчет без НДС, руб.'], ['План оптим','Поступления с учетом отсрочки, руб.'],",
        "#\t['План пессим','Сумма отгрузки Расчет с НДС, руб.'], ['План пессим','Сумма отгрузки Расчет без НДС, руб.'], ['План пессим','Поступления с учетом отсрочки, руб.'];",
        "",
        "['План','Отгрузки ЭКСПЕРТ (загр)']=> ['План','Отгрузки ЭКСПЕРТ , экз.'];",
        "['План','Сумма отгрузки с НДС ЭКСПЕРТ (загр)'] => ['План','Сумма отгрузки с НДС ЭКСПЕРТ , руб.'] ;",
        "['План','Отгрузки Расчет, экз.'] => ['План','ИТОГО Расчет, экз'], ['План','Сезонность продаж, %'];",
        "['План','ИТОГО Расчет, экз']  => ['План','Сумма отгрузки Расчет с НДС, руб.'], ['План','Прайсовая цена Просвещения с НДС, руб.'] , ['План','% скидки'] , ['План','Сумма отгрузки Расчет без НДС, руб.'],",
        "\t['План','Поступления с учетом отсрочки, руб.'], ['План','ДЗ/КЗ'], ['План','Расчетная цена с НДС'];",
        "['План','Отгрузки ЭКСПЕРТ , экз.'] => ['План','НДС, %'];",
        "",
        "",
        "[{'Отгрузки ЭКСПЕРТ , экз.', 'ИТОГО Расчет, экз'}] =>",
        "\tDB('Бюджет_продаж_по_сегментам',!Год,!Месяц,!Версии,!Зоны_ответственности,!Проекты,!Номенклатура,DB('Параметры_номенклатуры',!Номенклатура,'Учебник/Шлейф'),'Натуральное выражение, ед.'),",
        "\tDB('Бюджет_продаж_по_сегментам',!Год,!Месяц,!Версии,!Зоны_ответственности,!Проекты,!Номенклатура,DB('Параметры_номенклатуры',!Номенклатура,'Учебник/Шлейф'),'Стоимостное выражение, руб.'),",
        "\tDB('Бюджет_продаж_по_центрам',!Год,!Месяц,!Версии,!Зоны_ответственности,!Проекты,!Номенклатура,DB('Параметры_номенклатуры',!Номенклатура,'Учебник/Шлейф'),'Натуральное выражение, ед.'),",
        "\tDB('Бюджет_продаж_по_центрам',!Год,!Месяц,!Версии,!Зоны_ответственности,!Проекты,!Номенклатура, DB('Параметры_номенклатуры',!Номенклатура,'Учебник/Шлейф'),'Стоимостное выражение, руб.');",
        "",
        "",
        "#План печати",
        "['Отгрузки Расчет, экз.']=> DB('План_печати', !Год, !Месяц, !Версии, DB('Матрица_зоны_отв_кубы',!Зоны_ответственности,'Бюджет_продаж_номенклатура','План_печати','Фидер'), !Проекты, !Номенклатура, 'Продажи');",
        "['Отгрузки ЭКСПЕРТ (загр)' ]  => DB('План_печати', !Год, !Месяц, !Версии,DB('Матрица_зоны_отв_кубы',!Зоны_ответственности,'Бюджет_продаж_номенклатура','План_печати','Фидер'), !Проекты, !Номенклатура, 'Продажи');",
        "",
        "['Отгрузки ЭКСПЕРТ (загр)' ]  => DB('Расчет_авторские_гонорары',!Год,!Месяц,!Версии,",
        "\tDB('Матрица_зоны_отв_кубы',!Зоны_ответственности,'Бюджет_продаж_номенклатура','Расчет_авторские_гонорары','Фидер'),!Проекты,!Номенклатура,'План продаж');",
        "['Отгрузки Расчет, экз.'] => DB('Расчет_авторские_гонорары',!Год,!Месяц,!Версии,",
        "\tDB('Матрица_зоны_отв_кубы',!Зоны_ответственности,'Бюджет_продаж_номенклатура','Расчет_авторские_гонорары','Фидер'),!Проекты,!Номенклатура,'План продаж');",
        "",
        "[{'ИТОГО Расчет, экз', 'Отгрузки ЭКСПЕРТ , экз.'}] =>",
        "\tDB('Бюджет_роялти', !Год, !Месяц, !Версии,DB('Матрица_зоны_отв_кубы',!Зоны_ответственности,'Бюджет_продаж_номенклатура','Бюджет_роялти','Фидер'), !Проекты, !Номенклатура, 'План продаж');",
        "",
        "",
        "['Сумма отгрузки с НДС ЭКСПЕРТ , руб.'] => DB('Рентабельность_номекл',!Год,!Месяц,!Версии,!Зоны_ответственности,!Проекты,!Номенклатура,'Выручка от реализации','Экспертно');",
        "['Сумма отгрузки Расчет с НДС, руб.'] => DB('Рентабельность_номекл',!Год,!Месяц,!Версии,!Зоны_ответственности,!Проекты,!Номенклатура,'Выручка от реализации','Расчетно');",
        "",
        "",
        "",
        "\",",
        "",
        "",
        "   // KeyWord = \"CellPutN(\",",
        "    KeyWord = \"DB(\",",
        "    // KeyWord = \"(\",",
        "    text = Text.AfterDelimiter(Text, KeyWord, EntryNo),",
        "",
        "    //Params",
        "    StartInnerDelimiter =  \"(\",",
        "    EndInnerDelimeter = \")\",",
        "",
        "    //Function",
        "",
        "      SplitByStartInnerDelimiter = Text.Split(text, StartInnerDelimiter),",
        "      InnerDelimitersCount = List.Count(List.FirstN(SplitByStartInnerDelimiter, each not Text.Contains( _ , EndInnerDelimeter))),",
        "      OuterSubstring = Text.BeforeDelimiter(text, EndInnerDelimeter, InnerDelimitersCount) ",
        "   in",
        "      OuterSubstring"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Unknown",
      "isHidden": false
    },
    {
      "name": "List_ItemsByPositions",
      "lineageTag": "d8587da4-d8eb-49b6-bdbf-adff9383f504",
      "queryGroupId": "b78a3023-a97c-4455-9afc-61be43bd36dd",
      "text": [
        "let func = (List as list, Positions as list) as list =>",
        "   let",
        "      fn_getPos = (Output as list, i as number) => ",
        "         let",
        "            Output = Output & { List{ Positions{i} } }",
        "         in",
        "            if i < List.Count(Positions) - 1",
        "               then @fn_getPos(Output, i + 1)",
        "               else Output",
        "      ,",
        "      Positions = if List.IsEmpty(Positions) then List.Positions(List) else Positions,      ",
        "      Output = fn_getPos( {}, 0 )",
        "   in",
        "      Output,",
        "",
        "   documentation = [",
        "   Documentation.Name =  \" List_ItemsByPositions\",",
        "   Documentation.Description = \" \",",
        "   Documentation.LongDescription = \" Returns the result pulling specific items from the List \",",
        "   Documentation.Category = \" List \",",
        "   Documentation.Source = \" \",",
        "   Documentation.Version = \" 1.0 \",",
        "   Documentation.Author = \" Alexey Zaitsev \",",
        "   Documentation.Examples = {[Description =  \" \",",
        "   Code = \" List_ItemsByPositions({10, 11 ,12, 13, 14}, {0, 4}) \",",
        "   Result = \" {10, 14} \"]}",
        "   ]",
        "in  ",
        "   Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation))"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "List_Upper",
      "lineageTag": "70a40437-7460-42ef-a7ca-6eeef1c0bedc",
      "queryGroupId": "b78a3023-a97c-4455-9afc-61be43bd36dd",
      "text": [
        "let func =  (List as list) as list =>",
        "    List.Transform(List, each Text.Upper( _ ) ),",
        "",
        "    documentation = [",
        "    Documentation.Name =  \" List_Upper\",",
        "    Documentation.Description = \" \",",
        "    Documentation.LongDescription = \" Returns the result of converting all list elements to uppercase \",",
        "    Documentation.Category = \" List \",",
        "    Documentation.Source = \" \",",
        "    Documentation.Version = \" 1.0 \",",
        "    Documentation.Author = \" Alexey Zaitsev \",",
        "    Documentation.Examples = {[Description =  \" \",",
        "    Code = \" List_Upper ({\"\"CellPutS\"\", \"\"CellPutN\"\"}) \",",
        "    Result = \" {\"\"CELLPUTS\"\", \"\"CELLPUTN\"\"} \"]}",
        "    ]",
        " in  ",
        "    Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation))"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "Amount measures",
      "lineageTag": "95036771-47d6-4515-a3bb-6cc590c5d13d",
      "queryGroupId": "7fd7b0ce-fb43-439a-a1c5-472bba61fea1",
      "text": [
        "let",
        "    Source = Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText(\"i44FAA==\", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type nullable text) meta [Serialized.Text = true]) in type table [Dummy = _t]),",
        "    #\"Changed Type\" = Table.TransformColumnTypes(Source,{{\"Dummy\", type text}})",
        "in",
        "    #\"Changed Type\""
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    Source = Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText(\\\"i44FAA==\\\", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type nullable text) meta [Serialized.Text = true]) in type table [Dummy = _t]),\\n    #\\\"Changed Type\\\" = Table.TransformColumnTypes(Source,{{\\\"Dummy\\\", type text}})\\nin\\n    #\\\"Changed Type\\\"\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "System measures",
      "lineageTag": "346a8bdf-79c0-4e01-88b8-be26e83fa089",
      "queryGroupId": "7fd7b0ce-fb43-439a-a1c5-472bba61fea1",
      "text": [
        "let",
        "    Source = Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText(\"i44FAA==\", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type nullable text) meta [Serialized.Text = true]) in type table [Dummy = _t]),",
        "    #\"Changed Type\" = Table.TransformColumnTypes(Source,{{\"Dummy\", type text}})",
        "in",
        "    #\"Changed Type\""
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    Source = Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText(\\\"i44FAA==\\\", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type nullable text) meta [Serialized.Text = true]) in type table [Dummy = _t]),\\n    #\\\"Changed Type\\\" = Table.TransformColumnTypes(Source,{{\\\"Dummy\\\", type text}})\\nin\\n    #\\\"Changed Type\\\"\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "SysName",
      "lineageTag": "57d0c19f-f3ee-42f2-b6f3-560376df4148",
      "queryGroupId": "69125337-6a7a-4d67-abce-bf513c6746e2",
      "text": [
        "let",
        "    SysNames =",
        "                [",
        "                      CubeTreeNodeName = \"CubeLevel_\"",
        "                    , CubeTreeAreaDefinition = \"Area definition\" ",
        "                    , ProcTreeNodeName = \"ProcLevel_\"",
        "                    , DimTransactionLogName = \"Dim_\"",
        "                    , DimHierarchyNodeName = \"Element_\"",
        "                    , SingleHttpRequestName = \"sREST_\"",
        "                    , MultipleHttpRequestName = \"mREST_\"",
        "                ]",
        "in",
        "    SysNames"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "SysMessageLog",
      "lineageTag": "2fe35bcc-a952-4388-a564-29de2b286cf6",
      "queryGroupId": "69125337-6a7a-4d67-abce-bf513c6746e2",
      "text": [
        "let",
        "    Source = [",
        "\t\t\t\t  ProcessFeedersMsg = \"Done computing feeders for base cube\"",
        "\t\t\t \t, ElapsedTimeMsg = \"TM1 Server is ready, elapsed time\"",
        "\t\t\t]",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Unknown",
      "isHidden": false
    },
    {
      "name": "SysHttpRequests",
      "lineageTag": "1575c016-f711-4317-9ede-aecc2b192c3c",
      "queryGroupId": "69125337-6a7a-4d67-abce-bf513c6746e2",
      "text": [
        "let",
        "    Source = {",
        "\t\t\t\t\"sREST_Rules\"",
        "\t\t\t\t, \"sREST_Processes\"",
        "\t\t\t\t, \"sREST_Configuration\"",
        "\t\t\t\t, \"sREST_Server\"",
        "\t\t\t\t, \"sREST_CubeDimensions\"",
        "\t\t\t\t, \"sREST_DimensionAttributes\"",
        "\t\t\t\t, \"sREST_DimensionElements\"",
        "\t\t\t\t, \"sREST_Users\"",
        "\t\t\t\t, \"sREST_}ClientGroups\"",
        "\t\t\t\t, \"sREST_}CubeSecurity\"",
        "\t\t\t\t, \"sREST_}ElementAttributes_}Groups\"",
        "\t\t\t\t, \"sREST_}StatsByCube\"",
        "\t\t\t\t, \"sREST_}StatsByClient\"",
        "\t\t\t\t, \"sREST_}StatsForServer\"",
        "\t\t\t\t, \"sREST_MessageLog\"",
        "\t\t\t\t, \"sREST_TransactionLog\"",
        "\t\t\t}",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "List",
      "isHidden": false
    },
    {
      "name": "SysHttpRequestData",
      "lineageTag": "23b68ff0-6348-4728-b80a-1684d9feb94a",
      "queryGroupId": "69125337-6a7a-4d67-abce-bf513c6746e2",
      "text": [
        "let",
        "    Source = #table(type table[Name = text, Group = text, Data = any],",
        "        {",
        "            { \"sREST_Rules\", \t\t\t            \"Basic\",  \t#\"sREST_Rules\"\t\t\t\t\t\t},",
        "            { \"sREST_Processes\", \t\t\t        \"Basic\",    #\"sREST_Processes\"\t\t\t\t\t},",
        "            { \"sREST_Configuration\",\t\t        \"Basic\",    #\"sREST_Configuration\"\t\t\t\t},",
        "            { \"sREST_Server\",\t\t                \"Basic\",\t#\"sREST_Server\"\t\t\t\t\t\t},",
        "            { \"sREST_CubeDimensions\",\t\t        \"Basic\",\t#\"sREST_CubeDimensions\"\t\t\t\t},",
        "            { \"sREST_DimensionAttributes\",\t\t    \"Basic\",    #\"sREST_DimensionAttributes\"\t\t},",
        "            { \"sREST_DimensionElements\",\t\t    \"Basic\",    #\"sREST_DimensionElements\"\t\t\t},",
        "            { \"sREST_Users\",\t\t\t            \"Basic\",    #\"sREST_Users\"\t\t\t\t\t\t},",
        "            { \"sREST_}ClientGroups\",\t\t        \"Basic\",\t#\"sREST_}ClientGroups\"\t\t\t\t},",
        "            { \"sREST_}CubeSecurity\",\t\t        \"Basic\",\t#\"sREST_}CubeSecurity\"\t\t\t\t},",
        "            { \"sREST_}ElementAttributes_}Groups\",\t\"Basic\",    #\"sREST_}ElementAttributes_}Groups\"\t},",
        "            { \"sREST_}StatsByCube\",\t\t\t        \"Stats\",\t#\"sREST_}StatsByCube\"\t\t\t\t},",
        "            { \"sREST_}StatsByClient\",\t\t        \"Stats0\",\t#\"sREST_}StatsByClient\"\t\t\t\t},",
        "            { \"sREST_}StatsForServer\",\t\t        \"Stats\",\t#\"sREST_}StatsForServer\"\t\t\t},",
        "            { \"sREST_TransactionLog\",\t\t        \"TransLog\",\t#\"sREST_TransactionLog\"\t\t\t\t}",
        "        }",
        "    )",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "SysHttpRequestLog",
      "lineageTag": "721c5cd0-181d-42fa-89f1-f6c078e9e0f2",
      "queryGroupId": "69125337-6a7a-4d67-abce-bf513c6746e2",
      "text": [
        "let",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "        then",
        "            let",
        "                FilterSingleHttpRequests = Table.SelectRows(SysHttpRequestData, each Text.StartsWith([Name], SysName[SingleHttpRequestName])),",
        "",
        "                FilterMultipleHttpRequests = Table.SelectRows(SysHttpRequestData, each Text.StartsWith([Name], SysName[MultipleHttpRequestName])),",
        "                ExpandMultipleResponseList = Table.ExpandListColumn(FilterMultipleHttpRequests, \"Data\"),",
        "",
        "                AllHttpRequests = Table.Combine({ FilterSingleHttpRequests, ExpandMultipleResponseList }),",
        "",
        "                CheckEmptiness = Table.AddColumn(AllHttpRequests, \"IsEmpty\", each ",
        "                                                                                        (try [Data][ProductVersion] = null otherwise true) ",
        "                                                                                    and (try List.IsEmpty([Data][value]) otherwise true) ",
        "                                                                                    and (try List.IsEmpty([Data][Cells]) otherwise true), ",
        "                                                                                    type logical",
        "                                                ),",
        "                ExpendResponseRecord = Table.ExpandRecordColumn(CheckEmptiness, \"Data\", {\"@metadata\", \"error\"}),",
        "                ExpandMetadataTable = Table.ExpandTableColumn(ExpendResponseRecord, \"@metadata\", {",
        "                                                                                                    \"RequstNo\"",
        "                                                                                                    , \"RequestContent\"",
        "                                                                                                    , \"RequestBody\"",
        "                                                                                                    , \"AttemptNo\"",
        "                                                                                                    , \"RequestStartTime\"",
        "                                                                                                    , \"RequestResponseTime\"",
        "                                                                                                    , \"RequestDelay\"",
        "                                                                                                    , \"HasError\"",
        "                                                                                                    , \"ErrorReason\"",
        "                                                                                                    , \"ErrorMessage\"",
        "                                                                                                    , \"ErrorDetails\"",
        "                                                                                                    , \"HttpResponseStatus\"",
        "                                                                                                }",
        "                                                            ),",
        "                ExpendErrorRecord = Table.ExpandRecordColumn(ExpandMetadataTable, \"error\", {\"code\", \"message\"}, {\"ServerErrorCode\", \"ServerErrorMessage\"}),",
        "                TransformColumnTypes = Table.TransformColumnTypes(ExpendErrorRecord, {",
        "                                                                                        {\"RequstNo\", Int64.Type}",
        "                                                                                        , {\"AttemptNo\", Int64.Type}",
        "                                                                                        , {\"RequestStartTime\", type datetime}",
        "                                                                                        , {\"RequestResponseTime\", type datetime}",
        "                                                                                        , {\"RequestDelay\", type number}",
        "                                                                                        , {\"HasError\", type logical}",
        "                                                                                        , {\"HttpResponseStatus\", Int64.Type}\t",
        "                })",
        "            in",
        "                TransformColumnTypes",
        "        else null",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    Source = \\n        if (try ConnectionConfig[ConnectionType] otherwise \\\"REST\\\") = \\\"REST\\\"\\n        then\\n            let\\n                FilterSingleHttpRequests = Table.SelectRows(SysHttpRequestData, each Text.StartsWith([Name], SysName[SingleHttpRequestName])),\\n\\n                FilterMultipleHttpRequests = Table.SelectRows(SysHttpRequestData, each Text.StartsWith([Name], SysName[MultipleHttpRequestName])),\\n                ExpandMultipleResponseList = Table.ExpandListColumn(FilterMultipleHttpRequests, \\\"Data\\\"),\\n\\n                AllHttpRequests = Table.Combine({ FilterSingleHttpRequests, ExpandMultipleResponseList }),\\n\\n                CheckEmptiness = Table.AddColumn(AllHttpRequests, \\\"IsEmpty\\\", each \\n                                                                                        (try [Data][ProductVersion] = null otherwise true) \\n                                                                                    and (try List.IsEmpty([Data][value]) otherwise true) \\n                                                                                    and (try List.IsEmpty([Data][Cells]) otherwise true), \\n                                                                                    type logical\\n                                                ),\\n                ExpendResponseRecord = Table.ExpandRecordColumn(CheckEmptiness, \\\"Data\\\", {\\\"@metadata\\\", \\\"error\\\"}),\\n                ExpandMetadataTable = Table.ExpandTableColumn(ExpendResponseRecord, \\\"@metadata\\\", {\\n                                                                                                    \\\"RequstNo\\\"\\n                                                                                                    , \\\"RequestContent\\\"\\n                                                                                                    , \\\"RequestBody\\\"\\n                                                                                                    , \\\"AttemptNo\\\"\\n                                                                                                    , \\\"RequestStartTime\\\"\\n                                                                                                    , \\\"RequestResponseTime\\\"\\n                                                                                                    , \\\"RequestDelay\\\"\\n                                                                                                    , \\\"HasError\\\"\\n                                                                                                    , \\\"ErrorReason\\\"\\n                                                                                                    , \\\"ErrorMessage\\\"\\n                                                                                                    , \\\"ErrorDetails\\\"\\n                                                                                                    , \\\"HttpResponseStatus\\\"\\n                                                                                                }\\n                                                            ),\\n                ExpendErrorRecord = Table.ExpandRecordColumn(ExpandMetadataTable, \\\"error\\\", {\\\"code\\\", \\\"message\\\"}, {\\\"ServerErrorCode\\\", \\\"ServerErrorMessage\\\"}),\\n                TransformColumnTypes = Table.TransformColumnTypes(ExpendErrorRecord, {\\n                                                                                        {\\\"RequstNo\\\", Int64.Type}\\n                                                                                        , {\\\"AttemptNo\\\", Int64.Type}\\n                                                                                        , {\\\"RequestStartTime\\\", type datetime}\\n                                                                                        , {\\\"RequestResponseTime\\\", type datetime}\\n                                                                                        , {\\\"RequestDelay\\\", type number}\\n                                                                                        , {\\\"HasError\\\", type logical}\\n                                                                                        , {\\\"HttpResponseStatus\\\", Int64.Type}\\t\\n                })\\n            in\\n                TransformColumnTypes\\n        else null\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "SysLastRefresh",
      "lineageTag": "070575d7-5752-496f-98dc-b137c1f1e846",
      "queryGroupId": "69125337-6a7a-4d67-abce-bf513c6746e2",
      "text": [
        "let",
        "    Source = #table(type table[LastRefreshDate = datetime], {{ DateTime.FixedLocalNow() }})",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    Source = #table(type table[LastRefreshDate = datetime], {{ DateTime.FixedLocalNow() }})\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "SysConfigStatus",
      "lineageTag": "bd72c3d2-dad5-49d2-889d-bd6f7141fc5e",
      "queryGroupId": "69125337-6a7a-4d67-abce-bf513c6746e2",
      "text": [
        "let",
        "    Source = Table.Combine(",
        "        {",
        "\t\t\tTable.Unpivot(",
        "\t\t\t\t\tTable.FromRecords({ Record.SelectFields(ConnectionConfig, { \"ConnectionType\", \"Host:Port\", \"Login\", \"Namespace\" }) })",
        "\t\t\t\t\t, { \"ConnectionType\", \"Host:Port\", \"Login\", \"Namespace\" }",
        "\t\t\t\t\t, \"Name\"",
        "\t\t\t\t\t, \"Value\"",
        "\t\t\t)",
        "\t\t\t, Table.FromRecords(",
        "\t\t\t\t\t{   ",
        "\t\t\t\t\t\t[ Name = \"SSL connection\"",
        "\t\t\t\t\t\t, Value = Text.Contains(Text.Lower(ConnectionConfig[#\"Host:Port\"]), \"https\") ]",
        "\t\t\t\t\t}",
        "            )",
        "            , Table.FromRecords(",
        "                    {   ",
        "                        [ Name = \"TransactionLog\"",
        "                        , Value = SettingsConfig[TransactionLogPeriodInDays] >= 0 ]",
        "                    }",
        "            )",
        "        }",
        "    )",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    Source = Table.Combine(\\n        {\\n\\t\\t\\tTable.Unpivot(\\n\\t\\t\\t\\t\\tTable.FromRecords({ Record.SelectFields(ConnectionConfig, { \\\"ConnectionType\\\", \\\"Host:Port\\\", \\\"Login\\\", \\\"Namespace\\\" }) })\\n\\t\\t\\t\\t\\t, { \\\"ConnectionType\\\", \\\"Host:Port\\\", \\\"Login\\\", \\\"Namespace\\\" }\\n\\t\\t\\t\\t\\t, \\\"Name\\\"\\n\\t\\t\\t\\t\\t, \\\"Value\\\"\\n\\t\\t\\t)\\n\\t\\t\\t, Table.FromRecords(\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\t[ Name = \\\"SSL connection\\\"\\n\\t\\t\\t\\t\\t\\t, Value = Text.Contains(Text.Lower(ConnectionConfig[#\\\"Host:Port\\\"]), \\\"https\\\") ]\\n\\t\\t\\t\\t\\t}\\n            )\\n            , Table.FromRecords(\\n                    {   \\n                        [ Name = \\\"TransactionLog\\\"\\n                        , Value = SettingsConfig[TransactionLogPeriodInDays] >= 0 ]\\n                    }\\n            )\\n        }\\n    )\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Text_ReplaceSubstring",
      "lineageTag": "3c1c5268-7344-4ba1-8f84-aae8480f2d95",
      "queryGroupId": "b78a3023-a97c-4455-9afc-61be43bd36dd",
      "text": [
        "let func = (text as nullable text, oldText as text, newText as text, optional ignoreCase as logical) as text =>",
        "    let",
        "        UppercaseText = Text.Upper(text),",
        "        UppercaseOldText = Text.Upper(oldText),",
        "        OldTextStartPos = Text.PositionOf(UppercaseText, UppercaseOldText, Occurrence.All),",
        "        ReplacedRange = if ignoreCase = null or ignoreCase = false then ",
        "                            Text.Replace(text, oldText, newText)    ",
        "                        else if List.IsEmpty(OldTextStartPos ) then text",
        "                        else ",
        "                        Text.ReplaceAll(text, OldTextStartPos),",
        "            ",
        "        Text.ReplaceAll = (text as text, positionList as list) as text =>",
        "            let",
        "                firstPos = List.First(positionList),",
        "                restPos = List.Skip(positionList, 1),",
        "                currentText = Text.ReplaceRange(text, firstPos, Text.Length(oldText), newText),",
        "                final = if List.IsEmpty(restPos) then currentText",
        "                        else @Text.ReplaceAll(currentText, restPos)",
        "            in",
        "                final",
        "    in",
        "        ReplacedRange,",
        "",
        "    documentation = [",
        "    Documentation.Name =  \" Text_ReplaceSubstring \",",
        "    Documentation.Description = \" \",",
        "    Documentation.LongDescription = \" Returns the result of replacing all occurrences of text value old in text value text with text value new. Case sensivity depends on the \"\"ignoreCase\"\" flag value \",",
        "    Documentation.Category = \" Text \",",
        "    Documentation.Source = \" \",",
        "    Documentation.Version = \" 1.0 \",",
        "    Documentation.Author = \" Internet \",",
        "    Documentation.Examples = {[Description =  \" TBD \",",
        "    Code = \" Text_ReplaceSubstring (\"\"CellPutS CellPutN\"\", \"\"cellputs\"\", \"\"CELLPUTS\"\", true) \",",
        "    Result = \" \"\"CELLPUTS CellPutN\"\" \"]}",
        "    ]",
        " in  ",
        "    Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation))"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "Text_ContainsAnyOf",
      "lineageTag": "7b079654-b2b1-4faa-89d1-427977067d47",
      "queryGroupId": "b78a3023-a97c-4455-9afc-61be43bd36dd",
      "text": [
        "let func = (text as nullable text, ListOfSubstrings as list) as logical =>",
        "        List.Count(Splitter.SplitTextByAnyDelimiter(ListOfSubstrings)(text)) > 1,",
        "",
        "    documentation = [",
        "    Documentation.Name =  \" Text_ContainsAnyOf \",",
        "    Documentation.Description = \" \",",
        "    Documentation.LongDescription = \" Detects whether text contains any value in ListOfSubstrings \",",
        "    Documentation.Category = \" Text \",",
        "    Documentation.Source = \" \",",
        "    Documentation.Version = \" 1.0 \",",
        "    Documentation.Author = \" Alexet Zaitsev \",",
        "    Documentation.Examples = {[Description =  \" TBD \",",
        "    Code = \" Text_ContainsAnyOf(\"\"#TODO\"\", {\"\"#\"\", \"\"//\"\", \"\"--\"\"}) \",",
        "    Result = \" \"\"true\"\" \"]}",
        "    ]",
        " in  ",
        "    Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation))"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Unknown",
      "isHidden": false
    },
    {
      "name": "Text_BetweenOuterDelimiters",
      "lineageTag": "bc578fcf-625c-4748-b26e-d0461287f815",
      "queryGroupId": "b78a3023-a97c-4455-9afc-61be43bd36dd",
      "text": [
        "let func = (text as text, StartInnerDelimiter as text, EndInnerDelimeter as text) as any =>",
        "   let",
        "      SplitByStartInnerDelimiter = Text.Split(text, StartInnerDelimiter),",
        "      InnerDelimitersCount = List.Count(List.FirstN(SplitByStartInnerDelimiter, each not Text.Contains( _ , EndInnerDelimeter))),",
        "      OuterSubstring = Text.BeforeDelimiter(text, EndInnerDelimeter, InnerDelimitersCount) ",
        "   in",
        "      OuterSubstring,",
        "",
        "   documentation = [",
        "   Documentation.Name =  \" Text_BetweenOuterDelimiters \",",
        "   Documentation.Description = \" \",",
        "   Documentation.LongDescription = \" Returns the portion of text outside the nested delimiters \",",
        "   Documentation.Category = \" Text \",",
        "   Documentation.Source = \" \",",
        "   Documentation.Version = \" 1.0 \",",
        "   Documentation.Author = \" Alexet Zaitsev \",",
        "   Documentation.Examples = {[Description =  \" TBD \",",
        "   Code = \" Text_BetweenOuterDelimiters(\"\"CellGetS('str', pSourceCube, sv1, sv2, sv3), pTargetCube, tv1, tv2, tv3);\"\", \"\"(\"\", \"\")\"\" )\",",
        "   Result = \" CellGetS('str', pSourceCube, sv1, sv2, sv3), pTargetCube, tv1, tv2, tv3 \"]}",
        "   ]",
        " in  ",
        "   Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation))"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Unknown",
      "isHidden": false
    },
    {
      "name": "LoadXMLConnectionConfig",
      "lineageTag": "a6fdf1bd-b3a7-44ea-a151-875271e476bc",
      "queryGroupId": "97bbd2e1-8640-4dba-907f-449ec6205900",
      "text": [
        "let",
        "    NullTable = #table(type table[Login = text, Password = text, Namespace = text], {{ \"\", \"\", \"\" }}),",
        "",
        "    Source = if (#\"01 MODE\" = \"Desktop\") then try Xml.Tables( File.Contents(#\"03 CONFIG PATH\"), null, 65001 ) otherwise null else null,",
        " ",
        "    ConnectionTable = try Source{[Name = \"auth\"]}[Table] otherwise NullTable,",
        "    ReplaceEmptyValues = Table_TransformAllColumns(ConnectionTable, ( value ) => if Value.Is(value, type table) then \"\" else value, type text),               ",
        "    SetTypes = Table.TransformColumnTypes(ReplaceEmptyValues,",
        "        {",
        "              {\"Login\", type text}",
        "            , {\"Password\", type text}",
        "            , {\"Namespace\", type text}",
        "        }",
        "    ),",
        "                                              ",
        "   // ParamsSetup = Table.Unpivot(Table.FromRecords({ SetTypes{0} }), Table.ColumnNames(SetTypes), \"Name\", \"Value\")",
        "    ParamsSetup = try SetTypes{0} otherwise Record.FromTable(NullTable)",
        "in",
        "    ParamsSetup"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "LoadXMLSettingsConfig",
      "lineageTag": "3cedbde1-e791-4f55-bc56-e735de463e95",
      "queryGroupId": "97bbd2e1-8640-4dba-907f-449ec6205900",
      "text": [
        "let",
        "    Source = if (#\"01 MODE\" = \"Desktop\") then try Xml.Tables( File.Contents(#\"03 CONFIG PATH\"), null, 65001 ) otherwise null else null,",
        "",
        "    SettingsTable = try Source{[Name = \"settings\"]}[Table] otherwise null,",
        "",
        "    ReportTable = try SettingsTable{[Name = \"report\"]}[Table] otherwise SettingsConfigDefault,",
        "    AliasList = List.Select(",
        "\t\t\t\t\tList.Distinct(",
        "\t\t\t\t\t\tList.RemoveNulls(try Table.ToList( ReportTable{[Name = \"Alias\"]}[Table]) ",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\totherwise try Text.Split(ReportTable[alias]{0}, \"\") ",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\totherwise SettingsConfigDefault[AliasList]",
        "\t\t\t\t\t\t)",
        "\t\t\t\t\t)",
        "\t\t\t\t, each _ <> \"\"),",
        "    ",
        "    LogsTable = try SettingsTable{[Name = \"logs\"]}[Table] otherwise null,",
        "    TransactionLogPeriodInDays = try Number.FromText(LogsTable[TransactionLogPeriodInDays]{0}) otherwise SettingsConfigDefault[TransactionLogPeriodInDays],",
        "    ConvertGMTLogTimeStampsToLocalTimeZone = try Logical.FromText(LogsTable[ConvertGMTLogTimeStampsToLocalTimeZone]{0}) otherwise SettingsConfigDefault[ConvertGMTLogTimeStampsToLocalTimeZone],",
        "",
        "    SystemTable = try SettingsTable{[Name = \"system\"]}[Table] otherwise null,",
        "    HttpRequestPool = try Number.FromText(SystemTable[HttpRequestPool]{0}) otherwise SettingsConfigDefault[HttpRequestPool],",
        "    HttpRequestLatencySec = try Number.FromText(SystemTable[HttpRequestLatencySec]{0}) otherwise SettingsConfigDefault[HttpRequestLatencySec],",
        "    HttpRequestRecurringLatencySec = try Number.FromText(SystemTable[HttpRequestRecurringLatencySec]{0}) otherwise SettingsConfigDefault[HttpRequestRecurringLatencySec],",
        "    HttpRequestMaxAttempts = try Number.FromText(SystemTable[HttpRequestMaxAttempts]{0}) otherwise SettingsConfigDefault[HttpRequestMaxAttempts],",
        "    HttpRequestTimeoutSec = try Number.FromText(SystemTable[HttpRequestTimeoutSec]{0}) otherwise SettingsConfigDefault[HttpRequestTimeoutSec],",
        "    MaxTreePathsCount = try Number.FromText(SystemTable[MaxTreePathsCount]{0}) otherwise SettingsConfigDefault[MaxTreePathsCount],",
        "",
        "    Result = ",
        "\t\t[",
        "\t\t\tAliasList = AliasList",
        "\t\t\t, TransactionLogPeriodInDays = TransactionLogPeriodInDays                  ",
        "\t\t\t, ConvertGMTLogTimeStampsToLocalTimeZone = ConvertGMTLogTimeStampsToLocalTimeZone",
        "\t\t\t, HttpRequestPool = HttpRequestPool",
        "\t\t\t, HttpRequestLatencySec = HttpRequestLatencySec",
        "\t\t\t, HttpRequestRecurringLatencySec = HttpRequestRecurringLatencySec",
        "\t\t\t, HttpRequestMaxAttempts = HttpRequestMaxAttempts",
        "\t\t\t, HttpRequestTimeoutSec = HttpRequestTimeoutSec",
        "\t\t\t, MaxTreePathsCount = MaxTreePathsCount",
        "\t\t]",
        "in",
        "    Result"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "ConnectionConfig",
      "lineageTag": "eeafee85-d327-40a2-8034-fa3a46e8d7a2",
      "queryGroupId": "97bbd2e1-8640-4dba-907f-449ec6205900",
      "text": [
        "let",
        "    Connection = ",
        "                [",
        "                      ConnectionType = if #\"02 CONNECTION TYPE\" = null then \"Service\" else #\"02 CONNECTION TYPE\"",
        "                    , #\"Host:Port\" = if #\"11 HTTP(S)://HOST:PORT\" = null then \"REST\" else #\"11 HTTP(S)://HOST:PORT\"",
        "                ],",
        "    Auth = ",
        "            if (#\"01 MODE\" = \"Desktop\") ",
        "            then",
        "                LoadXMLConnectionConfig",
        "            else",
        "                [",
        "                      Login = if #\"12 LOGIN\" = null then \"\" else #\"12 LOGIN\"",
        "                    , Password = if #\"13 PASSWORD\" = null then \"\" else #\"13 PASSWORD\"",
        "                    , Namespace = if #\"14 NAMESPACE\"  = null then \"\" else #\"14 NAMESPACE\"",
        "                ]",
        "in",
        "    Connection & Auth"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "SettingsConfig",
      "lineageTag": "58d57b9f-b1e7-4fe9-9532-12c04e52c8d9",
      "queryGroupId": "97bbd2e1-8640-4dba-907f-449ec6205900",
      "text": [
        "let",
        "    Source = ",
        "            SettingsConfigDefault ",
        "            & (if #\"01 MODE\" = \"Desktop\" then LoadXMLSettingsConfig else []) ",
        "            & (if #\"21 MAX TREE PATHS COUNT\" > 0 then [MaxTreePathsCount = #\"21 MAX TREE PATHS COUNT\"] else [])",
        "            & (",
        "                if #\"22 ALIASES\" <> \"\" ",
        "                    then         ",
        "                        let",
        "                            SplitTextByDelimiter = Splitter.SplitTextByAnyDelimiter({\";\", \",\"}, QuoteStyle.None)(#\"22 ALIASES\"), ",
        "                            TrimAliases = List.Transform( SplitTextByDelimiter, each Text.Trim ( _ ) )",
        "                        in",
        "                            [AliasList = TrimAliases]",
        "                    else",
        "                        []",
        "                )",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "fn_getRequestNo",
      "lineageTag": "e15dc236-86c3-4925-bbe5-b5e7ac5aff55",
      "queryGroupId": "260d8486-e37e-4e55-834e-df45f3f93161",
      "navigationStepName": "Navigation",
      "text": [
        "(RequestList as list, RequestName as text) =>",
        "    List.PositionOf(RequestList, List.Single(List.Select(RequestList, each _ = RequestName))) + 1"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "fn_sendHttpRequest",
      "lineageTag": "ca598f44-28c0-4f7a-b3d6-14eb5cfdd925",
      "queryGroupId": "260d8486-e37e-4e55-834e-df45f3f93161",
      "navigationStepName": "Navigation",
      "text": [
        "let func = (RequestContent as text, optional RawBody as text, optional RequstNo as nullable number) =>  ",
        "    let ",
        "        //fn_trySendReques Start",
        "        fn_trySendRequest = (AttemptNo as number, optional ResponseMetaData as table) =>",
        "            let",
        "                // Request parameteres",
        "                NumberInPool = if (RequstNo = null) then 0 else RequstNo,  ",
        "                RequestDelay = if (AttemptNo <= 1)",
        "                                then ",
        "                                    if (Number.Mod(NumberInPool, HttpRequestPool) = 0) //Pooling",
        "                                    then HttpRequestLatencySec",
        "                                    else 0",
        "                                else (AttemptNo - 1) * HttpRequestRecurringLatencySec",
        "                ,",
        "                                    ",
        "                // Request URL, headers, options",
        "                //// Request = ConnectionConfig[#\"Host:Port\"] & \"/api/v1/\",",
        "                // Avoiding a dynamic data source when updating on the Service",
        "                Request = #\"11 HTTP(S)://HOST:PORT\" & \"/api/v1/\",",
        "                Options = [",
        "                        Headers = [",
        "                                    #\"Authorization\" = AuthType & \" \" & Auth, ",
        "                                    #\"Content-Type\" = \"application/json;charset=utf-8\",",
        "                                    #\"Cache-Control\" = \"no-cache, must-revalidate\"",
        "                        ],",
        "                        RelativePath = RequestContent,",
        "                        Content = Text.ToBinary(RawBody),",
        "                        Timeout = #duration(0, 0, 0, HttpRequestTimeoutSec),",
        "                        IsRetry = true,",
        "                        ManualStatusHandling = ",
        "                            {",
        "                                200, 201, 202,                  // Success, record the request result  ",
        "                                408, 429, 503, 504, 509,        // Handled error, repeat the request, if failure again - record the request result",
        "                                401, 403, 404                   // Handled error, record the request result  ",
        "                            }",
        "                ], ",
        "",
        "                //Send Request & BufferData",
        "                SendRequest = Function.InvokeAfter( () => try Web.Contents(Request, Options), #duration(0, 0, 0, RequestDelay) ),",
        "                BufferedData = SendRequest[[HasError]] & [Value = Binary.Buffer(SendRequest[Value])],  //avoid a risk of multple PQ calls      ",
        "",
        "                //fn_checkRequestError Start",
        "                fn_checkRequestError = (Response as any) as record =>",
        "                    if Response[HasError]?",
        "                        then [HasError = Response[HasError]?, ErrorReason = Response[Error]?[Reason]?, ErrorMessage = Response[Error]?[Message]?, ErrorDetails = Response[Error]?[Details]?]",
        "                        else ",
        "                          let",
        "                              ServerResponse = try Value.Metadata(SendRequest[Value]?)[Response.Status]?,",
        "                              ServerError = ",
        "\t\t\t\t\t    if ServerResponse[HasError]? ",
        "\t\t\t\t\t    then",
        "\t\t\t\t\t        [ HasError = ServerResponse[HasError]?, ErrorReason = ServerResponse[Error]?[Reason]?, ErrorMessage = ServerResponse[Error]?[Message]?, ErrorDetails = ServerResponse[Error]?[Details]? ]",
        "\t\t\t\t\t    else if not ServerResponse[HasError] and ServerResponse[Value] = null",
        "\t\t\t\t\t    then ",
        "\t\t\t\t\t        [ HasError = true, ErrorReason = \"Unknown\", ErrorMessage = \"Incorrect connection or authorization parameters may have been specified\", ErrorDetails = null ]",
        "\t\t\t\t\t    else",
        "\t\t\t\t\t\t[ HasError = false, ErrorReason = null, ErrorMessage = null, ErrorDetails = null ]",
        "                          in",
        "                            ServerError",
        "                ,",
        "                //fn_checkRequestError End",
        "",
        "                Error = fn_checkRequestError(BufferedData),",
        "                HttpResponseStatus = try Value.Metadata(SendRequest[Value]?)[Response.Status]? otherwise null, ",
        "                RequestResponseTime = if HttpResponseStatus <> null then DateTime.LocalNow() else null, // making sure the RequestStartTime and RequestResponseTime queries are executed in the correct order (the lazy evaluation effect)",
        "                AppendResponseMetaData = Table.InsertRows(    ResponseMetaData",
        "                                                            , Table.RowCount(ResponseMetaData)",
        "                                                            , {[  RequstNo = RequstNo",
        "                                                                , RequestContent = RequestContent",
        "                                                                , RequestBody = RawBody",
        "                                                                , AttemptNo = AttemptNo",
        "                                                                , RequestDelay = RequestDelay",
        "                                                                , RequestResponseTime = RequestResponseTime",
        "                                                                , HasError = Error[HasError]",
        "                                                                , ErrorReason = Error[ErrorReason]",
        "                                                                , ErrorMessage = Error[ErrorMessage]",
        "                                                                , ErrorDetails = Error[ErrorDetails]",
        "                                                                , HttpResponseStatus = HttpResponseStatus",
        "                                                            ]}",
        "                                                        ), ",
        "                RequestResult = if (Error[HasError]) ",
        "                then ",
        "                    Record.AddField([], \"@metadata\", AppendResponseMetaData)",
        "                else",
        "                    let                                ",
        "                        HttpRequestResult = if (List.MatchesAny({408, 429, 503, 504, 509}, each _ = Value.Metadata(BufferedData)[Response.Status]?) and AttemptNo < HttpRequestMaxAttempts)",
        "                                        then",
        "                                            @fn_trySendRequest(AttemptNo + 1, AppendResponseMetaData)                                                       // Repeat the request",
        "                                        else ",
        "                                            Record.AddField(try Json.Document(BufferedData[Value]) otherwise [], \"@metadata\", AppendResponseMetaData)       // Add @metadata field to the request result",
        "                    in",
        "                        HttpRequestResult",
        "                in",
        "                   RequestResult, ",
        "        //fn_trySendReques End",
        "        ",
        "        AuthType = if (ConnectionConfig[Namespace] = \"\") then \"Basic\" else \"CAMNamespace\",",
        "        Auth = Binary.ToText(",
        "                    Text.ToBinary(ConnectionConfig[Login] & ",
        "                    \":\" & ConnectionConfig[Password] & ",
        "                    ( if (ConnectionConfig[Namespace] = null or ConnectionConfig[Namespace] = \"\") then \"\" else \":\" & ConnectionConfig[Namespace] )",
        "                )               ",
        "                , BinaryEncoding.Base64), ",
        "        ",
        "        HttpRequestPool = SettingsConfig[HttpRequestPool], ",
        "        HttpRequestLatencySec = SettingsConfig[HttpRequestLatencySec],",
        "        HttpRequestRecurringLatencySec = SettingsConfig[HttpRequestRecurringLatencySec],",
        "        HttpRequestMaxAttempts = SettingsConfig[HttpRequestMaxAttempts],",
        "        HttpRequestTimeoutSec = SettingsConfig[HttpRequestTimeoutSec],",
        "        ResponseTable = fn_trySendRequest(1, #table(type table[",
        "                                                                  RequstNo = number",
        "                                                                , RequestContent = text",
        "                                                                , RequestBody = text",
        "                                                                , AttemptNo = number",
        "                                                                , RequestDelay = number",
        "                                                                , RequestResponseTime = datetime                                                                ",
        "                                                                , HasError = logical",
        "                                                                , ErrorReason = text",
        "                                                                , ErrorMessage = text",
        "                                                                , ErrorDetails = text",
        "                                                                , HttpResponseStatus = number",
        "                                                            ], {}) )",
        "    in",
        "        ResponseTable,",
        "",
        "    documentation = [",
        "    Documentation.Name =  \" fn_sendHttpRequest\",",
        "    Documentation.Description = \" \",",
        "    Documentation.LongDescription = \" Managing HTTP requests\",",
        "    Documentation.Category = \" Data extraction \",",
        "    Documentation.Source = \" \",",
        "    Documentation.Version = \" 1.6 \",",
        "    Documentation.Author = \" Alexey Zaitsev \",",
        "    Documentation.Examples = {[Description =  \"\",",
        "    Code = \" fn_sendHttpRequest( \"\"Users\"\", null, 1 ) \",",
        "    Result = \"A record in the format [ @odata.context as text, value as List, @metadata as Table ]\"]}",
        "    ]",
        "in",
        "    Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation))"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "fn_requestCubeData",
      "lineageTag": "64a23768-d6ec-4dda-934c-a3f03d71ef07",
      "queryGroupId": "260d8486-e37e-4e55-834e-df45f3f93161",
      "text": [
        "let func = (Cube as text, Dims as record, optional SuppressZeros as nullable logical, optional RequstNo as nullable number) =>  ",
        "        let",
        "            MDX1 = \"{ \"\"MDX\"\":\"\"SELECT \",",
        "            MDX2 = if (SuppressZeros = null or SuppressZeros = true) then \" NON EMPTY \" else \"\",",
        "            MDX3 = ",
        "                    let",
        "                        DimFilters = Record.ToTable(Dims),",
        "                        AddBracketsToName = Table.TransformColumns(DimFilters, { \"Name\", ( value ) => \"[\" & value & \"]\" }),",
        "                        CreateMembers = Table.FromRecords(Table.TransformRows(AddBracketsToName",
        "                                                                                    , ( row ) => Record.TransformFields(row, {\"Value\", each if List.IsEmpty( _ ) then { row[Name] & \".MEMBERS\" } else List.Transform( _ , each row[Name] & \".[\" & _ & \"]\" ) })",
        "                                                                )",
        "                        ),",
        "                        CreateAxes = Table.TransformColumns(CreateMembers, { \"Value\", ( value ) => \"{\" & Text.Combine(value, \",\") & \"}\" }),",
        "                        CombineAxes = Text.Combine(CreateAxes[Value], \" * \")",
        "                    in",
        "                        CombineAxes,",
        "            MDX4 = \" ON COLUMNS FROM [\" & Cube & \"]\"\" }\",",
        "            MDX = MDX1 & MDX2 & MDX3 & MDX4,",
        "    ",
        "        //SendRequest = fn_sendHttpRequest(\"ExecuteMDX?$expand=Axes($select=Tuples;$expand=Hierarchies($select=Name),Tuples($select=Ordinal;$expand=Members($select=Ordinal,Name,UniqueName))),Cells\", MDX, RequstNo)",
        "        //SendRequest = fn_sendHttpRequest(\"ExecuteMDX?$expand=Axes($expand=Hierarchies($select=Name),Tuples($select=Ordinal;$expand=Members($select=Ordinal,Name,UniqueName))),Cells\", MDX, RequstNo)",
        "        SendRequest = fn_sendHttpRequest(\"ExecuteMDX?$expand=Axes($expand=Tuples($select=Ordinal;$expand=Members($select=Ordinal,Name,UniqueName))),Cells($select=Ordinal,Value)\", MDX, RequstNo)",
        "    in",
        "        SendRequest,",
        "    ",
        "    documentation = [",
        "    Documentation.Name =  \" fn_requestCubeData\",",
        "    Documentation.Description = \" \",",
        "    Documentation.LongDescription = \" Returns cube data for the specified MDX expression \",",
        "    Documentation.Category = \" HTTP Request \",",
        "    Documentation.Source = \" \",",
        "    Documentation.Version = \" 2.0 \",",
        "    Documentation.Author = \" Alexey Zaitsev \",",
        "    Documentation.Examples = {[Description =  \"\",",
        "    Code = \" fn_requestCubeData(\"\"Cube1\"\", [Dim1 = {\"\"1\"\", \"\"2\"\", \"\"3\"\"}, Dim2 = {}, Dim3 = {\"\"Name\"\"}])\",",
        "    Result = \"Raw \"\"Cube1\"\" data for the specified dimension elements Dim1 and Dim3 and all elements Dim2\"]}",
        "    ]",
        "in",
        "    Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation))"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "sREST_Rules",
      "lineageTag": "503ec5f9-d221-4ef6-b810-067f56ef52f2",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "        then fn_sendHttpRequest(\"ModelCubes()?$select=Name,Rules\", null, fn_getRequestNo(SysHttpRequests, \"sREST_Rules\"))",
        "        else null",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_Processes",
      "lineageTag": "92481606-cfb9-41a8-8e64-eddb5246e6a2",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "        then fn_sendHttpRequest(\"Processes?$select=Name,PrologProcedure,MetadataProcedure,DataProcedure,EpilogProcedure\", null, fn_getRequestNo(SysHttpRequests, \"sREST_Processes\"))",
        "        else null",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_Configuration",
      "lineageTag": "0878dc99-a1be-4568-a6a7-9c2ecd7cc4d0",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "        then fn_sendHttpRequest(\"Configuration\", null, fn_getRequestNo(SysHttpRequests, \"sREST_Configuration\"))",
        "        else null",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_Server",
      "lineageTag": "3a80f0be-5302-4a73-b1e2-5a1cb120ca5c",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "        then fn_sendHttpRequest(\"Server\", null, fn_getRequestNo(SysHttpRequests, \"sREST_Server\"))",
        "        else null",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_CubeDimensions",
      "lineageTag": "e4bb5ac8-7ad3-4661-97e3-2e6596e54650",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "        then fn_sendHttpRequest(\"ModelCubes()?$select=Name&$expand=Dimensions($select=Name)\", null, fn_getRequestNo(SysHttpRequests, \"sREST_CubeDimensions\"))",
        "        else null              ",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_DimensionAttributes",
      "lineageTag": "b2df3695-a5c6-4fad-bc6a-b3390d40beec",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then fn_sendHttpRequest(\"Dimensions?$select=Name&$expand=Hierarchies($select=Name;$expand=ElementAttributes($select=Name,Type))\", null, fn_getRequestNo(SysHttpRequests, \"sREST_DimensionAttributes\"))",
        "        else null                ",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_DimensionElements",
      "lineageTag": "8e5503df-ce39-409b-8552-03df7489a4de",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Source = ",
        "    if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "    then",
        "        let",
        "            Aliases = SettingsConfig[AliasList],",
        "            AliasesPlaceHolders =   if List.IsEmpty(Aliases) ",
        "                                    then \"Attributes\" ",
        "                                    else ",
        "                                        let",
        "                                            Filters = List.Transform(Aliases, each \"Attributes/\" & _ )",
        "                                        in",
        "                                            \"Attributes/Caption,\" & Text.Combine(Filters, \",\"),",
        "            Request = \"Dimensions?$select=Name&$expand=Hierarchies($select=Name,Elements;$expand=Elements($select=Name,Type,Level,Index,\" & AliasesPlaceHolders & \",\"",
        "                & \"Parents;$expand=Parents($select=Name,\"",
        "                & \"Parents;$expand=Parents($select=Name,\"",
        "                & \"Parents;$expand=Parents($select=Name,\" ",
        "                & \"Parents;$expand=Parents($select=Name,\" ",
        "                & \"Parents;$expand=Parents($select=Name,\" ",
        "                & \"Parents;$expand=Parents($select=Name,\" ",
        "                & \"Parents;$expand=Parents($select=Name,\" ",
        "                & \"Parents;$expand=Parents($select=Name,\" ",
        "                & \"Parents;$expand=Parents($select=Name,\" ",
        "                & \"Parents;$expand=Parents($select=Name))))))))))\"",
        "                &\"))\",",
        "            SendRequest = fn_sendHttpRequest( Request, null, fn_getRequestNo(SysHttpRequests, \"sREST_DimensionElements\") )",
        "        in",
        "            SendRequest",
        "    else null",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_Users",
      "lineageTag": "d10341f6-061b-4093-860e-535b25e658ed",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then fn_sendHttpRequest(\"Users\", null, fn_getRequestNo(SysHttpRequests, \"sREST_Users\"))",
        "        else null",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_}ClientGroups",
      "lineageTag": "be046bd4-94e1-467e-b407-4772dfe821c3",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Cube = \"}ClientGroups\",",
        "    Dim1 = \"}Clients\",",
        "    Dim2 = \"}Groups\",",
        "    DimFilters = Record.FromList({{},{}}, {Dim1, Dim2}),",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then fn_requestCubeData(Cube, DimFilters, true, fn_getRequestNo(SysHttpRequests, \"sREST_}ClientGroups\"))",
        "        else null",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_}CubeSecurity",
      "lineageTag": "b6d23652-6abf-44e3-972f-1c53902deb8f",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Cube = \"}CubeSecurity\",",
        "    Dim1 = \"}Cubes\",",
        "    Dim2 = \"}Groups\",",
        "    DimFilters = Record.FromList({{},{}}, {Dim1, Dim2}),",
        "    Source =",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"  ",
        "        then fn_requestCubeData(Cube, DimFilters, true, fn_getRequestNo(SysHttpRequests, \"sREST_}CubeSecurity\"))",
        "        else null",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "fn_tabulateCubeData",
      "lineageTag": "0d70c881-2d72-454e-8dc6-e34a2bc22c4b",
      "queryGroupId": "260d8486-e37e-4e55-834e-df45f3f93161",
      "text": [
        "let func = (Axes as nullable list, Cells as nullable list, optional DimensionNames as nullable list) =>  ",
        "    let",
        "        //1. Axes members",
        "        AxesNullCheck = if Axes = null then {} else Axes,",
        "        ConvertAxesToTable = Table.FromList(AxesNullCheck, Splitter.SplitByNothing(), {\"AxesRecordSet\"}, null, ExtraValues.Ignore),",
        "        ExpandAxesRecordSet = Table.ExpandRecordColumn(ConvertAxesToTable, \"AxesRecordSet\", {\"Tuples\"}),",
        "        ExpandTuplesList = Table.ExpandListColumn(ExpandAxesRecordSet, \"Tuples\"),",
        "        ExpandTuplesRecordSet = Table.ExpandRecordColumn(ExpandTuplesList, \"Tuples\", {\"Ordinal\", \"Members\"}, {\"Tuples.Ordinal\", \"Tuples.Members\"}),",
        "        GetTargetTable =  Table.TransformColumns(ExpandTuplesRecordSet, ",
        "                                        { \"Tuples.Members\", ( value ) => ",
        "                                                let",
        "                                                    CreateTableFromListOfRecords = try Table.FromRecords(value, {\"Name\", \"UniqueName\"}) otherwise Table.FromRows({}, {\"Name\", \"UniqueName\"}),",
        "                                                    GetDimensionNames = Table.TransformColumns(CreateTableFromListOfRecords, ",
        "                                                                        { \"UniqueName\", ( value ) => Text.BetweenDelimiters(value, \"[\", \"].\", {0, RelativePosition.FromStart}, {0, RelativePosition.FromStart}) }",
        "                                                    ),",
        "                                                    PivotTable = Table.Pivot(GetDimensionNames, List.Distinct(GetDimensionNames[UniqueName]), \"UniqueName\", \"Name\")",
        "                                                in",
        "                                                   PivotTable ",
        "                                        }",
        "        ),",
        "        ColumnNames = if (DimensionNames = null or List.IsEmpty(DimensionNames))",
        "                then Table.ColumnNames(GetTargetTable[Tuples.Members]{0})",
        "                else DimensionNames,",
        "        ExpandTargetTable = Table.ExpandTableColumn(GetTargetTable, \"Tuples.Members\", Table.ColumnNames(GetTargetTable[Tuples.Members]{0}), ColumnNames),",
        "",
        "        //2. Cells",
        "        CellsNullCheck = if Cells = null then {} else Cells,",
        "        ConvertCellsToTable = Table.FromList(CellsNullCheck, Splitter.SplitByNothing(), {\"CellsRecordSet\"}, null, ExtraValues.Ignore),",
        "        ExpandCellsRecordSet = Table.ExpandRecordColumn(ConvertCellsToTable, \"CellsRecordSet\", {\"Ordinal\", \"Value\"}, {\"Cells.Ordinal\", \"Cells.Value\"}),",
        "",
        "        //3. Cells next to the Members ",
        "        CellsAlongMembers = Table.NestedJoin(",
        "                                ExpandTargetTable,",
        "                                \"Tuples.Ordinal\",   ",
        "                                ExpandCellsRecordSet,",
        "                                \"Cells.Ordinal\",",
        "                                \"Cells\",",
        "                                JoinKind.Inner",
        "        ),",
        "        ExpandCells = Table.ExpandTableColumn(CellsAlongMembers, \"Cells\", {\"Cells.Value\"}, {\"Value\"})",
        "    in",
        "        ExpandCells,",
        "    ",
        "    documentation = [",
        "    Documentation.Name =  \" fn_tabulateCubeData\",",
        "    Documentation.Description = \" \",",
        "    Documentation.LongDescription = \" Converts the raw data returned by an MDX query into a tabular form (the value of the cell is placed next to the dimension elements).",
        "                                    Ordinarily used with a dataset returned by the fn_requestCubeData() function. ",
        "                                    If explicit dimension names in the function call are omitted the dimension names from the Axes parameter data will be extracted. ",
        "                                    If the Axes list is empty the names must be specified explicitly in the third function parameter.\",",
        "    Documentation.Category = \" Data processing \",",
        "    Documentation.Source = \" \",",
        "    Documentation.Version = \" 2.0 \",",
        "    Documentation.Author = \" Alexey Zaitsev \",",
        "    Documentation.Examples = {[Description =  \"\",",
        "    Code = \" fn_tabulateCubeData( { Axes list }, { Cells list }, { Dim1, Dim2, Dim3 } ) \",",
        "    Result = \"A table in the format | Dim1 | Dim2 | Dim3 | Value |\"]}",
        "    ]",
        "in",
        "    Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation))"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "sREST_}ElementAttributes_}Groups",
      "lineageTag": "a8b60389-1020-4257-b5d6-532eb5bfdd85",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Cube = \"}ElementAttributes_}Groups\",",
        "    Dim1 = \"}Groups\",",
        "    Dim2 = \"}ElementAttributes_}Groups\",",
        "    DimFilters = Record.FromList({{},{}}, {Dim1, Dim2}),",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then fn_requestCubeData(Cube, DimFilters, true, fn_getRequestNo(SysHttpRequests, \"sREST_}ElementAttributes_}Groups\"))",
        "        else null",
        "in ",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_}StatsByCube",
      "lineageTag": "c097f7ee-389f-4ae6-9c9b-9e37e9814ec7",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Cube = \"}StatsByCube\",",
        "    Dim1 = \"}PerfCubes\",",
        "    Dim2 = \"}StatsStatsByCube\",",
        "    Dim3 = \"}TimeIntervals\",",
        "    DimFilters = Record.FromList({",
        "                                    {},",
        "                                    {\"Total Memory Used\", \"Memory Used for Views\", \"Memory Used for Calculations\", \"Memory Used for Feeders\", \"Memory Used for Input Data\", \"Number of Stored Calculated Cells\", \"Number of Populated String Cells\", \"Number of Populated Numeric Cells\", \"Number of Fed Cells\"},",
        "                                    {}//{\"LATEST\", \"0H00\", \"0H01\", \"0H02\", \"0H03\", \"0H04\", \"0H05\", \"0H06\", \"0H07\", \"0H08\", \"0H09\", \"0H10\", \"0H11\", \"0H12\", \"0H13\", \"0H14\", \"0H15\", \"0H16\", \"0H17\", \"0H18\", \"0H19\", \"0H20\", \"0H21\", \"0H22\", \"0H23\", \"1H00\", \"1H01\", \"1H02\", \"1H03\", \"1H04\", \"1H05\", \"1H06\", \"1H07\", \"1H08\", \"1H09\", \"1H10\", \"1H11\", \"1H12\", \"1H13\", \"1H14\", \"1H15\", \"1H16\", \"1H17\", \"1H18\", \"1H19\", \"1H20\", \"1H21\", \"1H22\", \"1H23\"}                                    ",
        "                                }, ",
        "                                {Dim1, Dim2, Dim3}),",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "        then fn_requestCubeData(Cube, DimFilters, true, fn_getRequestNo(SysHttpRequests, \"sREST_}StatsByCube\"))",
        "        else null",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_}StatsByClient",
      "lineageTag": "c9c8b9b0-9478-4de2-b54d-093405ce97ad",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Cube = \"}StatsByClient\",",
        "    Dim1 = \"}PerfClients\",",
        "    Dim2 = \"}StatsStatsByClient\",",
        "    Dim3 = \"}TimeIntervals\",",
        "    DimFilters = Record.FromList({",
        "                                {},",
        "                                {\"Message Count\", \"Request Count\"},",
        "                                {}//{\"LATEST\", \"0H00\", \"0H01\", \"0H02\", \"0H03\", \"0H04\", \"0H05\", \"0H06\", \"0H07\", \"0H08\", \"0H09\", \"0H10\", \"0H11\", \"0H12\", \"0H13\", \"0H14\", \"0H15\", \"0H16\", \"0H17\", \"0H18\", \"0H19\", \"0H20\", \"0H21\", \"0H22\", \"0H23\", \"1H00\", \"1H01\", \"1H02\", \"1H03\", \"1H04\", \"1H05\", \"1H06\", \"1H07\", \"1H08\", \"1H09\", \"1H10\", \"1H11\", \"1H12\", \"1H13\", \"1H14\", \"1H15\", \"1H16\", \"1H17\", \"1H18\", \"1H19\", \"1H20\", \"1H21\", \"1H22\", \"1H23\"}                               ",
        "                            }, ",
        "                            {Dim1, Dim2, Dim3}),",
        "    Source = ",
        "    if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\" ",
        "    then fn_requestCubeData(Cube, DimFilters, false, fn_getRequestNo(SysHttpRequests, \"sREST_}StatsByClient\"))",
        "    else null",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_}StatsForServer",
      "lineageTag": "d75f76e7-f14c-45e9-a400-3e671682169c",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Cube = \"}StatsForServer\",",
        "    Dim1 = \"}StatsStatsForServer\",",
        "    Dim2 = \"}TimeIntervals\",",
        "    DimFilters = Record.FromList({",
        "                            {},",
        "                            {}//{\"LATEST\", \"0H00\", \"0H01\", \"0H02\", \"0H03\", \"0H04\", \"0H05\", \"0H06\", \"0H07\", \"0H08\", \"0H09\", \"0H10\", \"0H11\", \"0H12\", \"0H13\", \"0H14\", \"0H15\", \"0H16\", \"0H17\", \"0H18\", \"0H19\", \"0H20\", \"0H21\", \"0H22\", \"0H23\", \"1H00\", \"1H01\", \"1H02\", \"1H03\", \"1H04\", \"1H05\", \"1H06\", \"1H07\", \"1H08\", \"1H09\", \"1H10\", \"1H11\", \"1H12\", \"1H13\", \"1H14\", \"1H15\", \"1H16\", \"1H17\", \"1H18\", \"1H19\", \"1H20\", \"1H21\", \"1H22\", \"1H23\"}                           ",
        "                        }, ",
        "                        {Dim1, Dim2}),",
        "    Source = ",
        "        if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "        then fn_requestCubeData(Cube, DimFilters, true, fn_getRequestNo(SysHttpRequests, \"sREST_}StatsForServer\"))",
        "        else null",
        "in",
        "    Source"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "sREST_MessageLog",
      "lineageTag": "0573f5ea-25e8-4910-8d82-cc359b8a4012",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "//let",
        "    //Period = SettingsConfig[MessageLogPeriodInDays],",
        "    ",
        "    //Result = if (Period < 0)",
        "    //then",
        "    //    null",
        "    //else",
        "        let",
        "            //StartDate = Date.StartOfDay(DateTime.LocalNow() + #duration(-Period, 0, 0, 0)),",
        "            //ODataStartDate = DateTime.ToText( StartDate, \"yyyy-MM-dd\" ) & \"T00:00:00Z\",",
        "            Source = ",
        "                if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "                //then fn_sendHttpRequest(\"MessageLog()?$filter=TimeStamp ge \" & ODataStartDate, null, fn_getRequestNo(SysHttpRequests, \"sREST_MessageLog\"))",
        "                then fn_sendHttpRequest(\"MessageLog()\", null, fn_getRequestNo(SysHttpRequests, \"sREST_MessageLog\"))",
        "                else null",
        "        in",
        "            Source",
        "//in",
        "//    Result"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Unknown",
      "isHidden": false
    },
    {
      "name": "sREST_TransactionLog",
      "lineageTag": "dd769d95-af30-4307-bb52-24095f2d15e6",
      "queryGroupId": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "text": [
        "let",
        "    Period = SettingsConfig[TransactionLogPeriodInDays],",
        "    ",
        "    Result = if (Period < 0)",
        "    then",
        "        null",
        "    else",
        "        let",
        "            StartDate = Date.StartOfDay(DateTime.LocalNow() + #duration(-Period, 0, 0, 0)),",
        "            ODataStartDate = DateTime.ToText( StartDate, \"yyyy-MM-dd\" ) & \"T00:00:00Z\",",
        "            Source = ",
        "                if (try ConnectionConfig[ConnectionType] otherwise \"REST\") = \"REST\"",
        "                then fn_sendHttpRequest(\"TransactionLogEntries?$filter=TimeStamp ge \" & ODataStartDate, null, fn_getRequestNo(SysHttpRequests, \"sREST_TransactionLog\"))",
        "                else null",
        "        in",
        "            Source",
        "in",
        "    Result"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "SettingsConfigDefault",
      "lineageTag": "f398eead-5a15-4b08-b1b9-b216dc9c50b6",
      "queryGroupId": "97bbd2e1-8640-4dba-907f-449ec6205900",
      "text": [
        "let",
        "    Result =",
        "\t\t\t\t[",
        "\t\t\t\t\t  AliasList = {}",
        "\t\t\t\t\t, InterfaceMaxTreeDepth = 11",
        "\t\t\t\t\t, MaxDimensionHierarchyDepth = 11",
        "\t\t\t\t\t, TransactionLogPeriodInDays = -1",
        "\t\t\t\t\t, ConvertGMTLogTimeStampsToLocalTimeZone = true                            ",
        "\t\t\t\t\t, HttpRequestPool = 120",
        "\t\t\t\t\t, HttpRequestLatencySec = 3",
        "\t\t\t\t\t, HttpRequestRecurringLatencySec = 1200",
        "\t\t\t\t\t, HttpRequestMaxAttempts = 3",
        "\t\t\t\t\t, HttpRequestTimeoutSec = 300",
        "\t\t\t\t\t, MaxTreePathsCount = 500000",
        "\t\t\t\t]",
        "in",
        "    Result"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Record",
      "isHidden": false
    },
    {
      "name": "Definitions",
      "lineageTag": "15abe158-ea21-4f08-b941-4f6d28dc4819",
      "queryGroupId": "7fd7b0ce-fb43-439a-a1c5-472bba61fea1",
      "text": [
        "let",
        "    Source = Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText(\"i44FAA==\", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type nullable text) meta [Serialized.Text = true]) in type table [Dummy = _t]),",
        "    #\"Changed Type\" = Table.TransformColumnTypes(Source,{{\"Dummy\", type text}})",
        "in",
        "    #\"Changed Type\""
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    Source = Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText(\\\"i44FAA==\\\", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type nullable text) meta [Serialized.Text = true]) in type table [Dummy = _t]),\\n    #\\\"Changed Type\\\" = Table.TransformColumnTypes(Source,{{\\\"Dummy\\\", type text}})\\nin\\n    #\\\"Changed Type\\\"\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Table_TransformAllColumns",
      "lineageTag": "8e276727-1012-40e2-b0a9-f56d3e98780a",
      "queryGroupId": "b78a3023-a97c-4455-9afc-61be43bd36dd",
      "text": [
        "let func = (Table as table, Function, TypeForColumns as type, optional ColumnNames as list) =>",
        "let",
        "    columnNames = if (ColumnNames = null) then Table.ColumnNames(Table) else ColumnNames,",
        "    Transformation = Table.TransformColumns( Table, List.Transform(columnNames, each {_, Function, TypeForColumns} ) )",
        "in",
        "    Transformation ,",
        "",
        "    documentation = [",
        "    Documentation.Name =  \" Table_TransformAllColumns \",",
        "    Documentation.Description = \" \",",
        "    Documentation.LongDescription = \" Transforms all columns of a <code>table</code> with one <code>function</code> and one <code>type</code>. Optionial <code>ColumnNames</code> to limit to a specific list. \",",
        "    Documentation.Category = \" Table \",",
        "    Documentation.Source = \" \",",
        "    Documentation.Version = \" 1.0 \",",
        "    Documentation.Author = \" Internet \",",
        "    Documentation.Examples = {[Description =  \" TBD \",",
        "    Code = \" Table_TransformAllColumns( #table( {\"\"TextColumn1\"\", \"\"TextColumn2\"\"}, List.Zip( { {\"\"123<code>456</code>\"\" ,\"\"789<code>101</code>\"\"}, {\"\"ABC<code>DEF</code>\"\" ,\"\"GHI<code>JKL</code>\"\"} } ) ), fnRemoveHtmlTags, type text) \",",
        "    Result = \" #table( {\"\"TextColumn1\"\", \"\"TextColumn2\"\"}, List.Zip( { {\"\"123456\"\" ,\"\"789101\"\"}, {\"\"ABCDEF\"\" ,\"\"GHIJKL\"\"} } ) ) \"]}",
        "    ]",
        " in  ",
        "    Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation))"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "Table_ExpandAnyColumn",
      "lineageTag": "5b64d225-6748-4feb-9fe2-33e015012bfc",
      "queryGroupId": "b78a3023-a97c-4455-9afc-61be43bd36dd",
      "text": [
        "let func = (Table as table, FieldToExpand as text, optional ColumnNames as list, optional NewColumnNames as list, optional PersistentType as type) as table =>",
        "let",
        "    Value = if PersistentType = null ",
        "            then try Record.Field(Table.SelectRows(Table, ( row ) =>  Value.Is(Record.Field(row, FieldToExpand), type list) or Value.Is(Record.Field(row, FieldToExpand), type table) ){0}, FieldToExpand) otherwise null",
        "            else null,",
        "    ExpendedTable = if PersistentType = type list or Value.Is(Value, type list) then Table.ExpandListColumn(Table, FieldToExpand) else ",
        "                    if PersistentType = type table or Value.Is(Value, type table) then Table.ExpandTableColumn(Table, FieldToExpand, if (ColumnNames = null) then Table.ColumnNames(Value) else ColumnNames, NewColumnNames) else",
        "                    Table",
        "in",
        "    ExpendedTable ,",
        "",
        "    documentation = [",
        "    Documentation.Name =  \" Table_TransformAllColumns \",",
        "    Documentation.Description = \" \",",
        "    Documentation.LongDescription = \" Transforms all columns of a <code>table</code> with one <code>function</code> and one <code>type</code>. Optionial <code>ColumnNames</code> to limit to a specific list. \",",
        "    Documentation.Category = \" Table \",",
        "    Documentation.Source = \" \",",
        "    Documentation.Version = \" 1.1 \",",
        "    Documentation.Author = \" Internet \",",
        "    Documentation.Examples = {[Description =  \" TBD \",",
        "    Code = \" Table_ExpandAnyColumn (SourceTable, ListOrTableType, null,  { new_1, new_2 }), \",",
        "    Result = \" Table with expanded ListOrTableType Field \"]}",
        "    ]",
        " in  ",
        "    Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation))"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "CubesTopN",
      "lineageTag": "b5880fa0-f67b-480c-8f7b-8a4fb69b6d46",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    Source = #table(type table[Number = number],",
        "                    {",
        "                        {3}, {5}, {10}",
        "                    }",
        "    ),",
        "    CubesCount = List.Count(Cubes[Cube]),",
        "    ResultNumber = Table.Combine({ Table.SelectRows(Source, each [Number] < CubesCount), #table(type table[Number = number], { {CubesCount} }) }),",
        "    ResultTable = Table.AddColumn(ResultNumber, \"SelectedValue\", each if [Number] < CubesCount then Number.ToText([Number]) else \"All\", type text)",
        "in",
        "    ResultTable"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    Source = #table(type table[Number = number],\\n                    {\\n                        {3}, {5}, {10}\\n                    }\\n    ),\\n    CubesCount = List.Count(Cubes[Cube]),\\n    ResultNumber = Table.Combine({ Table.SelectRows(Source, each [Number] < CubesCount), #table(type table[Number = number], { {CubesCount} }) }),\\n    ResultTable = Table.AddColumn(ResultNumber, \\\"SelectedValue\\\", each if [Number] < CubesCount then Number.ToText([Number]) else \\\"All\\\", type text)\\nin\\n    ResultTable\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "fn_reverseHierarchy",
      "lineageTag": "91b4874f-4067-44d2-99d5-38abba244d60",
      "queryGroupId": "75a65484-47a4-4b34-8810-b6d084f04da7",
      "text": [
        "(Source as table, fields as list, optional HierarchyPath as text) as table =>",
        "    Table.FromRecords(",
        "\t\tTable.TransformRows(Source, (row) => ",
        "\t\t\tlet",
        "\t\t\t\tRecordToReverse = Record.SelectFields(row, fields),",
        "\t\t\t\tReversedRow = List.Select(List.Reverse(Record.ToList(RecordToReverse)), each _ <> null),",
        "\t\t\t\tFieldsCount = List.Count(ReversedRow),",
        "\t\t\t\tReversedRecord = Record.FromList(ReversedRow, List.FirstN(fields, FieldsCount)),",
        "\t\t\t\tReversedPath = if (HierarchyPath = null) then [] else [HierarchyPath = Text.Combine( ReversedRow , \"|\")],",
        "\t\t\t\t// CompleteRecord = Record.SelectFields(row, List.RemoveItems(Table.ColumnNames(Source), fields & { HierarchyPath })) & ReversedRecord & ReversedPath",
        "\t\t\t\tCompleteRecord = Record.SelectFields(row, List.RemoveItems(Record.FieldNames(row), fields & { HierarchyPath })) & ReversedRecord & ReversedPath",
        "\t\t\tin",
        "\t\t\t\tCompleteRecord",
        "\t\t)",
        "\t, Table.ColumnNames(Source), MissingField.UseNull)"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "fn_FlattenHierarchy (unused)",
      "lineageTag": "eed3b0fe-d6ea-423e-8015-8d58df77e3a2",
      "queryGroupId": "75a65484-47a4-4b34-8810-b6d084f04da7",
      "text": [
        "let ",
        "  fFlattenHierarchy = (",
        "    hierarchyTable as table",
        "    ,parentKeyColumnIdentifier as text",
        "    ,parentNameColumnIdentifier as text",
        "    ,childKeyColumnIdentifier as text",
        "    ,childNameColumnIdentifier as text",
        "  ) as table =>",
        "  let",
        "    #\"Get Root Parents\" = Table.Distinct(",
        "      Table.SelectColumns(",
        "        Table.NestedJoin(hierarchyTable",
        "          ,parentKeyColumnIdentifier",
        "          ,hierarchyTable",
        "          ,childKeyColumnIdentifier",
        "          ,\"ROOT.PARENTS\"",
        "          ,JoinKind.LeftAnti",
        "        )",
        "        ,{",
        "          parentKeyColumnIdentifier",
        "          ,parentNameColumnIdentifier",
        "        }",
        "      )",
        "    ),",
        "    #\"Generate Hierarchy\" = fGetNextHierarchyLevel(",
        "      #\"Get Root Parents\"",
        "      ,parentKeyColumnIdentifier",
        "      ,1",
        "    ),",
        "    fGetNextHierarchyLevel = (",
        "      parentsTable as table",
        "      ,nextParentKeyColumnIdentifier as text",
        "      ,hierarchyLevel as number",
        "    ) =>",
        "      let ",
        "        vNextParentKey = childKeyColumnIdentifier & Text.From(hierarchyLevel),",
        "        vNextParentName = childNameColumnIdentifier & Text.From(hierarchyLevel),",
        "        #\"Left Join - hierarchyTable (Get Children)\" = Table.NestedJoin(parentsTable",
        "          ,nextParentKeyColumnIdentifier",
        "          ,hierarchyTable",
        "          ,parentKeyColumnIdentifier",
        "          ,\"NODE.CHILDREN\"",
        "          ,JoinKind.LeftOuter",
        "        ),",
        "        #\"Expand Column - NODE.CHILDREN\" = Table.ExpandTableColumn(#\"Left Join - hierarchyTable (Get Children)\"",
        "          ,\"NODE.CHILDREN\"",
        "          ,{",
        "              childKeyColumnIdentifier",
        "              ,childNameColumnIdentifier",
        "          },{",
        "              vNextParentKey",
        "              ,vNextParentName",
        "          }",
        "        ),",
        "        #\"Filter Rows - Parents with Children\" = Table.SelectRows(#\"Expand Column - NODE.CHILDREN\"",
        "          ,each Record.Field(_,vNextParentKey) <> null ",
        "              and Record.Field(_,vNextParentKey) <> Record.Field(_,nextParentKeyColumnIdentifier)",
        "        ),",
        "        #\"Generate Next Hierarchy Level\" = if Table.IsEmpty(#\"Filter Rows - Parents with Children\")",
        "          then parentsTable ",
        "          else Table.Combine(",
        "            {",
        "              parentsTable",
        "              ,@fGetNextHierarchyLevel(",
        "                #\"Filter Rows - Parents with Children\"",
        "                ,vNextParentKey",
        "                ,hierarchyLevel + 1",
        "              )",
        "            }",
        "        )",
        "      in ",
        "        #\"Generate Next Hierarchy Level\",",
        "    #\"Add Column - HierarchyPath\" = Table.AddColumn(#\"Generate Hierarchy\",",
        "      \"HierarchyPath\"",
        "      ,each Text.Combine(",
        "        List.Transform(",
        "          Record.FieldValues(",
        "            Record.SelectFields(_,",
        "              List.Select(Table.ColumnNames(#\"Generate Hierarchy\")",
        "                ,each Text.StartsWith(_,childKeyColumnIdentifier) ",
        "                  or Text.StartsWith(_,parentKeyColumnIdentifier)",
        "              )",
        "            )",
        "          )",
        "          ,each Text.From(_)",
        "        )",
        "        ,\"|\"",
        "      )",
        "      ,type text",
        "    ),",
        "    #\"Add Column - HierarchyNodeID\" = Table.AddColumn(#\"Add Column - HierarchyPath\",",
        "      \"HierarchyNodeID\"",
        "      ,each List.Last(Text.Split([HierarchyPath],\"|\"))",
        "      ,type text",
        "    ),",
        "    #\"Add Column - HierarchyLevel\" = Table.AddColumn(#\"Add Column - HierarchyNodeID\",",
        "      \"HierarchyLevel\"",
        "      ,each List.Count(Text.Split([HierarchyPath],\"|\"))",
        "      ,Int64.Type",
        "    ),",
        "    #\"Add Column - IsLeafLevel\" = Table.AddColumn(#\"Add Column - HierarchyLevel\",",
        "      \"IsLeafLevel\"",
        "      ,each List.Contains(",
        "          List.Transform(",
        "            Table.Column(",
        "              Table.NestedJoin(hierarchyTable",
        "              ,childKeyColumnIdentifier",
        "              ,hierarchyTable",
        "              ,parentKeyColumnIdentifier",
        "              ,\"LEAFLEVEL.CHILDREN\"",
        "              ,JoinKind.LeftAnti",
        "              )",
        "              ,childKeyColumnIdentifier",
        "            )",
        "            ,each Text.From(_)",
        "          )",
        "        ,List.Last(Text.Split([HierarchyPath],\"|\"))",
        "      )",
        "      ,type logical",
        "    )",
        "  in",
        "    #\"Add Column - IsLeafLevel\",",
        "  //Documentation",
        "  fFlattenHierarchyType = type function (",
        "    hierarchyTable as (type table meta [",
        "      Documentation.FieldCaption = \"Hierarchy\"",
        "      ,Documentation.LongDescription = \"A table containing a parent-child hierarchy\"",
        "      ]",
        "    )",
        "    ,parentKeyColumnIdentifier as (type text meta [",
        "      Documentation.FieldCaption = \"Parent Key Column Identifier\"",
        "      ,Documentation.LongDescription = \"The name of the column used to identify the key of the parent node in the hierarchy\"",
        "      ,Documentation.SampleValues = { \"ParentID\" }",
        "      ]",
        "    )",
        "    ,parentNameColumnIdentifier as (type text meta [",
        "      Documentation.FieldCaption = \"Parent Name Column Identifier\"",
        "      ,Documentation.LongDescription = \"The name of the column used to identify the name of the parent node in the hierarchy\"",
        "      ,Documentation.SampleValues = { \"ParentName\" }",
        "      ]",
        "    )",
        "    ,childKeyColumnIdentifier as (type text meta [",
        "      Documentation.FieldCaption = \"Child Key Column Identifier\"",
        "      ,Documentation.LongDescription = \"The name of the column used to identify the key of the child node in the hierarchy\"",
        "      ,Documentation.SampleValues = { \"ChildID\" }",
        "      ]",
        "    )",
        "    ,childNameColumnIdentifier as (type text meta [",
        "      Documentation.FieldCaption = \"Child Name Column Identifier\"",
        "      ,Documentation.LongDescription = \"The name of the column used to identify the name of the child node in the hierarchy\"",
        "      ,Documentation.SampleValues = { \"ChildName\" }",
        "      ]",
        "    )",
        "  ) as list meta [",
        "    Documentation.Name = \"fFlattenHierarchy\"",
        "    ,Documentation.LongDescription = \"Returns a flattened hierarchy table from a parent-child hierarchy table input.\"",
        "      & \"The number of columns returned is based on the depth of the hierarchy. Each child node will be prefixed\"",
        "      & \"with the value specified for the childNameColumnIdentifier parameter\"",
        "    ,Documentation.Examples = {",
        "      [",
        "      Description = \"Returns a flattened hierarchy table from a parent-child hierarchy table\"",
        "      ,Code = \"fFlattenHierarchy(barksdaleOrganisation, \"\"ParentNodeID\"\", \"\"ParentNodeName\"\", \"\"ChildNodeID\"\", \"\"ChildNodeName\"\")\"",
        "      ,Result = \"{100,2,3,51,62,\"\"Stringer\"\",\"\"Shamrock\"\",\"\"Slim Charles\"\",\"\"Bodie\"\",\"\"Pudding\"\",5,\"\"100|2|3|51|62\"\",TRUE,62}\"",
        "        & \",{100,2,3,51,\"\"Stringer\"\",\"\"Shamrock\"\",\"\"Slim Charles\"\",\"\"Bodie\"\",4,\"\"100|2|3|51\"\",FALSE,51}\"",
        "      ]",
        "    }",
        "  ]",
        "in",
        "  Value.ReplaceType(fFlattenHierarchy, fFlattenHierarchyType)"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "fn_transformTimeIntervalsToDateTime",
      "lineageTag": "d1da622d-fb57-4b87-8608-5dabec421842",
      "queryGroupId": "50230ec8-2045-43ca-ae17-8c6ddb71ebef",
      "text": [
        "(SourceTable as table, TimeIntervalsColumnName as text) as table =>",
        "let",
        "    UtcNow = DateTimeZone.FixedUtcNow(),",
        "    NowYear = Date.Year(UtcNow),",
        "    NowMonth = Date.Month(UtcNow),",
        "    NowDay = Date.Day(UtcNow),",
        "    NowHour = Time.Hour(UtcNow),",
        "    NowMinute = Time.Minute(UtcNow),",
        "",
        "    LocalNow = DateTimeZone.FixedLocalNow(), ",
        "    ZoneHours = DateTimeZone.ZoneHours(LocalNow),",
        "    ZoneMinutes = DateTimeZone.ZoneMinutes(LocalNow),",
        "",
        "    AddDateTime = Table.TransformColumns(SourceTable, ",
        "                                        { \"DateTime\", ",
        "                                            each",
        "                                                let",
        "                                                    StrInterval = Text.From( _ ),",
        "                                                    DateTime = ",
        "                                                            if (StrInterval = \"LATEST\") // DateTime.FixedLocalNow() not strictly equal to Cognos \"LATEST\" time because of Http Request execution period",
        "                                                            then  ",
        "                                                                #datetime(",
        "                                                                            NowYear,",
        "                                                                            NowMonth,",
        "                                                                            NowDay,",
        "                                                                            NowHour,",
        "                                                                            0,",
        "                                                                            0",
        "                                                                )",
        "                                                            else if (Text.Contains(StrInterval, \"M\", Comparer.Ordinal) and StrInterval <> \"LATEST\")",
        "                                                            then",
        "                                                                #datetime(",
        "                                                                            NowYear,",
        "                                                                            NowMonth,",
        "                                                                            NowDay,",
        "                                                                            NowHour,",
        "                                                                            try Number.FromText(Text.AfterDelimiter(StrInterval, \"M\")) otherwise 0,",
        "                                                                            0",
        "                                                                ) ",
        "                                                                - #duration(",
        "                                                                            0, ",
        "                                                                            (try Number.FromText(Text.BeforeDelimiter(StrInterval, \"M\")) otherwise 0), ",
        "                                                                            0, ",
        "                                                                            0",
        "                                                                )                                                                                                                            ",
        "                                                            else if (Text.Contains(StrInterval, \"H\", Comparer.Ordinal) and StrInterval <> \"LATEST\")",
        "                                                            then   ",
        "                                                                #datetime(",
        "                                                                            NowYear,",
        "                                                                            NowMonth,",
        "                                                                            NowDay,",
        "                                                                            try Number.FromText(Text.AfterDelimiter(StrInterval, \"H\")) otherwise 0,",
        "                                                                            0,",
        "                                                                            0",
        "                                                                ) ",
        "                                                                - #duration(",
        "                                                                            (try Number.FromText(Text.BeforeDelimiter(StrInterval, \"H\")) otherwise 0),",
        "                                                                            0,",
        "                                                                            0,",
        "                                                                            0",
        "                                                                )         ",
        "                                                            else null,",
        "                                                    LocalDateTimeZone = if (SettingsConfig[ConvertGMTLogTimeStampsToLocalTimeZone])",
        "                                                                        then DateTimeZone.SwitchZone(DateTime.AddZone(DateTime, 0, 0), ZoneHours, ZoneMinutes)",
        "                                                                        else DateTime.AddZone(DateTime, ZoneHours, ZoneMinutes)                                                                        ",
        "                                                in",
        "                                                    LocalDateTimeZone",
        "                                    }                          ",
        "),",
        "    RemoveNonOverriddenRows = Table.SelectRows(AddDateTime, each [DateTime] <= UtcNow) // Cognos may not erase the values opposite the 0H* elements that still store the previous day's data",
        "in",
        "    RemoveNonOverriddenRows"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "fn_aggregateMTimeIntervalsToCurrentHour",
      "lineageTag": "3bb36c7c-2415-491f-a98f-3974b2511381",
      "queryGroupId": "50230ec8-2045-43ca-ae17-8c6ddb71ebef",
      "text": [
        "(SourceTable as table, GroupedColumns as list, AggregatedColumns as list, TimeIntervalsColumnName as text) as table =>",
        "let",
        "    SelectMRecords = Table.SelectRows(SourceTable, each ",
        "                                                        Text.From(Record.Field( _ ,  TimeIntervalsColumnName)) = \"LATEST\"                  ",
        "                                                    or Text.Contains(Record.Field( _ ,  TimeIntervalsColumnName), \"M\", Comparer.Ordinal)",
        "    ),",
        "    ReplceTimeIntervalsColumnValues = Table.ReplaceValue(",
        "                                                        SelectMRecords ",
        "                                                        , each Record.Field( _ ,  TimeIntervalsColumnName )",
        "                                                        , each \"LATEST\"",
        "                                                        , Replacer.ReplaceValue",
        "                                                        , { TimeIntervalsColumnName }                                                       ",
        "    ),            ",
        "    AggregatedTable = Table.Group(ReplceTimeIntervalsColumnValues, GroupedColumns, AggregatedColumns),",
        "    SelectHRecords = Table.SelectRows(SourceTable, each ",
        "                                                        Text.From(Record.Field( _ ,  TimeIntervalsColumnName)) <> \"LATEST\"                  ",
        "                                                    and Text.Contains(Record.Field( _ ,  TimeIntervalsColumnName), \"H\", Comparer.Ordinal)",
        "    ),",
        "    ResultTable = Table.Combine({ AggregatedTable, SelectHRecords })",
        "in",
        "    ResultTable"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "fn_convertUTCtoLocalTimeZone",
      "lineageTag": "95b346c2-2f6e-4a40-9a8c-a8a352d8ee3b",
      "queryGroupId": "50230ec8-2045-43ca-ae17-8c6ddb71ebef",
      "text": [
        "(UTC as datetimezone) as datetimezone =>",
        "let",
        "    ZoneHours = DateTimeZone.ZoneHours(DateTimeZone.FixedLocalNow()),",
        "    ZoneMinutes = DateTimeZone.ZoneMinutes(DateTimeZone.FixedLocalNow()),",
        "    LocalDateTimeZone = DateTimeZone.SwitchZone(UTC, ZoneHours, ZoneMinutes) ",
        "in",
        "    LocalDateTimeZone"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "fn_isSuccessfulHttpRequest",
      "lineageTag": "4763f2e9-45a4-4e7c-bded-9b50ff826ff1",
      "queryGroupId": "260d8486-e37e-4e55-834e-df45f3f93161",
      "text": [
        "(RequestTable as table) as logical => ",
        "    let",
        "        LastResponseStatus = Table.SelectRows(RequestTable, each [AttemptNo] = List.Max(RequestTable[AttemptNo]))[HttpResponseStatus]{0},",
        "        IsSuccessful = List.MatchesAny({200, 201, 202}, each _ = LastResponseStatus)",
        "    in ",
        "        IsSuccessful"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Function",
      "isHidden": false
    },
    {
      "name": "SysReportStatus",
      "lineageTag": "0a283e0c-1d57-438f-8c7b-2ff4bc662dce",
      "queryGroupId": "69125337-6a7a-4d67-abce-bf513c6746e2",
      "text": [
        "let",
        "",
        "    fn_httpResponseGroupScore = (Group as text) as number =>",
        "        let",
        "            GroupRequests = Table.SelectRows(SysHttpRequestLog, each [Group] = Group),",
        "            GroupRequestsCount = Table.RowCount(GroupRequests),",
        "            SuccessfulResponses = Table.SelectRows(GroupRequests, each [HttpResponseStatus] >= 200 and [HttpResponseStatus] < 300 ),",
        "            SuccessfulResponseCount = Table.RowCount(SuccessfulResponses),",
        "            SuccessfulEmptyResponseCount = Table.RowCount(Table.SelectRows(SuccessfulResponses, each [IsEmpty]))",
        "        in",
        "            if // no requests has been made",
        "                GroupRequestsCount = 0 then 3",
        "            else if  // all the http requests renurned an error",
        "                SuccessfulResponseCount = 0 then 2",
        "            else if // none of the http requests returned an error and all of them are empty",
        "                SuccessfulResponseCount = GroupRequestsCount and SuccessfulResponseCount = SuccessfulEmptyResponseCount then 3",
        "            else if // none of the http requests returned an error and some of them are not empty",
        "                SuccessfulResponseCount = GroupRequestsCount and SuccessfulResponseCount > SuccessfulEmptyResponseCount then 0",
        "            else // some http requests renurned an error",
        "                1",
        "        ,",
        "        ",
        "    //0 - OK, 1 - Some errors, 2 - Failure, 3 - Empty",
        "    Source = #table(type table[#\"Indicator\" = text, Status = Int64.Type],",
        "                {",
        "                    { \"1. Configuration file\", ",
        "                        if  // config is not used",
        "                            List.NonNullCount(Record.ToList(LoadXMLConnectionConfig)) = 0 or List.MatchesAll(Record.ToList(LoadXMLConnectionConfig), each _ = \"\") then 3",
        "                        else 0",
        "                    }",
        "                    , { \"2. Server Requests\", ",
        "                        if // no request has been made",
        "                            SysHttpRequestLog = null then 3",
        "                        else  // none of the server requests returned an error",
        "                            if not List.ContainsAny(SysHttpRequestLog[HasError], { true }) then 0",
        "                        else // all the server requests renurned an error or null",
        "                            if not List.ContainsAny(SysHttpRequestLog[HasError], { false }) then 2\t\t\t\t\t\t\t",
        "                        else // some server requests returned an error",
        "                            1",
        "                    }",
        "                    , { \"3. SSL Setup\",",
        "                        if // no request has been made",
        "                            SysHttpRequestLog = null then 3",
        "                        else if // all the server requests returned an error",
        "                            not List.ContainsAny(SysHttpRequestLog[HasError], { true })",
        "                            and // some errors have a specific SSL-related code",
        "                                (   // URL uses http protocol,  tm1s.cfg UseSSL = true",
        "                                    List.MatchesAny(SysHttpRequestLog[ErrorMessage], each Text.Contains ( _ , \"The server committed a protocol violation. Section=ResponseStatusLine\"))",
        "                                    or // URL uses https protocol,  tm1s.cfg UseSSL = false",
        "                                    List.MatchesAny(SysHttpRequestLog[ErrorMessage], each Text.Contains ( _ , \"The underlying connection was closed: An unexpected error occurred on a send.\"))",
        "                                    or // Self signed certificate is used",
        "                                    List.MatchesAny(SysHttpRequestLog[ErrorMessage], each Text.Contains ( _ , \"The underlying connection was closed: Could not establish trust relationship for the SSL/TLS secure channel.\"))",
        "                                )",
        "                      then 2",
        "                      else 0",
        "                    }",
        "                    , { \"4. Http Response: Basic Data\", ",
        "                        if // no request has been made",
        "                            SysHttpRequestLog = null then 3",
        "                        else    ",
        "                            fn_httpResponseGroupScore(\"Basic\")",
        "                    }",
        "                    , { \"5. Http Response: Stats\",",
        "                        if // no request has been made",
        "                            SysHttpRequestLog = null then 3",
        "                        else    ",
        "                            fn_httpResponseGroupScore(\"Stats\")",
        "                    }",
        "                    , { \"6. Http Response: TransLog\",",
        "                        if // no request has been made",
        "                            SysHttpRequestLog = null then 3",
        "                        else    ",
        "                            fn_httpResponseGroupScore(\"TransLog\")",
        "                    }",
        "                }",
        "    )",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n\\n    fn_httpResponseGroupScore = (Group as text) as number =>\\n        let\\n            GroupRequests = Table.SelectRows(SysHttpRequestLog, each [Group] = Group),\\n            GroupRequestsCount = Table.RowCount(GroupRequests),\\n            SuccessfulResponses = Table.SelectRows(GroupRequests, each [HttpResponseStatus] >= 200 and [HttpResponseStatus] < 300 ),\\n            SuccessfulResponseCount = Table.RowCount(SuccessfulResponses),\\n            SuccessfulEmptyResponseCount = Table.RowCount(Table.SelectRows(SuccessfulResponses, each [IsEmpty]))\\n        in\\n            if // no requests has been made\\n                GroupRequestsCount = 0 then 3\\n            else if  // all the http requests renurned an error\\n                SuccessfulResponseCount = 0 then 2\\n            else if // none of the http requests returned an error and all of them are empty\\n                SuccessfulResponseCount = GroupRequestsCount and SuccessfulResponseCount = SuccessfulEmptyResponseCount then 3\\n            else if // none of the http requests returned an error and some of them are not empty\\n                SuccessfulResponseCount = GroupRequestsCount and SuccessfulResponseCount > SuccessfulEmptyResponseCount then 0\\n            else // some http requests renurned an error\\n                1\\n        ,\\n        \\n    //0 - OK, 1 - Some errors, 2 - Failure, 3 - Empty\\n    Source = #table(type table[#\\\"Indicator\\\" = text, Status = Int64.Type],\\n                {\\n                    { \\\"1. Configuration file\\\", \\n                        if  // config is not used\\n                            List.NonNullCount(Record.ToList(LoadXMLConnectionConfig)) = 0 or List.MatchesAll(Record.ToList(LoadXMLConnectionConfig), each _ = \\\"\\\") then 3\\n                        else 0\\n                    }\\n                    , { \\\"2. Server Requests\\\", \\n                        if // no request has been made\\n                            SysHttpRequestLog = null then 3\\n                        else  // none of the server requests returned an error\\n                            if not List.ContainsAny(SysHttpRequestLog[HasError], { true }) then 0\\n                        else // all the server requests renurned an error or null\\n                            if not List.ContainsAny(SysHttpRequestLog[HasError], { false }) then 2\\t\\t\\t\\t\\t\\t\\t\\n                        else // some server requests returned an error\\n                            1\\n                    }\\n                    , { \\\"3. SSL Setup\\\",\\n                        if // no request has been made\\n                            SysHttpRequestLog = null then 3\\n                        else if // all the server requests returned an error\\n                            not List.ContainsAny(SysHttpRequestLog[HasError], { true })\\n                            and // some errors have a specific SSL-related code\\n                                (   // URL uses http protocol,  tm1s.cfg UseSSL = true\\n                                    List.MatchesAny(SysHttpRequestLog[ErrorMessage], each Text.Contains ( _ , \\\"The server committed a protocol violation. Section=ResponseStatusLine\\\"))\\n                                    or // URL uses https protocol,  tm1s.cfg UseSSL = false\\n                                    List.MatchesAny(SysHttpRequestLog[ErrorMessage], each Text.Contains ( _ , \\\"The underlying connection was closed: An unexpected error occurred on a send.\\\"))\\n                                    or // Self signed certificate is used\\n                                    List.MatchesAny(SysHttpRequestLog[ErrorMessage], each Text.Contains ( _ , \\\"The underlying connection was closed: Could not establish trust relationship for the SSL/TLS secure channel.\\\"))\\n                                )\\n                      then 2\\n                      else 0\\n                    }\\n                    , { \\\"4. Http Response: Basic Data\\\", \\n                        if // no request has been made\\n                            SysHttpRequestLog = null then 3\\n                        else    \\n                            fn_httpResponseGroupScore(\\\"Basic\\\")\\n                    }\\n                    , { \\\"5. Http Response: Stats\\\",\\n                        if // no request has been made\\n                            SysHttpRequestLog = null then 3\\n                        else    \\n                            fn_httpResponseGroupScore(\\\"Stats\\\")\\n                    }\\n                    , { \\\"6. Http Response: TransLog\\\",\\n                        if // no request has been made\\n                            SysHttpRequestLog = null then 3\\n                        else    \\n                            fn_httpResponseGroupScore(\\\"TransLog\\\")\\n                    }\\n                }\\n    )\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "DataFiles_TransactionLog",
      "lineageTag": "028ae803-7c8b-4ec1-a041-5cee3e56bcc4",
      "queryGroupId": "6b9bd30e-c3b7-4f80-bccb-4793bd9fbb08",
      "text": [
        "let",
        "    Result = ",
        "        if ConnectionConfig[ConnectionType] = \"DataFiles\" then",
        "            let",
        "                Period = SettingsConfig[TransactionLogPeriodInDays],",
        "",
        "                Result = if (Period < 0)",
        "                then",
        "                    null",
        "                else",
        "                    let",
        "                        EndDateTime = DateTime.ToText(DateTime.LocalNow(), \"yyyyMMddhhmmss\"),",
        "                        StartDateTime = DateTime.ToText(Date.StartOfDay(DateTime.LocalNow() + #duration(-Period, 0, 0, 0)), \"yyyyMMddhhmmss\"),",
        "                        //Source = ( try Table.Buffer(Folder.Files(ConnectionConfig[LogFilesPath])) otherwise Table.FromRecords({ [Name = null, Extension = null] }) ),",
        "                        // Avoiding a dynamic data source when updating on the Service",
        "                        Source = ( try Table.Buffer(Folder.Files(#\"32 LOG FILES PATH\")) otherwise Table.FromRecords({ [Name = null, Extension = null] }) )[[Name], [Extension]],",
        "                        ExtSelection = Table.SelectRows(Source, each FileExtentions{[Name = \"TransactionLog\"]}[Extension] = Text.From([Extension])),",
        "                        LogNameSelection = Table.SelectRows(ExtSelection, each Text.StartsWith( [Name], KeyWords[TransactionLogRef] )),",
        "                        RemoveExtensionFromName = Table.ReplaceValue(  ",
        "                                                                        LogNameSelection",
        "                                                                        , each [Extension]",
        "                                                                        , each \"\"",
        "                                                                        , Replacer.ReplaceText",
        "                                                                        , {\"Name\"}  ",
        "                        ),",
        "                        PeriodSelection = Table.SelectRows(RemoveExtensionFromName, each ( ",
        "                                                                                            [Name] >= KeyWords[TransactionLogRef] & StartDateTime and [Name] <= KeyWords[TransactionLogRef] & EndDateTime ",
        "                                                                                            or [Name] = KeyWords[TransactionLogRef]",
        "                                                                                        )",
        "                        ),",
        "                        CombineFiles = Table.AddColumn(",
        "                                                        PeriodSelection",
        "                                                        , \"CombinedFiles\"",
        "                                                        , each try Table.Buffer(Csv.Document(",
        "                                                            [Content]",
        "                                                            , { \"SetId\", \"TimeStamp\", \"ReplicatiomTime\", \"User\", \"ValueType\", \"OldValue\", \"NewValue\", \"Cube\", \"Tuple\" }",
        "                                                            , \",\"",
        "                                                            , ExtraValues.List",
        "                                                            , 65001",
        "                                                        )) otherwise null",
        "                        ),",
        "                        ExpandCombineFiles = Table.ExpandTableColumn(Table.FromList(CombineFiles[CombinedFiles], Splitter.SplitByNothing(), {\"CombinedFiles\"}, null, ExtraValues.Ignore), \"CombinedFiles\", ",
        "                                                                                                { \"SetId\", \"TimeStamp\", \"User\", \"OldValue\", \"NewValue\", \"Cube\", \"Tuple\" }",
        "                        ),",
        "                        RemoveIrrelevant = Table.SelectRows(ExpandCombineFiles, each not Text.StartsWith( [SetId], \"#\") and [Cube] <> \"\" and [Cube] <> null),",
        "                        CubeNameSelection = Table.SelectRows(RemoveIrrelevant, each ",
        "                                                let ",
        "                                                    Name = [Cube], ",
        "                                                    NameFilter = List.MatchesAny( KeyWords[SysMetaDataRef], each not Text.StartsWith( Name, _ ))",
        "                                                in ",
        "                                                    NameFilter",
        "                        ),",
        "                        RemoveEmptyValues = if Table.RowCount( CubeNameSelection ) > 0",
        "                                            then Table.FromRecords(Table.TransformRows(CubeNameSelection",
        "                                                                                        , (row) => Record.TransformFields(row, {\"Tuple\", each List.Select( _ , each _ <> \"\" ) })",
        "                                                                                        )",
        "                                            )",
        "                                            else CubeNameSelection,",
        "                        ConvertToDateTime = Table.TransformColumns(RemoveEmptyValues,",
        "                                                                                        { \"TimeStamp\", ( value ) =>",
        "                                                                                            let ",
        "                                                                                                DateTimeZone = #datetimezone(",
        "                                                                                                    (try Number.FromText(Text.Middle(value, 0, 4)) otherwise 0)",
        "                                                                                                    , (try Number.FromText(Text.Middle(value, 4, 2)) otherwise 0)",
        "                                                                                                    , (try Number.FromText(Text.Middle(value, 6, 2)) otherwise 0)",
        "                                                                                                    , (try Number.FromText(Text.Middle(value, 8, 2)) otherwise 0)",
        "                                                                                                    , (try Number.FromText(Text.Middle(value, 10, 2)) otherwise 0)",
        "                                                                                                    , (try Number.FromText(Text.Middle(value, 12, 2)) otherwise 0)",
        "                                                                                                    , 0",
        "                                                                                                    , 0",
        "                                                                                                    )",
        "                                                                                            in",
        "                                                                                                if (try Logical.FromText(SettingsConfig{[Name = \"ConvertGMTLogTimeStampsToLocalTimeZone\"]}[Value]) otherwise SettingsConfigDefault{[Name = \"ConvertGMTLogTimeStampsToLocalTimeZone\"]}[Value])",
        "                                                                                                then fn_convertUTCtoLocalTimeZone(DateTimeZone)",
        "                                                                                                else DateTimeZone",
        "                                                                                        }",
        "                        ),",
        "                        Result = ConvertToDateTime[[TimeStamp], [User], [Cube], [Tuple], [OldValue], [NewValue]]",
        "                    in",
        "                        Result",
        "                in Result",
        "        else",
        "            null",
        "in",
        "    Result"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Null",
      "isHidden": false
    },
    {
      "name": "MemoryMetrics",
      "lineageTag": "e96bba20-0bcb-468f-90be-69a52eb0d11d",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    Source = #table(type table[Name = text, Metric = text],",
        "        {",
        "            { \"cubes\",          \"Total Memory Used\" },",
        "            { \"views\",          \"Memory Used for Views\" },",
        "            { \"calculations\",   \"Memory Used for Calculations\" },",
        "            { \"feeders\",        \"Memory Used for Feeders\" },",
        "            { \"input data\",     \"Memory Used for Input Data\" }",
        "        }",
        "    )",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    Source = #table(type table[Name = text, Metric = text],\\n        {\\n            { \\\"cubes\\\",          \\\"Total Memory Used\\\" },\\n            { \\\"views\\\",          \\\"Memory Used for Views\\\" },\\n            { \\\"calculations\\\",   \\\"Memory Used for Calculations\\\" },\\n            { \\\"feeders\\\",        \\\"Memory Used for Feeders\\\" },\\n            { \\\"input data\\\",     \\\"Memory Used for Input Data\\\" }\\n        }\\n    )\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "MetricsTimeScale",
      "lineageTag": "2feb23c3-ae2a-4d70-b092-012c79f55467",
      "queryGroupId": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "text": [
        "let",
        "    Source = Table.FromList(List.Distinct( List.Combine({ CubeStats[HoursOffset], ServerStats[HoursOffset] }) ), Splitter.SplitByNothing(), {\"HoursOffset\"}, null, ExtraValues.Ignore),",
        "    ChangeType = Table.TransformColumnTypes(Source,{{\"HoursOffset\", Int64.Type}})",
        "in",
        "    ChangeType"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    Source = Table.FromList(List.Distinct( List.Combine({ CubeStats[HoursOffset], ServerStats[HoursOffset] }) ), Splitter.SplitByNothing(), {\\\"HoursOffset\\\"}, null, ExtraValues.Ignore),\\n    ChangeType = Table.TransformColumnTypes(Source,{{\\\"HoursOffset\\\", Int64.Type}})\\nin\\n    ChangeType\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "Value_SafeDivision",
      "lineageTag": "5863547e-071f-4c3e-9ec7-46246c69d59d",
      "queryGroupId": "b78a3023-a97c-4455-9afc-61be43bd36dd",
      "text": [
        "let func = (value_1 as any, value_2 as any) =>",
        "    let",
        "        Quotient = try value_1 / value_2 otherwise 0",
        "    in",
        "        if List.Contains({ Number.PositiveInfinity,  Number.NegativeInfinity, null }, Quotient) or Number.IsNaN(Quotient) then 0 else Quotient",
        "    ,",
        "",
        "    documentation = [",
        "    Documentation.Name =  \" Value_SafeDivision \",",
        "    Documentation.Description = \" \",",
        "    Documentation.LongDescription = \" Safe arithmetic division operation \",",
        "    Documentation.Category = \" Value \",",
        "    Documentation.Source = \" \",",
        "    Documentation.Version = \" 1.0 \",",
        "    Documentation.Author = \" Alexey Zaitsev \",",
        "    Documentation.Examples = {[Description =  \" TBD \",",
        "    Code = \" Value_SafeDivision( 10, 0 ),  Value_SafeDivision( 10, \"\"zero\"\" )\",",
        "    Result = \" 0 \"]}",
        "    ]",
        " in  ",
        "    Value.ReplaceType(func, Value.ReplaceMetadata(Value.Type(func), documentation))"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Unknown",
      "isHidden": false
    },
    {
      "name": "xDel_Query1",
      "lineageTag": "0482a7b0-c89c-4af2-996b-4b9b6968288c",
      "text": [
        "let",
        "    RelatedObjects = xDel_Query2[Definitions],",
        "    //RelatedObjects = #\"xDel_Tree:Rules:Target<Source\"[RelatedObjects],",
        "    MaxTreePathsCount = SettingsConfig[MaxTreePathsCount],",
        "    InterfaceMaxTreeDepth = SettingsConfig[InterfaceMaxTreeDepth],",
        "    AvgRelatedObjects1 = ",
        "        Value_SafeDivision( ",
        "            try List.Count(List.Combine(RelatedObjects)) ",
        "            otherwise try  List.Count( Table.ExpandTableColumn(Table.FromList(RelatedObjects, Splitter.SplitByNothing(), {\"RelatedObjects\"}, null, ExtraValues.Error), \"RelatedObjects\", { \"RelatedObjects\" } )[RelatedObjects] )",
        "            otherwise 1",
        "        , List.Count(RelatedObjects) ",
        "        ), ",
        "    AvgRelatedObjects2 = if AvgRelatedObjects1 < 1 then 1 else AvgRelatedObjects1 ,",
        "    CalcMaxTreeDepth = Number.RoundDown( Number.Log( Value_SafeDivision(MaxTreePathsCount, List.Count(RelatedObjects)),  AvgRelatedObjects2 )),",
        "    MaxTreeDepth = if Number.IsNaN(CalcMaxTreeDepth) or CalcMaxTreeDepth <= 1 or CalcMaxTreeDepth > InterfaceMaxTreeDepth then InterfaceMaxTreeDepth else CalcMaxTreeDepth",
        "in",
        "    MaxTreeDepth"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Number",
      "isHidden": false
    },
    {
      "name": "SysStatusNo",
      "lineageTag": "e077cf34-0055-4447-a5a6-afc3bd61f050",
      "queryGroupId": "69125337-6a7a-4d67-abce-bf513c6746e2",
      "text": [
        "let",
        "    Source = #table(type table[No = number, Description = text, SymbolCode = Int64.Type],",
        "        {",
        "              { 0, \"OK\",                    128994  }",
        "            , { 1, \"Some errors/ Warning\",  128993  }",
        "            , { 2, \"Failure/ Critical\",     128992  }",
        "            , { 3, \"Empty\",                 9898    }",
        "        }",
        "    )",
        "in",
        "    Source"
      ],
      "isDirectQuery": false,
      "lastLoadedAsTableFormulaText": "{\"IncludesReferencedQueries\":false,\"RootFormulaText\":\"let\\n    Source = #table(type table[No = number, Description = text, SymbolCode = Int64.Type],\\n        {\\n              { 0, \\\"OK\\\",                    128994  }\\n            , { 1, \\\"Some errors/ Warning\\\",  128993  }\\n            , { 2, \\\"Failure/ Critical\\\",     128992  }\\n            , { 3, \\\"Empty\\\",                 9898    }\\n        }\\n    )\\nin\\n    Source\",\"ReferencedQueriesFormulaText\":{}}",
      "loadAsTableDisabled": false,
      "resultType": "Table",
      "isHidden": false
    },
    {
      "name": "xDel_Query2",
      "lineageTag": "f1e5d632-ef4b-4023-91aa-9c43baf93283",
      "text": [
        "Table.ReplaceValue(",
        "    Table.FromRecords({",
        "        [Name = \"Cindy\", Country = \"US\"],",
        "        [Name = \"Bob\", Country = \"CA\"]",
        "    }),",
        "    each [Country] = \"US\",",
        "    \"?\",",
        "    (currentValue, isUS, replacementValue) =>",
        "        if isUS then",
        "            Text.Repeat(replacementValue, Text.Length(currentValue))",
        "        else",
        "            currentValue,",
        "    {\"Name\", \"Country1\"}",
        ")"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "31 DATA FILES PATH",
      "lineageTag": "e7f3af23-5e36-4889-986a-86140c53fbe9",
      "description": "Optional. The absolute path to the model data files. Used with the CONNECTION TYPE = \"DataFiles\"\nFormat: \"Full_path_to_the_directory\\\"\nDefault value: \"X:\\\"",
      "queryGroupId": "3c598972-2685-4d67-9d26-73285509eef9",
      "text": [
        "\"C:\\Program Files\\ibm\\cognos\\tm1_64\\samples\\tm1\\sample_outdoors\\datafiles\\\" meta [IsParameterQuery=true, Type=\"Text\", IsParameterQueryRequired=false]"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Text",
      "isHidden": false
    },
    {
      "name": "32 LOG FILES PATH",
      "lineageTag": "b3995e1c-1fc1-4ed1-aad3-973a0328f3f4",
      "description": "Optional. The absolute path to the model log files. Used with the CONNECTION TYPE = \"DataFiles\"\nFormat: \"Full_path_to_the_directory\\\"\nDefault value: \"X:\\\"",
      "queryGroupId": "3c598972-2685-4d67-9d26-73285509eef9",
      "text": [
        "\"C:\\Program Files\\ibm\\cognos\\tm1_64\\samples\\tm1\\sample_outdoors\\logfiles\\\" meta [IsParameterQuery=true, Type=\"Text\", IsParameterQueryRequired=false]"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Exception",
      "isHidden": false
    },
    {
      "name": "fn_getProcessVariablesDict",
      "lineageTag": "587e057a-492f-47d0-8fb5-85400f3ff4dc",
      "queryGroupId": "d5716580-3088-432c-bbda-345a91cb55ec",
      "text": [
        "// Function prepares Processes variables Dictionary",
        "// Parameters: ",
        "//      TextToParse: Prepared code ( returned by prepareCodeContent() );",
        "//      VariableQuote = \"'\" for Processes",
        "// ++++++++++++++++++++++++++++++++++++++++++++++++",
        "(TextToParse as text, VariableQuote as text) as list =>  ",
        "let",
        "// Select variables: keys cannot contain special symbols, values are not functions",
        "    Rows = Text.Split(TextToParse, \";\"),",
        "    RawsKeyValue = List.Transform(Rows, each if Text.Contains( _ , \"=\" ) then Splitter.SplitTextByAnyDelimiter({ \"@=\", \"=\" })( _ ) else { null, _ } ),",
        "    // 0 - Key, 1 - Value",
        "    VariableDict = List.Select(RawsKeyValue, each _{0} <> null and not Text_ContainsAnyOf( _{0} , { \"(\", \"[\" } ) and not Text_ContainsAnyOf( _{1} , { \"(\", \"[\" } )),",
        "    ",
        "    Counter = List.Count(VariableDict),",
        "    // Private function replaces variable references with real values   ",
        "    fn_getRealVairableValue = (i as number, optional DictToSearchIn as list) as list =>",
        "        let",
        "            ReferredVariableKey = VariableDict{i}{1},",
        "            VariableNewValue = if Text.Contains( ReferredVariableKey, VariableQuote ) then ReferredVariableKey else try List.Last(List.Select(DictToSearchIn, each _{0} = ReferredVariableKey)){1} otherwise VariableQuote & VariableQuote,",
        "            TransformedVariableDict = if DictToSearchIn = null then {{ VariableDict{i}{0}, VariableNewValue }} else DictToSearchIn & {{ VariableDict{i}{0}, VariableNewValue }}",
        "        in",
        "            if i >= Counter - 1",
        "                then TransformedVariableDict",
        "                else @fn_getRealVairableValue(i + 1, TransformedVariableDict),",
        "    ",
        "    ReplaceVariableReferenceWithValue = fn_getRealVairableValue(0)",
        "in",
        "    ReplaceVariableReferenceWithValue"
      ],
      "loadAsTableDisabled": true,
      "resultType": "Exception",
      "isHidden": false
    }
  ],
  "queryGroups": [
    {
      "name": "Settings",
      "id": "004f1c76-b8e8-4802-b3cf-dc4e36302980",
      "description": ""
    },
    {
      "name": "Data",
      "id": "1f64aa30-eeb6-41d5-ae4d-8b32b05dc453",
      "order": 2,
      "description": ""
    },
    {
      "name": "Functions",
      "id": "8ba10b3b-b10b-4008-89c5-e5a864ef3dc8",
      "order": 1,
      "description": ""
    },
    {
      "name": "SysData",
      "id": "69125337-6a7a-4d67-abce-bf513c6746e2",
      "order": 4,
      "description": ""
    },
    {
      "name": "MetaData",
      "id": "3377eb56-03e4-4ce7-968d-bb4471d7fb25",
      "order": 1,
      "description": "",
      "parentId": "1f64aa30-eeb6-41d5-ae4d-8b32b05dc453"
    },
    {
      "name": "UserData",
      "id": "50e995dc-4586-4cd4-9740-59ce2b766d9e",
      "order": 2,
      "description": "",
      "parentId": "1f64aa30-eeb6-41d5-ae4d-8b32b05dc453"
    },
    {
      "name": "Lib",
      "id": "0ad8d95b-705b-45fe-bf0e-0177cda0d700",
      "description": "",
      "parentId": "8ba10b3b-b10b-4008-89c5-e5a864ef3dc8"
    },
    {
      "name": "Measures",
      "id": "7fd7b0ce-fb43-439a-a1c5-472bba61fea1",
      "description": "",
      "parentId": "1f64aa30-eeb6-41d5-ae4d-8b32b05dc453"
    },
    {
      "name": "Configuration",
      "id": "97bbd2e1-8640-4dba-907f-449ec6205900",
      "order": 1,
      "description": "",
      "parentId": "004f1c76-b8e8-4802-b3cf-dc4e36302980"
    },
    {
      "name": "Params",
      "id": "3c598972-2685-4d67-9d26-73285509eef9",
      "description": "",
      "parentId": "004f1c76-b8e8-4802-b3cf-dc4e36302980"
    },
    {
      "name": "RulesProcessesHandling",
      "id": "7e862cc9-af5a-4123-9678-c848a95d8d11",
      "order": 2,
      "description": "",
      "parentId": "8ba10b3b-b10b-4008-89c5-e5a864ef3dc8"
    },
    {
      "name": "Utils",
      "id": "75a65484-47a4-4b34-8810-b6d084f04da7",
      "order": 4,
      "description": "",
      "parentId": "8ba10b3b-b10b-4008-89c5-e5a864ef3dc8"
    },
    {
      "name": "StatCubesHandling",
      "id": "50230ec8-2045-43ca-ae17-8c6ddb71ebef",
      "order": 3,
      "description": "",
      "parentId": "8ba10b3b-b10b-4008-89c5-e5a864ef3dc8"
    },
    {
      "name": "DataExtraction",
      "id": "260d8486-e37e-4e55-834e-df45f3f93161",
      "order": 1,
      "description": "",
      "parentId": "8ba10b3b-b10b-4008-89c5-e5a864ef3dc8"
    },
    {
      "name": "DataFilesLoad",
      "id": "6b9bd30e-c3b7-4f80-bccb-4793bd9fbb08",
      "description": "",
      "parentId": "50e995dc-4586-4cd4-9740-59ce2b766d9e"
    },
    {
      "name": "RESTLoad",
      "id": "9e50717b-4179-4602-ab30-20fe245e94e2",
      "order": 1,
      "description": "",
      "parentId": "50e995dc-4586-4cd4-9740-59ce2b766d9e"
    },
    {
      "name": "BasicEx",
      "id": "b78a3023-a97c-4455-9afc-61be43bd36dd",
      "description": "",
      "parentId": "0ad8d95b-705b-45fe-bf0e-0177cda0d700"
    },
    {
      "name": "Private",
      "id": "d5716580-3088-432c-bbda-345a91cb55ec",
      "description": "",
      "parentId": "7e862cc9-af5a-4123-9678-c848a95d8d11"
    }
  ],
  "culture": "ru-RU",
  "firewallEnabled": true
}